
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Role
 * 
 */
export type Role = {
  id: number
  role: string
}

/**
 * Model ArticleType
 * 
 */
export type ArticleType = {
  id: number
  type: string
}

/**
 * Model HardwareType
 * 
 */
export type HardwareType = {
  id: number
  type: string
}

/**
 * Model DocumentType
 * 
 */
export type DocumentType = {
  id: number
  type: string
}

/**
 * Model User
 * 
 */
export type User = {
  id: number
  firstname: string
  lastname: string
  username: string
  email: string
  password: string
  createdAt: Date
  deletedAt: Date | null
  roleId: number
}

/**
 * Model Article
 * 
 */
export type Article = {
  id: number
  name: string
  subDescription: string
  description: string
  isPublished: boolean
  createdAt: Date
  deletedAt: Date | null
  modifiedAt: Date | null
  userId: number
  articleTypeId: number
  articleId: number | null
}

/**
 * Model Hardware
 * 
 */
export type Hardware = {
  id: number
  name: string
  brand: string
  subDescription: string
  description: string
  isDiy: boolean
  creationDate: Date
  discontinuationDate: Date | null
  createdAt: Date
  deletedAt: Date | null
  modifiedAt: Date | null
  commercialLinks: string[]
  userId: number
  hardwareTypeId: number
}

/**
 * Model ArticleDocument
 * 
 */
export type ArticleDocument = {
  id: number
  name: string
  mimetype: string
  buffer: Buffer
  size: number
  createdAt: Date
  documentTypeId: number
  userId: number
  articleId: number
}

/**
 * Model ArticleComment
 * 
 */
export type ArticleComment = {
  id: number
  content: string
  createdAt: Date
  deletedAt: Date | null
  modifiedAt: Date | null
  userId: number
  articleId: number
}

/**
 * Model HardwareDocument
 * 
 */
export type HardwareDocument = {
  id: number
  name: string
  mimetype: string
  buffer: Buffer
  size: number
  createdAt: Date
  documentTypeId: number
  userId: number
  hardwareId: number
}

/**
 * Model HardwareComment
 * 
 */
export type HardwareComment = {
  id: number
  content: string
  createdAt: Date
  deletedAt: Date | null
  modifiedAt: Date | null
  userId: number
  hardwareId: number
}

/**
 * Model Article_Hardware
 * 
 */
export type Article_Hardware = {
  assigneddAt: Date
  articleId: number
  hardwareId: number
  userId: number
}

/**
 * Model Hardware_Hardware
 * 
 */
export type Hardware_Hardware = {
  assigneddAt: Date
  firstHardwareId: number
  secondHardwareId: number
  userId: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Roles
 * const roles = await prisma.role.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<GlobalReject>;

  /**
   * `prisma.articleType`: Exposes CRUD operations for the **ArticleType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArticleTypes
    * const articleTypes = await prisma.articleType.findMany()
    * ```
    */
  get articleType(): Prisma.ArticleTypeDelegate<GlobalReject>;

  /**
   * `prisma.hardwareType`: Exposes CRUD operations for the **HardwareType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HardwareTypes
    * const hardwareTypes = await prisma.hardwareType.findMany()
    * ```
    */
  get hardwareType(): Prisma.HardwareTypeDelegate<GlobalReject>;

  /**
   * `prisma.documentType`: Exposes CRUD operations for the **DocumentType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentTypes
    * const documentTypes = await prisma.documentType.findMany()
    * ```
    */
  get documentType(): Prisma.DocumentTypeDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.article`: Exposes CRUD operations for the **Article** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Articles
    * const articles = await prisma.article.findMany()
    * ```
    */
  get article(): Prisma.ArticleDelegate<GlobalReject>;

  /**
   * `prisma.hardware`: Exposes CRUD operations for the **Hardware** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hardware
    * const hardware = await prisma.hardware.findMany()
    * ```
    */
  get hardware(): Prisma.HardwareDelegate<GlobalReject>;

  /**
   * `prisma.articleDocument`: Exposes CRUD operations for the **ArticleDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArticleDocuments
    * const articleDocuments = await prisma.articleDocument.findMany()
    * ```
    */
  get articleDocument(): Prisma.ArticleDocumentDelegate<GlobalReject>;

  /**
   * `prisma.articleComment`: Exposes CRUD operations for the **ArticleComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArticleComments
    * const articleComments = await prisma.articleComment.findMany()
    * ```
    */
  get articleComment(): Prisma.ArticleCommentDelegate<GlobalReject>;

  /**
   * `prisma.hardwareDocument`: Exposes CRUD operations for the **HardwareDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HardwareDocuments
    * const hardwareDocuments = await prisma.hardwareDocument.findMany()
    * ```
    */
  get hardwareDocument(): Prisma.HardwareDocumentDelegate<GlobalReject>;

  /**
   * `prisma.hardwareComment`: Exposes CRUD operations for the **HardwareComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HardwareComments
    * const hardwareComments = await prisma.hardwareComment.findMany()
    * ```
    */
  get hardwareComment(): Prisma.HardwareCommentDelegate<GlobalReject>;

  /**
   * `prisma.article_Hardware`: Exposes CRUD operations for the **Article_Hardware** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Article_Hardwares
    * const article_Hardwares = await prisma.article_Hardware.findMany()
    * ```
    */
  get article_Hardware(): Prisma.Article_HardwareDelegate<GlobalReject>;

  /**
   * `prisma.hardware_Hardware`: Exposes CRUD operations for the **Hardware_Hardware** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hardware_Hardwares
    * const hardware_Hardwares = await prisma.hardware_Hardware.findMany()
    * ```
    */
  get hardware_Hardware(): Prisma.Hardware_HardwareDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.11.0
   * Query Engine version: 8fde8fef4033376662cad983758335009d522acb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Role: 'Role',
    ArticleType: 'ArticleType',
    HardwareType: 'HardwareType',
    DocumentType: 'DocumentType',
    User: 'User',
    Article: 'Article',
    Hardware: 'Hardware',
    ArticleDocument: 'ArticleDocument',
    ArticleComment: 'ArticleComment',
    HardwareDocument: 'HardwareDocument',
    HardwareComment: 'HardwareComment',
    Article_Hardware: 'Article_Hardware',
    Hardware_Hardware: 'Hardware_Hardware'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RoleCountOutputType
   */


  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect = {
    users?: boolean
  }

  export type RoleCountOutputTypeGetPayload<S extends boolean | null | undefined | RoleCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RoleCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RoleCountOutputTypeArgs)
    ? RoleCountOutputType 
    : S extends { select: any } & (RoleCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RoleCountOutputType ? RoleCountOutputType[P] : never
  } 
      : RoleCountOutputType




  // Custom InputTypes

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect | null
  }



  /**
   * Count Type ArticleTypeCountOutputType
   */


  export type ArticleTypeCountOutputType = {
    articles: number
  }

  export type ArticleTypeCountOutputTypeSelect = {
    articles?: boolean
  }

  export type ArticleTypeCountOutputTypeGetPayload<S extends boolean | null | undefined | ArticleTypeCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ArticleTypeCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ArticleTypeCountOutputTypeArgs)
    ? ArticleTypeCountOutputType 
    : S extends { select: any } & (ArticleTypeCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ArticleTypeCountOutputType ? ArticleTypeCountOutputType[P] : never
  } 
      : ArticleTypeCountOutputType




  // Custom InputTypes

  /**
   * ArticleTypeCountOutputType without action
   */
  export type ArticleTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ArticleTypeCountOutputType
     */
    select?: ArticleTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type HardwareTypeCountOutputType
   */


  export type HardwareTypeCountOutputType = {
    hardwares: number
  }

  export type HardwareTypeCountOutputTypeSelect = {
    hardwares?: boolean
  }

  export type HardwareTypeCountOutputTypeGetPayload<S extends boolean | null | undefined | HardwareTypeCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HardwareTypeCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (HardwareTypeCountOutputTypeArgs)
    ? HardwareTypeCountOutputType 
    : S extends { select: any } & (HardwareTypeCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof HardwareTypeCountOutputType ? HardwareTypeCountOutputType[P] : never
  } 
      : HardwareTypeCountOutputType




  // Custom InputTypes

  /**
   * HardwareTypeCountOutputType without action
   */
  export type HardwareTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the HardwareTypeCountOutputType
     */
    select?: HardwareTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type DocumentTypeCountOutputType
   */


  export type DocumentTypeCountOutputType = {
    articleDocuments: number
    hardwareDocument: number
  }

  export type DocumentTypeCountOutputTypeSelect = {
    articleDocuments?: boolean
    hardwareDocument?: boolean
  }

  export type DocumentTypeCountOutputTypeGetPayload<S extends boolean | null | undefined | DocumentTypeCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DocumentTypeCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DocumentTypeCountOutputTypeArgs)
    ? DocumentTypeCountOutputType 
    : S extends { select: any } & (DocumentTypeCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DocumentTypeCountOutputType ? DocumentTypeCountOutputType[P] : never
  } 
      : DocumentTypeCountOutputType




  // Custom InputTypes

  /**
   * DocumentTypeCountOutputType without action
   */
  export type DocumentTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DocumentTypeCountOutputType
     */
    select?: DocumentTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    articles: number
    articleDocuments: number
    articleComments: number
    hardwares: number
    hardwareDocuments: number
    hardwareComments: number
    article_hardware: number
    hardware_hardware: number
  }

  export type UserCountOutputTypeSelect = {
    articles?: boolean
    articleDocuments?: boolean
    articleComments?: boolean
    hardwares?: boolean
    hardwareDocuments?: boolean
    hardwareComments?: boolean
    article_hardware?: boolean
    hardware_hardware?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type ArticleCountOutputType
   */


  export type ArticleCountOutputType = {
    articles: number
    articleDocuments: number
    articleComments: number
    article_hardware: number
  }

  export type ArticleCountOutputTypeSelect = {
    articles?: boolean
    articleDocuments?: boolean
    articleComments?: boolean
    article_hardware?: boolean
  }

  export type ArticleCountOutputTypeGetPayload<S extends boolean | null | undefined | ArticleCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ArticleCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ArticleCountOutputTypeArgs)
    ? ArticleCountOutputType 
    : S extends { select: any } & (ArticleCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ArticleCountOutputType ? ArticleCountOutputType[P] : never
  } 
      : ArticleCountOutputType




  // Custom InputTypes

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ArticleCountOutputType
     */
    select?: ArticleCountOutputTypeSelect | null
  }



  /**
   * Count Type HardwareCountOutputType
   */


  export type HardwareCountOutputType = {
    hardwareDocuments: number
    hardwareComments: number
    article_hardware: number
    firstHardwareOf: number
    secondHardwares: number
  }

  export type HardwareCountOutputTypeSelect = {
    hardwareDocuments?: boolean
    hardwareComments?: boolean
    article_hardware?: boolean
    firstHardwareOf?: boolean
    secondHardwares?: boolean
  }

  export type HardwareCountOutputTypeGetPayload<S extends boolean | null | undefined | HardwareCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HardwareCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (HardwareCountOutputTypeArgs)
    ? HardwareCountOutputType 
    : S extends { select: any } & (HardwareCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof HardwareCountOutputType ? HardwareCountOutputType[P] : never
  } 
      : HardwareCountOutputType




  // Custom InputTypes

  /**
   * HardwareCountOutputType without action
   */
  export type HardwareCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the HardwareCountOutputType
     */
    select?: HardwareCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Role
   */


  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    role: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    role: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    role: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    role?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    role?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    role?: true
    _all?: true
  }

  export type RoleAggregateArgs = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs = {
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithAggregationInput>
    by: RoleScalarFieldEnum[]
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }


  export type RoleGroupByOutputType = {
    id: number
    role: string
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect = {
    id?: boolean
    role?: boolean
    users?: boolean | Role$usersArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }


  export type RoleInclude = {
    users?: boolean | Role$usersArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }

  export type RoleGetPayload<S extends boolean | null | undefined | RoleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Role :
    S extends undefined ? never :
    S extends { include: any } & (RoleArgs | RoleFindManyArgs)
    ? Role  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'users' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends '_count' ? RoleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RoleArgs | RoleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'users' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends '_count' ? RoleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Role ? Role[P] : never
  } 
      : Role


  type RoleCountArgs = 
    Omit<RoleFindManyArgs, 'select' | 'include'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Role'> extends True ? Prisma__RoleClient<RoleGetPayload<T>> : Prisma__RoleClient<RoleGetPayload<T> | null, null>

    /**
     * Find one Role that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RoleFindUniqueOrThrowArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Role'> extends True ? Prisma__RoleClient<RoleGetPayload<T>> : Prisma__RoleClient<RoleGetPayload<T> | null, null>

    /**
     * Find the first Role that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoleFindFirstOrThrowArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs>
    ): Prisma.PrismaPromise<Array<RoleGetPayload<T>>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Create many Roles.
     *     @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    users<T extends Role$usersArgs= {}>(args?: Subset<T, Role$usersArgs>): Prisma.PrismaPromise<Array<UserGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Role base type for findUnique actions
   */
  export type RoleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUnique
   */
  export interface RoleFindUniqueArgs extends RoleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role base type for findFirst actions
   */
  export type RoleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: Enumerable<RoleScalarFieldEnum>
  }

  /**
   * Role findFirst
   */
  export interface RoleFindFirstArgs extends RoleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role findMany
   */
  export type RoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role create
   */
  export type RoleCreateArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }


  /**
   * Role createMany
   */
  export type RoleCreateManyArgs = {
    /**
     * The data used to create many Roles.
     */
    data: Enumerable<RoleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Role update
   */
  export type RoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }


  /**
   * Role upsert
   */
  export type RoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }


  /**
   * Role delete
   */
  export type RoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }


  /**
   * Role.users
   */
  export type Role$usersArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Role without action
   */
  export type RoleArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
  }



  /**
   * Model ArticleType
   */


  export type AggregateArticleType = {
    _count: ArticleTypeCountAggregateOutputType | null
    _avg: ArticleTypeAvgAggregateOutputType | null
    _sum: ArticleTypeSumAggregateOutputType | null
    _min: ArticleTypeMinAggregateOutputType | null
    _max: ArticleTypeMaxAggregateOutputType | null
  }

  export type ArticleTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type ArticleTypeSumAggregateOutputType = {
    id: number | null
  }

  export type ArticleTypeMinAggregateOutputType = {
    id: number | null
    type: string | null
  }

  export type ArticleTypeMaxAggregateOutputType = {
    id: number | null
    type: string | null
  }

  export type ArticleTypeCountAggregateOutputType = {
    id: number
    type: number
    _all: number
  }


  export type ArticleTypeAvgAggregateInputType = {
    id?: true
  }

  export type ArticleTypeSumAggregateInputType = {
    id?: true
  }

  export type ArticleTypeMinAggregateInputType = {
    id?: true
    type?: true
  }

  export type ArticleTypeMaxAggregateInputType = {
    id?: true
    type?: true
  }

  export type ArticleTypeCountAggregateInputType = {
    id?: true
    type?: true
    _all?: true
  }

  export type ArticleTypeAggregateArgs = {
    /**
     * Filter which ArticleType to aggregate.
     */
    where?: ArticleTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleTypes to fetch.
     */
    orderBy?: Enumerable<ArticleTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArticleTypes
    **/
    _count?: true | ArticleTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleTypeMaxAggregateInputType
  }

  export type GetArticleTypeAggregateType<T extends ArticleTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateArticleType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticleType[P]>
      : GetScalarType<T[P], AggregateArticleType[P]>
  }




  export type ArticleTypeGroupByArgs = {
    where?: ArticleTypeWhereInput
    orderBy?: Enumerable<ArticleTypeOrderByWithAggregationInput>
    by: ArticleTypeScalarFieldEnum[]
    having?: ArticleTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleTypeCountAggregateInputType | true
    _avg?: ArticleTypeAvgAggregateInputType
    _sum?: ArticleTypeSumAggregateInputType
    _min?: ArticleTypeMinAggregateInputType
    _max?: ArticleTypeMaxAggregateInputType
  }


  export type ArticleTypeGroupByOutputType = {
    id: number
    type: string
    _count: ArticleTypeCountAggregateOutputType | null
    _avg: ArticleTypeAvgAggregateOutputType | null
    _sum: ArticleTypeSumAggregateOutputType | null
    _min: ArticleTypeMinAggregateOutputType | null
    _max: ArticleTypeMaxAggregateOutputType | null
  }

  type GetArticleTypeGroupByPayload<T extends ArticleTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ArticleTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleTypeGroupByOutputType[P]>
        }
      >
    >


  export type ArticleTypeSelect = {
    id?: boolean
    type?: boolean
    articles?: boolean | ArticleType$articlesArgs
    _count?: boolean | ArticleTypeCountOutputTypeArgs
  }


  export type ArticleTypeInclude = {
    articles?: boolean | ArticleType$articlesArgs
    _count?: boolean | ArticleTypeCountOutputTypeArgs
  }

  export type ArticleTypeGetPayload<S extends boolean | null | undefined | ArticleTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ArticleType :
    S extends undefined ? never :
    S extends { include: any } & (ArticleTypeArgs | ArticleTypeFindManyArgs)
    ? ArticleType  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'articles' ? Array < ArticleGetPayload<S['include'][P]>>  :
        P extends '_count' ? ArticleTypeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ArticleTypeArgs | ArticleTypeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'articles' ? Array < ArticleGetPayload<S['select'][P]>>  :
        P extends '_count' ? ArticleTypeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ArticleType ? ArticleType[P] : never
  } 
      : ArticleType


  type ArticleTypeCountArgs = 
    Omit<ArticleTypeFindManyArgs, 'select' | 'include'> & {
      select?: ArticleTypeCountAggregateInputType | true
    }

  export interface ArticleTypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ArticleType that matches the filter.
     * @param {ArticleTypeFindUniqueArgs} args - Arguments to find a ArticleType
     * @example
     * // Get one ArticleType
     * const articleType = await prisma.articleType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ArticleTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ArticleTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ArticleType'> extends True ? Prisma__ArticleTypeClient<ArticleTypeGetPayload<T>> : Prisma__ArticleTypeClient<ArticleTypeGetPayload<T> | null, null>

    /**
     * Find one ArticleType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ArticleTypeFindUniqueOrThrowArgs} args - Arguments to find a ArticleType
     * @example
     * // Get one ArticleType
     * const articleType = await prisma.articleType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ArticleTypeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ArticleTypeFindUniqueOrThrowArgs>
    ): Prisma__ArticleTypeClient<ArticleTypeGetPayload<T>>

    /**
     * Find the first ArticleType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTypeFindFirstArgs} args - Arguments to find a ArticleType
     * @example
     * // Get one ArticleType
     * const articleType = await prisma.articleType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ArticleTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ArticleTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ArticleType'> extends True ? Prisma__ArticleTypeClient<ArticleTypeGetPayload<T>> : Prisma__ArticleTypeClient<ArticleTypeGetPayload<T> | null, null>

    /**
     * Find the first ArticleType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTypeFindFirstOrThrowArgs} args - Arguments to find a ArticleType
     * @example
     * // Get one ArticleType
     * const articleType = await prisma.articleType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ArticleTypeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ArticleTypeFindFirstOrThrowArgs>
    ): Prisma__ArticleTypeClient<ArticleTypeGetPayload<T>>

    /**
     * Find zero or more ArticleTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArticleTypes
     * const articleTypes = await prisma.articleType.findMany()
     * 
     * // Get first 10 ArticleTypes
     * const articleTypes = await prisma.articleType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleTypeWithIdOnly = await prisma.articleType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ArticleTypeFindManyArgs>(
      args?: SelectSubset<T, ArticleTypeFindManyArgs>
    ): Prisma.PrismaPromise<Array<ArticleTypeGetPayload<T>>>

    /**
     * Create a ArticleType.
     * @param {ArticleTypeCreateArgs} args - Arguments to create a ArticleType.
     * @example
     * // Create one ArticleType
     * const ArticleType = await prisma.articleType.create({
     *   data: {
     *     // ... data to create a ArticleType
     *   }
     * })
     * 
    **/
    create<T extends ArticleTypeCreateArgs>(
      args: SelectSubset<T, ArticleTypeCreateArgs>
    ): Prisma__ArticleTypeClient<ArticleTypeGetPayload<T>>

    /**
     * Create many ArticleTypes.
     *     @param {ArticleTypeCreateManyArgs} args - Arguments to create many ArticleTypes.
     *     @example
     *     // Create many ArticleTypes
     *     const articleType = await prisma.articleType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ArticleTypeCreateManyArgs>(
      args?: SelectSubset<T, ArticleTypeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ArticleType.
     * @param {ArticleTypeDeleteArgs} args - Arguments to delete one ArticleType.
     * @example
     * // Delete one ArticleType
     * const ArticleType = await prisma.articleType.delete({
     *   where: {
     *     // ... filter to delete one ArticleType
     *   }
     * })
     * 
    **/
    delete<T extends ArticleTypeDeleteArgs>(
      args: SelectSubset<T, ArticleTypeDeleteArgs>
    ): Prisma__ArticleTypeClient<ArticleTypeGetPayload<T>>

    /**
     * Update one ArticleType.
     * @param {ArticleTypeUpdateArgs} args - Arguments to update one ArticleType.
     * @example
     * // Update one ArticleType
     * const articleType = await prisma.articleType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ArticleTypeUpdateArgs>(
      args: SelectSubset<T, ArticleTypeUpdateArgs>
    ): Prisma__ArticleTypeClient<ArticleTypeGetPayload<T>>

    /**
     * Delete zero or more ArticleTypes.
     * @param {ArticleTypeDeleteManyArgs} args - Arguments to filter ArticleTypes to delete.
     * @example
     * // Delete a few ArticleTypes
     * const { count } = await prisma.articleType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ArticleTypeDeleteManyArgs>(
      args?: SelectSubset<T, ArticleTypeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArticleTypes
     * const articleType = await prisma.articleType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ArticleTypeUpdateManyArgs>(
      args: SelectSubset<T, ArticleTypeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ArticleType.
     * @param {ArticleTypeUpsertArgs} args - Arguments to update or create a ArticleType.
     * @example
     * // Update or create a ArticleType
     * const articleType = await prisma.articleType.upsert({
     *   create: {
     *     // ... data to create a ArticleType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArticleType we want to update
     *   }
     * })
    **/
    upsert<T extends ArticleTypeUpsertArgs>(
      args: SelectSubset<T, ArticleTypeUpsertArgs>
    ): Prisma__ArticleTypeClient<ArticleTypeGetPayload<T>>

    /**
     * Count the number of ArticleTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTypeCountArgs} args - Arguments to filter ArticleTypes to count.
     * @example
     * // Count the number of ArticleTypes
     * const count = await prisma.articleType.count({
     *   where: {
     *     // ... the filter for the ArticleTypes we want to count
     *   }
     * })
    **/
    count<T extends ArticleTypeCountArgs>(
      args?: Subset<T, ArticleTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArticleType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleTypeAggregateArgs>(args: Subset<T, ArticleTypeAggregateArgs>): Prisma.PrismaPromise<GetArticleTypeAggregateType<T>>

    /**
     * Group by ArticleType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleTypeGroupByArgs['orderBy'] }
        : { orderBy?: ArticleTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ArticleType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ArticleTypeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    articles<T extends ArticleType$articlesArgs= {}>(args?: Subset<T, ArticleType$articlesArgs>): Prisma.PrismaPromise<Array<ArticleGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ArticleType base type for findUnique actions
   */
  export type ArticleTypeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ArticleType
     */
    select?: ArticleTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTypeInclude | null
    /**
     * Filter, which ArticleType to fetch.
     */
    where: ArticleTypeWhereUniqueInput
  }

  /**
   * ArticleType findUnique
   */
  export interface ArticleTypeFindUniqueArgs extends ArticleTypeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ArticleType findUniqueOrThrow
   */
  export type ArticleTypeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ArticleType
     */
    select?: ArticleTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTypeInclude | null
    /**
     * Filter, which ArticleType to fetch.
     */
    where: ArticleTypeWhereUniqueInput
  }


  /**
   * ArticleType base type for findFirst actions
   */
  export type ArticleTypeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ArticleType
     */
    select?: ArticleTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTypeInclude | null
    /**
     * Filter, which ArticleType to fetch.
     */
    where?: ArticleTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleTypes to fetch.
     */
    orderBy?: Enumerable<ArticleTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleTypes.
     */
    cursor?: ArticleTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleTypes.
     */
    distinct?: Enumerable<ArticleTypeScalarFieldEnum>
  }

  /**
   * ArticleType findFirst
   */
  export interface ArticleTypeFindFirstArgs extends ArticleTypeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ArticleType findFirstOrThrow
   */
  export type ArticleTypeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ArticleType
     */
    select?: ArticleTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTypeInclude | null
    /**
     * Filter, which ArticleType to fetch.
     */
    where?: ArticleTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleTypes to fetch.
     */
    orderBy?: Enumerable<ArticleTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleTypes.
     */
    cursor?: ArticleTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleTypes.
     */
    distinct?: Enumerable<ArticleTypeScalarFieldEnum>
  }


  /**
   * ArticleType findMany
   */
  export type ArticleTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the ArticleType
     */
    select?: ArticleTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTypeInclude | null
    /**
     * Filter, which ArticleTypes to fetch.
     */
    where?: ArticleTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleTypes to fetch.
     */
    orderBy?: Enumerable<ArticleTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArticleTypes.
     */
    cursor?: ArticleTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleTypes.
     */
    skip?: number
    distinct?: Enumerable<ArticleTypeScalarFieldEnum>
  }


  /**
   * ArticleType create
   */
  export type ArticleTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the ArticleType
     */
    select?: ArticleTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTypeInclude | null
    /**
     * The data needed to create a ArticleType.
     */
    data: XOR<ArticleTypeCreateInput, ArticleTypeUncheckedCreateInput>
  }


  /**
   * ArticleType createMany
   */
  export type ArticleTypeCreateManyArgs = {
    /**
     * The data used to create many ArticleTypes.
     */
    data: Enumerable<ArticleTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ArticleType update
   */
  export type ArticleTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the ArticleType
     */
    select?: ArticleTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTypeInclude | null
    /**
     * The data needed to update a ArticleType.
     */
    data: XOR<ArticleTypeUpdateInput, ArticleTypeUncheckedUpdateInput>
    /**
     * Choose, which ArticleType to update.
     */
    where: ArticleTypeWhereUniqueInput
  }


  /**
   * ArticleType updateMany
   */
  export type ArticleTypeUpdateManyArgs = {
    /**
     * The data used to update ArticleTypes.
     */
    data: XOR<ArticleTypeUpdateManyMutationInput, ArticleTypeUncheckedUpdateManyInput>
    /**
     * Filter which ArticleTypes to update
     */
    where?: ArticleTypeWhereInput
  }


  /**
   * ArticleType upsert
   */
  export type ArticleTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the ArticleType
     */
    select?: ArticleTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTypeInclude | null
    /**
     * The filter to search for the ArticleType to update in case it exists.
     */
    where: ArticleTypeWhereUniqueInput
    /**
     * In case the ArticleType found by the `where` argument doesn't exist, create a new ArticleType with this data.
     */
    create: XOR<ArticleTypeCreateInput, ArticleTypeUncheckedCreateInput>
    /**
     * In case the ArticleType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleTypeUpdateInput, ArticleTypeUncheckedUpdateInput>
  }


  /**
   * ArticleType delete
   */
  export type ArticleTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the ArticleType
     */
    select?: ArticleTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTypeInclude | null
    /**
     * Filter which ArticleType to delete.
     */
    where: ArticleTypeWhereUniqueInput
  }


  /**
   * ArticleType deleteMany
   */
  export type ArticleTypeDeleteManyArgs = {
    /**
     * Filter which ArticleTypes to delete
     */
    where?: ArticleTypeWhereInput
  }


  /**
   * ArticleType.articles
   */
  export type ArticleType$articlesArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    where?: ArticleWhereInput
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }


  /**
   * ArticleType without action
   */
  export type ArticleTypeArgs = {
    /**
     * Select specific fields to fetch from the ArticleType
     */
    select?: ArticleTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleTypeInclude | null
  }



  /**
   * Model HardwareType
   */


  export type AggregateHardwareType = {
    _count: HardwareTypeCountAggregateOutputType | null
    _avg: HardwareTypeAvgAggregateOutputType | null
    _sum: HardwareTypeSumAggregateOutputType | null
    _min: HardwareTypeMinAggregateOutputType | null
    _max: HardwareTypeMaxAggregateOutputType | null
  }

  export type HardwareTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type HardwareTypeSumAggregateOutputType = {
    id: number | null
  }

  export type HardwareTypeMinAggregateOutputType = {
    id: number | null
    type: string | null
  }

  export type HardwareTypeMaxAggregateOutputType = {
    id: number | null
    type: string | null
  }

  export type HardwareTypeCountAggregateOutputType = {
    id: number
    type: number
    _all: number
  }


  export type HardwareTypeAvgAggregateInputType = {
    id?: true
  }

  export type HardwareTypeSumAggregateInputType = {
    id?: true
  }

  export type HardwareTypeMinAggregateInputType = {
    id?: true
    type?: true
  }

  export type HardwareTypeMaxAggregateInputType = {
    id?: true
    type?: true
  }

  export type HardwareTypeCountAggregateInputType = {
    id?: true
    type?: true
    _all?: true
  }

  export type HardwareTypeAggregateArgs = {
    /**
     * Filter which HardwareType to aggregate.
     */
    where?: HardwareTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HardwareTypes to fetch.
     */
    orderBy?: Enumerable<HardwareTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HardwareTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HardwareTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HardwareTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HardwareTypes
    **/
    _count?: true | HardwareTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HardwareTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HardwareTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HardwareTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HardwareTypeMaxAggregateInputType
  }

  export type GetHardwareTypeAggregateType<T extends HardwareTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateHardwareType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHardwareType[P]>
      : GetScalarType<T[P], AggregateHardwareType[P]>
  }




  export type HardwareTypeGroupByArgs = {
    where?: HardwareTypeWhereInput
    orderBy?: Enumerable<HardwareTypeOrderByWithAggregationInput>
    by: HardwareTypeScalarFieldEnum[]
    having?: HardwareTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HardwareTypeCountAggregateInputType | true
    _avg?: HardwareTypeAvgAggregateInputType
    _sum?: HardwareTypeSumAggregateInputType
    _min?: HardwareTypeMinAggregateInputType
    _max?: HardwareTypeMaxAggregateInputType
  }


  export type HardwareTypeGroupByOutputType = {
    id: number
    type: string
    _count: HardwareTypeCountAggregateOutputType | null
    _avg: HardwareTypeAvgAggregateOutputType | null
    _sum: HardwareTypeSumAggregateOutputType | null
    _min: HardwareTypeMinAggregateOutputType | null
    _max: HardwareTypeMaxAggregateOutputType | null
  }

  type GetHardwareTypeGroupByPayload<T extends HardwareTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HardwareTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HardwareTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HardwareTypeGroupByOutputType[P]>
            : GetScalarType<T[P], HardwareTypeGroupByOutputType[P]>
        }
      >
    >


  export type HardwareTypeSelect = {
    id?: boolean
    type?: boolean
    hardwares?: boolean | HardwareType$hardwaresArgs
    _count?: boolean | HardwareTypeCountOutputTypeArgs
  }


  export type HardwareTypeInclude = {
    hardwares?: boolean | HardwareType$hardwaresArgs
    _count?: boolean | HardwareTypeCountOutputTypeArgs
  }

  export type HardwareTypeGetPayload<S extends boolean | null | undefined | HardwareTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HardwareType :
    S extends undefined ? never :
    S extends { include: any } & (HardwareTypeArgs | HardwareTypeFindManyArgs)
    ? HardwareType  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'hardwares' ? Array < HardwareGetPayload<S['include'][P]>>  :
        P extends '_count' ? HardwareTypeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (HardwareTypeArgs | HardwareTypeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'hardwares' ? Array < HardwareGetPayload<S['select'][P]>>  :
        P extends '_count' ? HardwareTypeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof HardwareType ? HardwareType[P] : never
  } 
      : HardwareType


  type HardwareTypeCountArgs = 
    Omit<HardwareTypeFindManyArgs, 'select' | 'include'> & {
      select?: HardwareTypeCountAggregateInputType | true
    }

  export interface HardwareTypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one HardwareType that matches the filter.
     * @param {HardwareTypeFindUniqueArgs} args - Arguments to find a HardwareType
     * @example
     * // Get one HardwareType
     * const hardwareType = await prisma.hardwareType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HardwareTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HardwareTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HardwareType'> extends True ? Prisma__HardwareTypeClient<HardwareTypeGetPayload<T>> : Prisma__HardwareTypeClient<HardwareTypeGetPayload<T> | null, null>

    /**
     * Find one HardwareType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HardwareTypeFindUniqueOrThrowArgs} args - Arguments to find a HardwareType
     * @example
     * // Get one HardwareType
     * const hardwareType = await prisma.hardwareType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HardwareTypeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HardwareTypeFindUniqueOrThrowArgs>
    ): Prisma__HardwareTypeClient<HardwareTypeGetPayload<T>>

    /**
     * Find the first HardwareType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareTypeFindFirstArgs} args - Arguments to find a HardwareType
     * @example
     * // Get one HardwareType
     * const hardwareType = await prisma.hardwareType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HardwareTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HardwareTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HardwareType'> extends True ? Prisma__HardwareTypeClient<HardwareTypeGetPayload<T>> : Prisma__HardwareTypeClient<HardwareTypeGetPayload<T> | null, null>

    /**
     * Find the first HardwareType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareTypeFindFirstOrThrowArgs} args - Arguments to find a HardwareType
     * @example
     * // Get one HardwareType
     * const hardwareType = await prisma.hardwareType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HardwareTypeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HardwareTypeFindFirstOrThrowArgs>
    ): Prisma__HardwareTypeClient<HardwareTypeGetPayload<T>>

    /**
     * Find zero or more HardwareTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HardwareTypes
     * const hardwareTypes = await prisma.hardwareType.findMany()
     * 
     * // Get first 10 HardwareTypes
     * const hardwareTypes = await prisma.hardwareType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hardwareTypeWithIdOnly = await prisma.hardwareType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HardwareTypeFindManyArgs>(
      args?: SelectSubset<T, HardwareTypeFindManyArgs>
    ): Prisma.PrismaPromise<Array<HardwareTypeGetPayload<T>>>

    /**
     * Create a HardwareType.
     * @param {HardwareTypeCreateArgs} args - Arguments to create a HardwareType.
     * @example
     * // Create one HardwareType
     * const HardwareType = await prisma.hardwareType.create({
     *   data: {
     *     // ... data to create a HardwareType
     *   }
     * })
     * 
    **/
    create<T extends HardwareTypeCreateArgs>(
      args: SelectSubset<T, HardwareTypeCreateArgs>
    ): Prisma__HardwareTypeClient<HardwareTypeGetPayload<T>>

    /**
     * Create many HardwareTypes.
     *     @param {HardwareTypeCreateManyArgs} args - Arguments to create many HardwareTypes.
     *     @example
     *     // Create many HardwareTypes
     *     const hardwareType = await prisma.hardwareType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HardwareTypeCreateManyArgs>(
      args?: SelectSubset<T, HardwareTypeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HardwareType.
     * @param {HardwareTypeDeleteArgs} args - Arguments to delete one HardwareType.
     * @example
     * // Delete one HardwareType
     * const HardwareType = await prisma.hardwareType.delete({
     *   where: {
     *     // ... filter to delete one HardwareType
     *   }
     * })
     * 
    **/
    delete<T extends HardwareTypeDeleteArgs>(
      args: SelectSubset<T, HardwareTypeDeleteArgs>
    ): Prisma__HardwareTypeClient<HardwareTypeGetPayload<T>>

    /**
     * Update one HardwareType.
     * @param {HardwareTypeUpdateArgs} args - Arguments to update one HardwareType.
     * @example
     * // Update one HardwareType
     * const hardwareType = await prisma.hardwareType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HardwareTypeUpdateArgs>(
      args: SelectSubset<T, HardwareTypeUpdateArgs>
    ): Prisma__HardwareTypeClient<HardwareTypeGetPayload<T>>

    /**
     * Delete zero or more HardwareTypes.
     * @param {HardwareTypeDeleteManyArgs} args - Arguments to filter HardwareTypes to delete.
     * @example
     * // Delete a few HardwareTypes
     * const { count } = await prisma.hardwareType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HardwareTypeDeleteManyArgs>(
      args?: SelectSubset<T, HardwareTypeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HardwareTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HardwareTypes
     * const hardwareType = await prisma.hardwareType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HardwareTypeUpdateManyArgs>(
      args: SelectSubset<T, HardwareTypeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HardwareType.
     * @param {HardwareTypeUpsertArgs} args - Arguments to update or create a HardwareType.
     * @example
     * // Update or create a HardwareType
     * const hardwareType = await prisma.hardwareType.upsert({
     *   create: {
     *     // ... data to create a HardwareType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HardwareType we want to update
     *   }
     * })
    **/
    upsert<T extends HardwareTypeUpsertArgs>(
      args: SelectSubset<T, HardwareTypeUpsertArgs>
    ): Prisma__HardwareTypeClient<HardwareTypeGetPayload<T>>

    /**
     * Count the number of HardwareTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareTypeCountArgs} args - Arguments to filter HardwareTypes to count.
     * @example
     * // Count the number of HardwareTypes
     * const count = await prisma.hardwareType.count({
     *   where: {
     *     // ... the filter for the HardwareTypes we want to count
     *   }
     * })
    **/
    count<T extends HardwareTypeCountArgs>(
      args?: Subset<T, HardwareTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HardwareTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HardwareType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HardwareTypeAggregateArgs>(args: Subset<T, HardwareTypeAggregateArgs>): Prisma.PrismaPromise<GetHardwareTypeAggregateType<T>>

    /**
     * Group by HardwareType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HardwareTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HardwareTypeGroupByArgs['orderBy'] }
        : { orderBy?: HardwareTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HardwareTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHardwareTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HardwareType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HardwareTypeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    hardwares<T extends HardwareType$hardwaresArgs= {}>(args?: Subset<T, HardwareType$hardwaresArgs>): Prisma.PrismaPromise<Array<HardwareGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HardwareType base type for findUnique actions
   */
  export type HardwareTypeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the HardwareType
     */
    select?: HardwareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareTypeInclude | null
    /**
     * Filter, which HardwareType to fetch.
     */
    where: HardwareTypeWhereUniqueInput
  }

  /**
   * HardwareType findUnique
   */
  export interface HardwareTypeFindUniqueArgs extends HardwareTypeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HardwareType findUniqueOrThrow
   */
  export type HardwareTypeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HardwareType
     */
    select?: HardwareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareTypeInclude | null
    /**
     * Filter, which HardwareType to fetch.
     */
    where: HardwareTypeWhereUniqueInput
  }


  /**
   * HardwareType base type for findFirst actions
   */
  export type HardwareTypeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the HardwareType
     */
    select?: HardwareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareTypeInclude | null
    /**
     * Filter, which HardwareType to fetch.
     */
    where?: HardwareTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HardwareTypes to fetch.
     */
    orderBy?: Enumerable<HardwareTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HardwareTypes.
     */
    cursor?: HardwareTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HardwareTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HardwareTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HardwareTypes.
     */
    distinct?: Enumerable<HardwareTypeScalarFieldEnum>
  }

  /**
   * HardwareType findFirst
   */
  export interface HardwareTypeFindFirstArgs extends HardwareTypeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HardwareType findFirstOrThrow
   */
  export type HardwareTypeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HardwareType
     */
    select?: HardwareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareTypeInclude | null
    /**
     * Filter, which HardwareType to fetch.
     */
    where?: HardwareTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HardwareTypes to fetch.
     */
    orderBy?: Enumerable<HardwareTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HardwareTypes.
     */
    cursor?: HardwareTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HardwareTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HardwareTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HardwareTypes.
     */
    distinct?: Enumerable<HardwareTypeScalarFieldEnum>
  }


  /**
   * HardwareType findMany
   */
  export type HardwareTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the HardwareType
     */
    select?: HardwareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareTypeInclude | null
    /**
     * Filter, which HardwareTypes to fetch.
     */
    where?: HardwareTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HardwareTypes to fetch.
     */
    orderBy?: Enumerable<HardwareTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HardwareTypes.
     */
    cursor?: HardwareTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HardwareTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HardwareTypes.
     */
    skip?: number
    distinct?: Enumerable<HardwareTypeScalarFieldEnum>
  }


  /**
   * HardwareType create
   */
  export type HardwareTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the HardwareType
     */
    select?: HardwareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareTypeInclude | null
    /**
     * The data needed to create a HardwareType.
     */
    data: XOR<HardwareTypeCreateInput, HardwareTypeUncheckedCreateInput>
  }


  /**
   * HardwareType createMany
   */
  export type HardwareTypeCreateManyArgs = {
    /**
     * The data used to create many HardwareTypes.
     */
    data: Enumerable<HardwareTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HardwareType update
   */
  export type HardwareTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the HardwareType
     */
    select?: HardwareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareTypeInclude | null
    /**
     * The data needed to update a HardwareType.
     */
    data: XOR<HardwareTypeUpdateInput, HardwareTypeUncheckedUpdateInput>
    /**
     * Choose, which HardwareType to update.
     */
    where: HardwareTypeWhereUniqueInput
  }


  /**
   * HardwareType updateMany
   */
  export type HardwareTypeUpdateManyArgs = {
    /**
     * The data used to update HardwareTypes.
     */
    data: XOR<HardwareTypeUpdateManyMutationInput, HardwareTypeUncheckedUpdateManyInput>
    /**
     * Filter which HardwareTypes to update
     */
    where?: HardwareTypeWhereInput
  }


  /**
   * HardwareType upsert
   */
  export type HardwareTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the HardwareType
     */
    select?: HardwareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareTypeInclude | null
    /**
     * The filter to search for the HardwareType to update in case it exists.
     */
    where: HardwareTypeWhereUniqueInput
    /**
     * In case the HardwareType found by the `where` argument doesn't exist, create a new HardwareType with this data.
     */
    create: XOR<HardwareTypeCreateInput, HardwareTypeUncheckedCreateInput>
    /**
     * In case the HardwareType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HardwareTypeUpdateInput, HardwareTypeUncheckedUpdateInput>
  }


  /**
   * HardwareType delete
   */
  export type HardwareTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the HardwareType
     */
    select?: HardwareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareTypeInclude | null
    /**
     * Filter which HardwareType to delete.
     */
    where: HardwareTypeWhereUniqueInput
  }


  /**
   * HardwareType deleteMany
   */
  export type HardwareTypeDeleteManyArgs = {
    /**
     * Filter which HardwareTypes to delete
     */
    where?: HardwareTypeWhereInput
  }


  /**
   * HardwareType.hardwares
   */
  export type HardwareType$hardwaresArgs = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude | null
    where?: HardwareWhereInput
    orderBy?: Enumerable<HardwareOrderByWithRelationInput>
    cursor?: HardwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HardwareScalarFieldEnum>
  }


  /**
   * HardwareType without action
   */
  export type HardwareTypeArgs = {
    /**
     * Select specific fields to fetch from the HardwareType
     */
    select?: HardwareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareTypeInclude | null
  }



  /**
   * Model DocumentType
   */


  export type AggregateDocumentType = {
    _count: DocumentTypeCountAggregateOutputType | null
    _avg: DocumentTypeAvgAggregateOutputType | null
    _sum: DocumentTypeSumAggregateOutputType | null
    _min: DocumentTypeMinAggregateOutputType | null
    _max: DocumentTypeMaxAggregateOutputType | null
  }

  export type DocumentTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type DocumentTypeSumAggregateOutputType = {
    id: number | null
  }

  export type DocumentTypeMinAggregateOutputType = {
    id: number | null
    type: string | null
  }

  export type DocumentTypeMaxAggregateOutputType = {
    id: number | null
    type: string | null
  }

  export type DocumentTypeCountAggregateOutputType = {
    id: number
    type: number
    _all: number
  }


  export type DocumentTypeAvgAggregateInputType = {
    id?: true
  }

  export type DocumentTypeSumAggregateInputType = {
    id?: true
  }

  export type DocumentTypeMinAggregateInputType = {
    id?: true
    type?: true
  }

  export type DocumentTypeMaxAggregateInputType = {
    id?: true
    type?: true
  }

  export type DocumentTypeCountAggregateInputType = {
    id?: true
    type?: true
    _all?: true
  }

  export type DocumentTypeAggregateArgs = {
    /**
     * Filter which DocumentType to aggregate.
     */
    where?: DocumentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTypes to fetch.
     */
    orderBy?: Enumerable<DocumentTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentTypes
    **/
    _count?: true | DocumentTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentTypeMaxAggregateInputType
  }

  export type GetDocumentTypeAggregateType<T extends DocumentTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentType[P]>
      : GetScalarType<T[P], AggregateDocumentType[P]>
  }




  export type DocumentTypeGroupByArgs = {
    where?: DocumentTypeWhereInput
    orderBy?: Enumerable<DocumentTypeOrderByWithAggregationInput>
    by: DocumentTypeScalarFieldEnum[]
    having?: DocumentTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentTypeCountAggregateInputType | true
    _avg?: DocumentTypeAvgAggregateInputType
    _sum?: DocumentTypeSumAggregateInputType
    _min?: DocumentTypeMinAggregateInputType
    _max?: DocumentTypeMaxAggregateInputType
  }


  export type DocumentTypeGroupByOutputType = {
    id: number
    type: string
    _count: DocumentTypeCountAggregateOutputType | null
    _avg: DocumentTypeAvgAggregateOutputType | null
    _sum: DocumentTypeSumAggregateOutputType | null
    _min: DocumentTypeMinAggregateOutputType | null
    _max: DocumentTypeMaxAggregateOutputType | null
  }

  type GetDocumentTypeGroupByPayload<T extends DocumentTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DocumentTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentTypeGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentTypeGroupByOutputType[P]>
        }
      >
    >


  export type DocumentTypeSelect = {
    id?: boolean
    type?: boolean
    articleDocuments?: boolean | DocumentType$articleDocumentsArgs
    hardwareDocument?: boolean | DocumentType$hardwareDocumentArgs
    _count?: boolean | DocumentTypeCountOutputTypeArgs
  }


  export type DocumentTypeInclude = {
    articleDocuments?: boolean | DocumentType$articleDocumentsArgs
    hardwareDocument?: boolean | DocumentType$hardwareDocumentArgs
    _count?: boolean | DocumentTypeCountOutputTypeArgs
  }

  export type DocumentTypeGetPayload<S extends boolean | null | undefined | DocumentTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DocumentType :
    S extends undefined ? never :
    S extends { include: any } & (DocumentTypeArgs | DocumentTypeFindManyArgs)
    ? DocumentType  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'articleDocuments' ? Array < ArticleDocumentGetPayload<S['include'][P]>>  :
        P extends 'hardwareDocument' ? Array < HardwareDocumentGetPayload<S['include'][P]>>  :
        P extends '_count' ? DocumentTypeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DocumentTypeArgs | DocumentTypeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'articleDocuments' ? Array < ArticleDocumentGetPayload<S['select'][P]>>  :
        P extends 'hardwareDocument' ? Array < HardwareDocumentGetPayload<S['select'][P]>>  :
        P extends '_count' ? DocumentTypeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof DocumentType ? DocumentType[P] : never
  } 
      : DocumentType


  type DocumentTypeCountArgs = 
    Omit<DocumentTypeFindManyArgs, 'select' | 'include'> & {
      select?: DocumentTypeCountAggregateInputType | true
    }

  export interface DocumentTypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DocumentType that matches the filter.
     * @param {DocumentTypeFindUniqueArgs} args - Arguments to find a DocumentType
     * @example
     * // Get one DocumentType
     * const documentType = await prisma.documentType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DocumentTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DocumentType'> extends True ? Prisma__DocumentTypeClient<DocumentTypeGetPayload<T>> : Prisma__DocumentTypeClient<DocumentTypeGetPayload<T> | null, null>

    /**
     * Find one DocumentType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentTypeFindUniqueOrThrowArgs} args - Arguments to find a DocumentType
     * @example
     * // Get one DocumentType
     * const documentType = await prisma.documentType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentTypeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DocumentTypeFindUniqueOrThrowArgs>
    ): Prisma__DocumentTypeClient<DocumentTypeGetPayload<T>>

    /**
     * Find the first DocumentType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeFindFirstArgs} args - Arguments to find a DocumentType
     * @example
     * // Get one DocumentType
     * const documentType = await prisma.documentType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DocumentTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DocumentType'> extends True ? Prisma__DocumentTypeClient<DocumentTypeGetPayload<T>> : Prisma__DocumentTypeClient<DocumentTypeGetPayload<T> | null, null>

    /**
     * Find the first DocumentType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeFindFirstOrThrowArgs} args - Arguments to find a DocumentType
     * @example
     * // Get one DocumentType
     * const documentType = await prisma.documentType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentTypeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DocumentTypeFindFirstOrThrowArgs>
    ): Prisma__DocumentTypeClient<DocumentTypeGetPayload<T>>

    /**
     * Find zero or more DocumentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentTypes
     * const documentTypes = await prisma.documentType.findMany()
     * 
     * // Get first 10 DocumentTypes
     * const documentTypes = await prisma.documentType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentTypeWithIdOnly = await prisma.documentType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentTypeFindManyArgs>(
      args?: SelectSubset<T, DocumentTypeFindManyArgs>
    ): Prisma.PrismaPromise<Array<DocumentTypeGetPayload<T>>>

    /**
     * Create a DocumentType.
     * @param {DocumentTypeCreateArgs} args - Arguments to create a DocumentType.
     * @example
     * // Create one DocumentType
     * const DocumentType = await prisma.documentType.create({
     *   data: {
     *     // ... data to create a DocumentType
     *   }
     * })
     * 
    **/
    create<T extends DocumentTypeCreateArgs>(
      args: SelectSubset<T, DocumentTypeCreateArgs>
    ): Prisma__DocumentTypeClient<DocumentTypeGetPayload<T>>

    /**
     * Create many DocumentTypes.
     *     @param {DocumentTypeCreateManyArgs} args - Arguments to create many DocumentTypes.
     *     @example
     *     // Create many DocumentTypes
     *     const documentType = await prisma.documentType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentTypeCreateManyArgs>(
      args?: SelectSubset<T, DocumentTypeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DocumentType.
     * @param {DocumentTypeDeleteArgs} args - Arguments to delete one DocumentType.
     * @example
     * // Delete one DocumentType
     * const DocumentType = await prisma.documentType.delete({
     *   where: {
     *     // ... filter to delete one DocumentType
     *   }
     * })
     * 
    **/
    delete<T extends DocumentTypeDeleteArgs>(
      args: SelectSubset<T, DocumentTypeDeleteArgs>
    ): Prisma__DocumentTypeClient<DocumentTypeGetPayload<T>>

    /**
     * Update one DocumentType.
     * @param {DocumentTypeUpdateArgs} args - Arguments to update one DocumentType.
     * @example
     * // Update one DocumentType
     * const documentType = await prisma.documentType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentTypeUpdateArgs>(
      args: SelectSubset<T, DocumentTypeUpdateArgs>
    ): Prisma__DocumentTypeClient<DocumentTypeGetPayload<T>>

    /**
     * Delete zero or more DocumentTypes.
     * @param {DocumentTypeDeleteManyArgs} args - Arguments to filter DocumentTypes to delete.
     * @example
     * // Delete a few DocumentTypes
     * const { count } = await prisma.documentType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentTypeDeleteManyArgs>(
      args?: SelectSubset<T, DocumentTypeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentTypes
     * const documentType = await prisma.documentType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentTypeUpdateManyArgs>(
      args: SelectSubset<T, DocumentTypeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentType.
     * @param {DocumentTypeUpsertArgs} args - Arguments to update or create a DocumentType.
     * @example
     * // Update or create a DocumentType
     * const documentType = await prisma.documentType.upsert({
     *   create: {
     *     // ... data to create a DocumentType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentType we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentTypeUpsertArgs>(
      args: SelectSubset<T, DocumentTypeUpsertArgs>
    ): Prisma__DocumentTypeClient<DocumentTypeGetPayload<T>>

    /**
     * Count the number of DocumentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeCountArgs} args - Arguments to filter DocumentTypes to count.
     * @example
     * // Count the number of DocumentTypes
     * const count = await prisma.documentType.count({
     *   where: {
     *     // ... the filter for the DocumentTypes we want to count
     *   }
     * })
    **/
    count<T extends DocumentTypeCountArgs>(
      args?: Subset<T, DocumentTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentTypeAggregateArgs>(args: Subset<T, DocumentTypeAggregateArgs>): Prisma.PrismaPromise<GetDocumentTypeAggregateType<T>>

    /**
     * Group by DocumentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentTypeGroupByArgs['orderBy'] }
        : { orderBy?: DocumentTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DocumentTypeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    articleDocuments<T extends DocumentType$articleDocumentsArgs= {}>(args?: Subset<T, DocumentType$articleDocumentsArgs>): Prisma.PrismaPromise<Array<ArticleDocumentGetPayload<T>>| Null>;

    hardwareDocument<T extends DocumentType$hardwareDocumentArgs= {}>(args?: Subset<T, DocumentType$hardwareDocumentArgs>): Prisma.PrismaPromise<Array<HardwareDocumentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DocumentType base type for findUnique actions
   */
  export type DocumentTypeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentTypeInclude | null
    /**
     * Filter, which DocumentType to fetch.
     */
    where: DocumentTypeWhereUniqueInput
  }

  /**
   * DocumentType findUnique
   */
  export interface DocumentTypeFindUniqueArgs extends DocumentTypeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DocumentType findUniqueOrThrow
   */
  export type DocumentTypeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentTypeInclude | null
    /**
     * Filter, which DocumentType to fetch.
     */
    where: DocumentTypeWhereUniqueInput
  }


  /**
   * DocumentType base type for findFirst actions
   */
  export type DocumentTypeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentTypeInclude | null
    /**
     * Filter, which DocumentType to fetch.
     */
    where?: DocumentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTypes to fetch.
     */
    orderBy?: Enumerable<DocumentTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentTypes.
     */
    cursor?: DocumentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentTypes.
     */
    distinct?: Enumerable<DocumentTypeScalarFieldEnum>
  }

  /**
   * DocumentType findFirst
   */
  export interface DocumentTypeFindFirstArgs extends DocumentTypeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DocumentType findFirstOrThrow
   */
  export type DocumentTypeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentTypeInclude | null
    /**
     * Filter, which DocumentType to fetch.
     */
    where?: DocumentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTypes to fetch.
     */
    orderBy?: Enumerable<DocumentTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentTypes.
     */
    cursor?: DocumentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentTypes.
     */
    distinct?: Enumerable<DocumentTypeScalarFieldEnum>
  }


  /**
   * DocumentType findMany
   */
  export type DocumentTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentTypeInclude | null
    /**
     * Filter, which DocumentTypes to fetch.
     */
    where?: DocumentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTypes to fetch.
     */
    orderBy?: Enumerable<DocumentTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentTypes.
     */
    cursor?: DocumentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTypes.
     */
    skip?: number
    distinct?: Enumerable<DocumentTypeScalarFieldEnum>
  }


  /**
   * DocumentType create
   */
  export type DocumentTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentTypeInclude | null
    /**
     * The data needed to create a DocumentType.
     */
    data: XOR<DocumentTypeCreateInput, DocumentTypeUncheckedCreateInput>
  }


  /**
   * DocumentType createMany
   */
  export type DocumentTypeCreateManyArgs = {
    /**
     * The data used to create many DocumentTypes.
     */
    data: Enumerable<DocumentTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DocumentType update
   */
  export type DocumentTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentTypeInclude | null
    /**
     * The data needed to update a DocumentType.
     */
    data: XOR<DocumentTypeUpdateInput, DocumentTypeUncheckedUpdateInput>
    /**
     * Choose, which DocumentType to update.
     */
    where: DocumentTypeWhereUniqueInput
  }


  /**
   * DocumentType updateMany
   */
  export type DocumentTypeUpdateManyArgs = {
    /**
     * The data used to update DocumentTypes.
     */
    data: XOR<DocumentTypeUpdateManyMutationInput, DocumentTypeUncheckedUpdateManyInput>
    /**
     * Filter which DocumentTypes to update
     */
    where?: DocumentTypeWhereInput
  }


  /**
   * DocumentType upsert
   */
  export type DocumentTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentTypeInclude | null
    /**
     * The filter to search for the DocumentType to update in case it exists.
     */
    where: DocumentTypeWhereUniqueInput
    /**
     * In case the DocumentType found by the `where` argument doesn't exist, create a new DocumentType with this data.
     */
    create: XOR<DocumentTypeCreateInput, DocumentTypeUncheckedCreateInput>
    /**
     * In case the DocumentType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentTypeUpdateInput, DocumentTypeUncheckedUpdateInput>
  }


  /**
   * DocumentType delete
   */
  export type DocumentTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentTypeInclude | null
    /**
     * Filter which DocumentType to delete.
     */
    where: DocumentTypeWhereUniqueInput
  }


  /**
   * DocumentType deleteMany
   */
  export type DocumentTypeDeleteManyArgs = {
    /**
     * Filter which DocumentTypes to delete
     */
    where?: DocumentTypeWhereInput
  }


  /**
   * DocumentType.articleDocuments
   */
  export type DocumentType$articleDocumentsArgs = {
    /**
     * Select specific fields to fetch from the ArticleDocument
     */
    select?: ArticleDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleDocumentInclude | null
    where?: ArticleDocumentWhereInput
    orderBy?: Enumerable<ArticleDocumentOrderByWithRelationInput>
    cursor?: ArticleDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ArticleDocumentScalarFieldEnum>
  }


  /**
   * DocumentType.hardwareDocument
   */
  export type DocumentType$hardwareDocumentArgs = {
    /**
     * Select specific fields to fetch from the HardwareDocument
     */
    select?: HardwareDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareDocumentInclude | null
    where?: HardwareDocumentWhereInput
    orderBy?: Enumerable<HardwareDocumentOrderByWithRelationInput>
    cursor?: HardwareDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HardwareDocumentScalarFieldEnum>
  }


  /**
   * DocumentType without action
   */
  export type DocumentTypeArgs = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentTypeInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    roleId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    firstname: string | null
    lastname: string | null
    username: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    deletedAt: Date | null
    roleId: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    firstname: string | null
    lastname: string | null
    username: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    deletedAt: Date | null
    roleId: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstname: number
    lastname: number
    username: number
    email: number
    password: number
    createdAt: number
    deletedAt: number
    roleId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    roleId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    roleId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    username?: true
    email?: true
    password?: true
    createdAt?: true
    deletedAt?: true
    roleId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    username?: true
    email?: true
    password?: true
    createdAt?: true
    deletedAt?: true
    roleId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    username?: true
    email?: true
    password?: true
    createdAt?: true
    deletedAt?: true
    roleId?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt: Date
    deletedAt: Date | null
    roleId: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    roleId?: boolean
    role?: boolean | RoleArgs
    articles?: boolean | User$articlesArgs
    articleDocuments?: boolean | User$articleDocumentsArgs
    articleComments?: boolean | User$articleCommentsArgs
    hardwares?: boolean | User$hardwaresArgs
    hardwareDocuments?: boolean | User$hardwareDocumentsArgs
    hardwareComments?: boolean | User$hardwareCommentsArgs
    article_hardware?: boolean | User$article_hardwareArgs
    hardware_hardware?: boolean | User$hardware_hardwareArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    role?: boolean | RoleArgs
    articles?: boolean | User$articlesArgs
    articleDocuments?: boolean | User$articleDocumentsArgs
    articleComments?: boolean | User$articleCommentsArgs
    hardwares?: boolean | User$hardwaresArgs
    hardwareDocuments?: boolean | User$hardwareDocumentsArgs
    hardwareComments?: boolean | User$hardwareCommentsArgs
    article_hardware?: boolean | User$article_hardwareArgs
    hardware_hardware?: boolean | User$hardware_hardwareArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'role' ? RoleGetPayload<S['include'][P]> :
        P extends 'articles' ? Array < ArticleGetPayload<S['include'][P]>>  :
        P extends 'articleDocuments' ? Array < ArticleDocumentGetPayload<S['include'][P]>>  :
        P extends 'articleComments' ? Array < ArticleCommentGetPayload<S['include'][P]>>  :
        P extends 'hardwares' ? Array < HardwareGetPayload<S['include'][P]>>  :
        P extends 'hardwareDocuments' ? Array < HardwareDocumentGetPayload<S['include'][P]>>  :
        P extends 'hardwareComments' ? Array < HardwareCommentGetPayload<S['include'][P]>>  :
        P extends 'article_hardware' ? Array < Article_HardwareGetPayload<S['include'][P]>>  :
        P extends 'hardware_hardware' ? Array < Hardware_HardwareGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'role' ? RoleGetPayload<S['select'][P]> :
        P extends 'articles' ? Array < ArticleGetPayload<S['select'][P]>>  :
        P extends 'articleDocuments' ? Array < ArticleDocumentGetPayload<S['select'][P]>>  :
        P extends 'articleComments' ? Array < ArticleCommentGetPayload<S['select'][P]>>  :
        P extends 'hardwares' ? Array < HardwareGetPayload<S['select'][P]>>  :
        P extends 'hardwareDocuments' ? Array < HardwareDocumentGetPayload<S['select'][P]>>  :
        P extends 'hardwareComments' ? Array < HardwareCommentGetPayload<S['select'][P]>>  :
        P extends 'article_hardware' ? Array < Article_HardwareGetPayload<S['select'][P]>>  :
        P extends 'hardware_hardware' ? Array < Hardware_HardwareGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    role<T extends RoleArgs= {}>(args?: Subset<T, RoleArgs>): Prisma__RoleClient<RoleGetPayload<T> | Null>;

    articles<T extends User$articlesArgs= {}>(args?: Subset<T, User$articlesArgs>): Prisma.PrismaPromise<Array<ArticleGetPayload<T>>| Null>;

    articleDocuments<T extends User$articleDocumentsArgs= {}>(args?: Subset<T, User$articleDocumentsArgs>): Prisma.PrismaPromise<Array<ArticleDocumentGetPayload<T>>| Null>;

    articleComments<T extends User$articleCommentsArgs= {}>(args?: Subset<T, User$articleCommentsArgs>): Prisma.PrismaPromise<Array<ArticleCommentGetPayload<T>>| Null>;

    hardwares<T extends User$hardwaresArgs= {}>(args?: Subset<T, User$hardwaresArgs>): Prisma.PrismaPromise<Array<HardwareGetPayload<T>>| Null>;

    hardwareDocuments<T extends User$hardwareDocumentsArgs= {}>(args?: Subset<T, User$hardwareDocumentsArgs>): Prisma.PrismaPromise<Array<HardwareDocumentGetPayload<T>>| Null>;

    hardwareComments<T extends User$hardwareCommentsArgs= {}>(args?: Subset<T, User$hardwareCommentsArgs>): Prisma.PrismaPromise<Array<HardwareCommentGetPayload<T>>| Null>;

    article_hardware<T extends User$article_hardwareArgs= {}>(args?: Subset<T, User$article_hardwareArgs>): Prisma.PrismaPromise<Array<Article_HardwareGetPayload<T>>| Null>;

    hardware_hardware<T extends User$hardware_hardwareArgs= {}>(args?: Subset<T, User$hardware_hardwareArgs>): Prisma.PrismaPromise<Array<Hardware_HardwareGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.articles
   */
  export type User$articlesArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    where?: ArticleWhereInput
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }


  /**
   * User.articleDocuments
   */
  export type User$articleDocumentsArgs = {
    /**
     * Select specific fields to fetch from the ArticleDocument
     */
    select?: ArticleDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleDocumentInclude | null
    where?: ArticleDocumentWhereInput
    orderBy?: Enumerable<ArticleDocumentOrderByWithRelationInput>
    cursor?: ArticleDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ArticleDocumentScalarFieldEnum>
  }


  /**
   * User.articleComments
   */
  export type User$articleCommentsArgs = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleCommentInclude | null
    where?: ArticleCommentWhereInput
    orderBy?: Enumerable<ArticleCommentOrderByWithRelationInput>
    cursor?: ArticleCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ArticleCommentScalarFieldEnum>
  }


  /**
   * User.hardwares
   */
  export type User$hardwaresArgs = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude | null
    where?: HardwareWhereInput
    orderBy?: Enumerable<HardwareOrderByWithRelationInput>
    cursor?: HardwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HardwareScalarFieldEnum>
  }


  /**
   * User.hardwareDocuments
   */
  export type User$hardwareDocumentsArgs = {
    /**
     * Select specific fields to fetch from the HardwareDocument
     */
    select?: HardwareDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareDocumentInclude | null
    where?: HardwareDocumentWhereInput
    orderBy?: Enumerable<HardwareDocumentOrderByWithRelationInput>
    cursor?: HardwareDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HardwareDocumentScalarFieldEnum>
  }


  /**
   * User.hardwareComments
   */
  export type User$hardwareCommentsArgs = {
    /**
     * Select specific fields to fetch from the HardwareComment
     */
    select?: HardwareCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareCommentInclude | null
    where?: HardwareCommentWhereInput
    orderBy?: Enumerable<HardwareCommentOrderByWithRelationInput>
    cursor?: HardwareCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HardwareCommentScalarFieldEnum>
  }


  /**
   * User.article_hardware
   */
  export type User$article_hardwareArgs = {
    /**
     * Select specific fields to fetch from the Article_Hardware
     */
    select?: Article_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Article_HardwareInclude | null
    where?: Article_HardwareWhereInput
    orderBy?: Enumerable<Article_HardwareOrderByWithRelationInput>
    cursor?: Article_HardwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Article_HardwareScalarFieldEnum>
  }


  /**
   * User.hardware_hardware
   */
  export type User$hardware_hardwareArgs = {
    /**
     * Select specific fields to fetch from the Hardware_Hardware
     */
    select?: Hardware_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Hardware_HardwareInclude | null
    where?: Hardware_HardwareWhereInput
    orderBy?: Enumerable<Hardware_HardwareOrderByWithRelationInput>
    cursor?: Hardware_HardwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Hardware_HardwareScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model Article
   */


  export type AggregateArticle = {
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  export type ArticleAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    articleTypeId: number | null
    articleId: number | null
  }

  export type ArticleSumAggregateOutputType = {
    id: number | null
    userId: number | null
    articleTypeId: number | null
    articleId: number | null
  }

  export type ArticleMinAggregateOutputType = {
    id: number | null
    name: string | null
    subDescription: string | null
    description: string | null
    isPublished: boolean | null
    createdAt: Date | null
    deletedAt: Date | null
    modifiedAt: Date | null
    userId: number | null
    articleTypeId: number | null
    articleId: number | null
  }

  export type ArticleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    subDescription: string | null
    description: string | null
    isPublished: boolean | null
    createdAt: Date | null
    deletedAt: Date | null
    modifiedAt: Date | null
    userId: number | null
    articleTypeId: number | null
    articleId: number | null
  }

  export type ArticleCountAggregateOutputType = {
    id: number
    name: number
    subDescription: number
    description: number
    isPublished: number
    createdAt: number
    deletedAt: number
    modifiedAt: number
    userId: number
    articleTypeId: number
    articleId: number
    _all: number
  }


  export type ArticleAvgAggregateInputType = {
    id?: true
    userId?: true
    articleTypeId?: true
    articleId?: true
  }

  export type ArticleSumAggregateInputType = {
    id?: true
    userId?: true
    articleTypeId?: true
    articleId?: true
  }

  export type ArticleMinAggregateInputType = {
    id?: true
    name?: true
    subDescription?: true
    description?: true
    isPublished?: true
    createdAt?: true
    deletedAt?: true
    modifiedAt?: true
    userId?: true
    articleTypeId?: true
    articleId?: true
  }

  export type ArticleMaxAggregateInputType = {
    id?: true
    name?: true
    subDescription?: true
    description?: true
    isPublished?: true
    createdAt?: true
    deletedAt?: true
    modifiedAt?: true
    userId?: true
    articleTypeId?: true
    articleId?: true
  }

  export type ArticleCountAggregateInputType = {
    id?: true
    name?: true
    subDescription?: true
    description?: true
    isPublished?: true
    createdAt?: true
    deletedAt?: true
    modifiedAt?: true
    userId?: true
    articleTypeId?: true
    articleId?: true
    _all?: true
  }

  export type ArticleAggregateArgs = {
    /**
     * Filter which Article to aggregate.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Articles
    **/
    _count?: true | ArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleMaxAggregateInputType
  }

  export type GetArticleAggregateType<T extends ArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticle[P]>
      : GetScalarType<T[P], AggregateArticle[P]>
  }




  export type ArticleGroupByArgs = {
    where?: ArticleWhereInput
    orderBy?: Enumerable<ArticleOrderByWithAggregationInput>
    by: ArticleScalarFieldEnum[]
    having?: ArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleCountAggregateInputType | true
    _avg?: ArticleAvgAggregateInputType
    _sum?: ArticleSumAggregateInputType
    _min?: ArticleMinAggregateInputType
    _max?: ArticleMaxAggregateInputType
  }


  export type ArticleGroupByOutputType = {
    id: number
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt: Date
    deletedAt: Date | null
    modifiedAt: Date | null
    userId: number
    articleTypeId: number
    articleId: number | null
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  type GetArticleGroupByPayload<T extends ArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleGroupByOutputType[P]>
        }
      >
    >


  export type ArticleSelect = {
    id?: boolean
    name?: boolean
    subDescription?: boolean
    description?: boolean
    isPublished?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    modifiedAt?: boolean
    userId?: boolean
    articleTypeId?: boolean
    articleId?: boolean
    user?: boolean | UserArgs
    articleType?: boolean | ArticleTypeArgs
    article?: boolean | ArticleArgs
    articles?: boolean | Article$articlesArgs
    articleDocuments?: boolean | Article$articleDocumentsArgs
    articleComments?: boolean | Article$articleCommentsArgs
    article_hardware?: boolean | Article$article_hardwareArgs
    _count?: boolean | ArticleCountOutputTypeArgs
  }


  export type ArticleInclude = {
    user?: boolean | UserArgs
    articleType?: boolean | ArticleTypeArgs
    article?: boolean | ArticleArgs
    articles?: boolean | Article$articlesArgs
    articleDocuments?: boolean | Article$articleDocumentsArgs
    articleComments?: boolean | Article$articleCommentsArgs
    article_hardware?: boolean | Article$article_hardwareArgs
    _count?: boolean | ArticleCountOutputTypeArgs
  }

  export type ArticleGetPayload<S extends boolean | null | undefined | ArticleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Article :
    S extends undefined ? never :
    S extends { include: any } & (ArticleArgs | ArticleFindManyArgs)
    ? Article  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'articleType' ? ArticleTypeGetPayload<S['include'][P]> :
        P extends 'article' ? ArticleGetPayload<S['include'][P]> | null :
        P extends 'articles' ? Array < ArticleGetPayload<S['include'][P]>>  :
        P extends 'articleDocuments' ? Array < ArticleDocumentGetPayload<S['include'][P]>>  :
        P extends 'articleComments' ? Array < ArticleCommentGetPayload<S['include'][P]>>  :
        P extends 'article_hardware' ? Array < Article_HardwareGetPayload<S['include'][P]>>  :
        P extends '_count' ? ArticleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ArticleArgs | ArticleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'articleType' ? ArticleTypeGetPayload<S['select'][P]> :
        P extends 'article' ? ArticleGetPayload<S['select'][P]> | null :
        P extends 'articles' ? Array < ArticleGetPayload<S['select'][P]>>  :
        P extends 'articleDocuments' ? Array < ArticleDocumentGetPayload<S['select'][P]>>  :
        P extends 'articleComments' ? Array < ArticleCommentGetPayload<S['select'][P]>>  :
        P extends 'article_hardware' ? Array < Article_HardwareGetPayload<S['select'][P]>>  :
        P extends '_count' ? ArticleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Article ? Article[P] : never
  } 
      : Article


  type ArticleCountArgs = 
    Omit<ArticleFindManyArgs, 'select' | 'include'> & {
      select?: ArticleCountAggregateInputType | true
    }

  export interface ArticleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Article that matches the filter.
     * @param {ArticleFindUniqueArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ArticleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ArticleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Article'> extends True ? Prisma__ArticleClient<ArticleGetPayload<T>> : Prisma__ArticleClient<ArticleGetPayload<T> | null, null>

    /**
     * Find one Article that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ArticleFindUniqueOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ArticleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ArticleFindUniqueOrThrowArgs>
    ): Prisma__ArticleClient<ArticleGetPayload<T>>

    /**
     * Find the first Article that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ArticleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ArticleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Article'> extends True ? Prisma__ArticleClient<ArticleGetPayload<T>> : Prisma__ArticleClient<ArticleGetPayload<T> | null, null>

    /**
     * Find the first Article that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ArticleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ArticleFindFirstOrThrowArgs>
    ): Prisma__ArticleClient<ArticleGetPayload<T>>

    /**
     * Find zero or more Articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Articles
     * const articles = await prisma.article.findMany()
     * 
     * // Get first 10 Articles
     * const articles = await prisma.article.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleWithIdOnly = await prisma.article.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ArticleFindManyArgs>(
      args?: SelectSubset<T, ArticleFindManyArgs>
    ): Prisma.PrismaPromise<Array<ArticleGetPayload<T>>>

    /**
     * Create a Article.
     * @param {ArticleCreateArgs} args - Arguments to create a Article.
     * @example
     * // Create one Article
     * const Article = await prisma.article.create({
     *   data: {
     *     // ... data to create a Article
     *   }
     * })
     * 
    **/
    create<T extends ArticleCreateArgs>(
      args: SelectSubset<T, ArticleCreateArgs>
    ): Prisma__ArticleClient<ArticleGetPayload<T>>

    /**
     * Create many Articles.
     *     @param {ArticleCreateManyArgs} args - Arguments to create many Articles.
     *     @example
     *     // Create many Articles
     *     const article = await prisma.article.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ArticleCreateManyArgs>(
      args?: SelectSubset<T, ArticleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Article.
     * @param {ArticleDeleteArgs} args - Arguments to delete one Article.
     * @example
     * // Delete one Article
     * const Article = await prisma.article.delete({
     *   where: {
     *     // ... filter to delete one Article
     *   }
     * })
     * 
    **/
    delete<T extends ArticleDeleteArgs>(
      args: SelectSubset<T, ArticleDeleteArgs>
    ): Prisma__ArticleClient<ArticleGetPayload<T>>

    /**
     * Update one Article.
     * @param {ArticleUpdateArgs} args - Arguments to update one Article.
     * @example
     * // Update one Article
     * const article = await prisma.article.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ArticleUpdateArgs>(
      args: SelectSubset<T, ArticleUpdateArgs>
    ): Prisma__ArticleClient<ArticleGetPayload<T>>

    /**
     * Delete zero or more Articles.
     * @param {ArticleDeleteManyArgs} args - Arguments to filter Articles to delete.
     * @example
     * // Delete a few Articles
     * const { count } = await prisma.article.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ArticleDeleteManyArgs>(
      args?: SelectSubset<T, ArticleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Articles
     * const article = await prisma.article.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ArticleUpdateManyArgs>(
      args: SelectSubset<T, ArticleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Article.
     * @param {ArticleUpsertArgs} args - Arguments to update or create a Article.
     * @example
     * // Update or create a Article
     * const article = await prisma.article.upsert({
     *   create: {
     *     // ... data to create a Article
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Article we want to update
     *   }
     * })
    **/
    upsert<T extends ArticleUpsertArgs>(
      args: SelectSubset<T, ArticleUpsertArgs>
    ): Prisma__ArticleClient<ArticleGetPayload<T>>

    /**
     * Count the number of Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCountArgs} args - Arguments to filter Articles to count.
     * @example
     * // Count the number of Articles
     * const count = await prisma.article.count({
     *   where: {
     *     // ... the filter for the Articles we want to count
     *   }
     * })
    **/
    count<T extends ArticleCountArgs>(
      args?: Subset<T, ArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleAggregateArgs>(args: Subset<T, ArticleAggregateArgs>): Prisma.PrismaPromise<GetArticleAggregateType<T>>

    /**
     * Group by Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleGroupByArgs['orderBy'] }
        : { orderBy?: ArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Article.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ArticleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    articleType<T extends ArticleTypeArgs= {}>(args?: Subset<T, ArticleTypeArgs>): Prisma__ArticleTypeClient<ArticleTypeGetPayload<T> | Null>;

    article<T extends ArticleArgs= {}>(args?: Subset<T, ArticleArgs>): Prisma__ArticleClient<ArticleGetPayload<T> | Null>;

    articles<T extends Article$articlesArgs= {}>(args?: Subset<T, Article$articlesArgs>): Prisma.PrismaPromise<Array<ArticleGetPayload<T>>| Null>;

    articleDocuments<T extends Article$articleDocumentsArgs= {}>(args?: Subset<T, Article$articleDocumentsArgs>): Prisma.PrismaPromise<Array<ArticleDocumentGetPayload<T>>| Null>;

    articleComments<T extends Article$articleCommentsArgs= {}>(args?: Subset<T, Article$articleCommentsArgs>): Prisma.PrismaPromise<Array<ArticleCommentGetPayload<T>>| Null>;

    article_hardware<T extends Article$article_hardwareArgs= {}>(args?: Subset<T, Article$article_hardwareArgs>): Prisma.PrismaPromise<Array<Article_HardwareGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Article base type for findUnique actions
   */
  export type ArticleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article findUnique
   */
  export interface ArticleFindUniqueArgs extends ArticleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Article findUniqueOrThrow
   */
  export type ArticleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article base type for findFirst actions
   */
  export type ArticleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }

  /**
   * Article findFirst
   */
  export interface ArticleFindFirstArgs extends ArticleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Article findFirstOrThrow
   */
  export type ArticleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }


  /**
   * Article findMany
   */
  export type ArticleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    /**
     * Filter, which Articles to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }


  /**
   * Article create
   */
  export type ArticleCreateArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    /**
     * The data needed to create a Article.
     */
    data: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
  }


  /**
   * Article createMany
   */
  export type ArticleCreateManyArgs = {
    /**
     * The data used to create many Articles.
     */
    data: Enumerable<ArticleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Article update
   */
  export type ArticleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    /**
     * The data needed to update a Article.
     */
    data: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
    /**
     * Choose, which Article to update.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article updateMany
   */
  export type ArticleUpdateManyArgs = {
    /**
     * The data used to update Articles.
     */
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyInput>
    /**
     * Filter which Articles to update
     */
    where?: ArticleWhereInput
  }


  /**
   * Article upsert
   */
  export type ArticleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    /**
     * The filter to search for the Article to update in case it exists.
     */
    where: ArticleWhereUniqueInput
    /**
     * In case the Article found by the `where` argument doesn't exist, create a new Article with this data.
     */
    create: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
    /**
     * In case the Article was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
  }


  /**
   * Article delete
   */
  export type ArticleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    /**
     * Filter which Article to delete.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article deleteMany
   */
  export type ArticleDeleteManyArgs = {
    /**
     * Filter which Articles to delete
     */
    where?: ArticleWhereInput
  }


  /**
   * Article.articles
   */
  export type Article$articlesArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    where?: ArticleWhereInput
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }


  /**
   * Article.articleDocuments
   */
  export type Article$articleDocumentsArgs = {
    /**
     * Select specific fields to fetch from the ArticleDocument
     */
    select?: ArticleDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleDocumentInclude | null
    where?: ArticleDocumentWhereInput
    orderBy?: Enumerable<ArticleDocumentOrderByWithRelationInput>
    cursor?: ArticleDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ArticleDocumentScalarFieldEnum>
  }


  /**
   * Article.articleComments
   */
  export type Article$articleCommentsArgs = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleCommentInclude | null
    where?: ArticleCommentWhereInput
    orderBy?: Enumerable<ArticleCommentOrderByWithRelationInput>
    cursor?: ArticleCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ArticleCommentScalarFieldEnum>
  }


  /**
   * Article.article_hardware
   */
  export type Article$article_hardwareArgs = {
    /**
     * Select specific fields to fetch from the Article_Hardware
     */
    select?: Article_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Article_HardwareInclude | null
    where?: Article_HardwareWhereInput
    orderBy?: Enumerable<Article_HardwareOrderByWithRelationInput>
    cursor?: Article_HardwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Article_HardwareScalarFieldEnum>
  }


  /**
   * Article without action
   */
  export type ArticleArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
  }



  /**
   * Model Hardware
   */


  export type AggregateHardware = {
    _count: HardwareCountAggregateOutputType | null
    _avg: HardwareAvgAggregateOutputType | null
    _sum: HardwareSumAggregateOutputType | null
    _min: HardwareMinAggregateOutputType | null
    _max: HardwareMaxAggregateOutputType | null
  }

  export type HardwareAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    hardwareTypeId: number | null
  }

  export type HardwareSumAggregateOutputType = {
    id: number | null
    userId: number | null
    hardwareTypeId: number | null
  }

  export type HardwareMinAggregateOutputType = {
    id: number | null
    name: string | null
    brand: string | null
    subDescription: string | null
    description: string | null
    isDiy: boolean | null
    creationDate: Date | null
    discontinuationDate: Date | null
    createdAt: Date | null
    deletedAt: Date | null
    modifiedAt: Date | null
    userId: number | null
    hardwareTypeId: number | null
  }

  export type HardwareMaxAggregateOutputType = {
    id: number | null
    name: string | null
    brand: string | null
    subDescription: string | null
    description: string | null
    isDiy: boolean | null
    creationDate: Date | null
    discontinuationDate: Date | null
    createdAt: Date | null
    deletedAt: Date | null
    modifiedAt: Date | null
    userId: number | null
    hardwareTypeId: number | null
  }

  export type HardwareCountAggregateOutputType = {
    id: number
    name: number
    brand: number
    subDescription: number
    description: number
    isDiy: number
    creationDate: number
    discontinuationDate: number
    createdAt: number
    deletedAt: number
    modifiedAt: number
    commercialLinks: number
    userId: number
    hardwareTypeId: number
    _all: number
  }


  export type HardwareAvgAggregateInputType = {
    id?: true
    userId?: true
    hardwareTypeId?: true
  }

  export type HardwareSumAggregateInputType = {
    id?: true
    userId?: true
    hardwareTypeId?: true
  }

  export type HardwareMinAggregateInputType = {
    id?: true
    name?: true
    brand?: true
    subDescription?: true
    description?: true
    isDiy?: true
    creationDate?: true
    discontinuationDate?: true
    createdAt?: true
    deletedAt?: true
    modifiedAt?: true
    userId?: true
    hardwareTypeId?: true
  }

  export type HardwareMaxAggregateInputType = {
    id?: true
    name?: true
    brand?: true
    subDescription?: true
    description?: true
    isDiy?: true
    creationDate?: true
    discontinuationDate?: true
    createdAt?: true
    deletedAt?: true
    modifiedAt?: true
    userId?: true
    hardwareTypeId?: true
  }

  export type HardwareCountAggregateInputType = {
    id?: true
    name?: true
    brand?: true
    subDescription?: true
    description?: true
    isDiy?: true
    creationDate?: true
    discontinuationDate?: true
    createdAt?: true
    deletedAt?: true
    modifiedAt?: true
    commercialLinks?: true
    userId?: true
    hardwareTypeId?: true
    _all?: true
  }

  export type HardwareAggregateArgs = {
    /**
     * Filter which Hardware to aggregate.
     */
    where?: HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hardware to fetch.
     */
    orderBy?: Enumerable<HardwareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hardware from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hardware.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hardware
    **/
    _count?: true | HardwareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HardwareAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HardwareSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HardwareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HardwareMaxAggregateInputType
  }

  export type GetHardwareAggregateType<T extends HardwareAggregateArgs> = {
        [P in keyof T & keyof AggregateHardware]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHardware[P]>
      : GetScalarType<T[P], AggregateHardware[P]>
  }




  export type HardwareGroupByArgs = {
    where?: HardwareWhereInput
    orderBy?: Enumerable<HardwareOrderByWithAggregationInput>
    by: HardwareScalarFieldEnum[]
    having?: HardwareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HardwareCountAggregateInputType | true
    _avg?: HardwareAvgAggregateInputType
    _sum?: HardwareSumAggregateInputType
    _min?: HardwareMinAggregateInputType
    _max?: HardwareMaxAggregateInputType
  }


  export type HardwareGroupByOutputType = {
    id: number
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date
    discontinuationDate: Date | null
    createdAt: Date
    deletedAt: Date | null
    modifiedAt: Date | null
    commercialLinks: string[]
    userId: number
    hardwareTypeId: number
    _count: HardwareCountAggregateOutputType | null
    _avg: HardwareAvgAggregateOutputType | null
    _sum: HardwareSumAggregateOutputType | null
    _min: HardwareMinAggregateOutputType | null
    _max: HardwareMaxAggregateOutputType | null
  }

  type GetHardwareGroupByPayload<T extends HardwareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HardwareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HardwareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HardwareGroupByOutputType[P]>
            : GetScalarType<T[P], HardwareGroupByOutputType[P]>
        }
      >
    >


  export type HardwareSelect = {
    id?: boolean
    name?: boolean
    brand?: boolean
    subDescription?: boolean
    description?: boolean
    isDiy?: boolean
    creationDate?: boolean
    discontinuationDate?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    modifiedAt?: boolean
    commercialLinks?: boolean
    userId?: boolean
    hardwareTypeId?: boolean
    user?: boolean | UserArgs
    hardwareType?: boolean | HardwareTypeArgs
    hardwareDocuments?: boolean | Hardware$hardwareDocumentsArgs
    hardwareComments?: boolean | Hardware$hardwareCommentsArgs
    article_hardware?: boolean | Hardware$article_hardwareArgs
    firstHardwareOf?: boolean | Hardware$firstHardwareOfArgs
    secondHardwares?: boolean | Hardware$secondHardwaresArgs
    _count?: boolean | HardwareCountOutputTypeArgs
  }


  export type HardwareInclude = {
    user?: boolean | UserArgs
    hardwareType?: boolean | HardwareTypeArgs
    hardwareDocuments?: boolean | Hardware$hardwareDocumentsArgs
    hardwareComments?: boolean | Hardware$hardwareCommentsArgs
    article_hardware?: boolean | Hardware$article_hardwareArgs
    firstHardwareOf?: boolean | Hardware$firstHardwareOfArgs
    secondHardwares?: boolean | Hardware$secondHardwaresArgs
    _count?: boolean | HardwareCountOutputTypeArgs
  }

  export type HardwareGetPayload<S extends boolean | null | undefined | HardwareArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Hardware :
    S extends undefined ? never :
    S extends { include: any } & (HardwareArgs | HardwareFindManyArgs)
    ? Hardware  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'hardwareType' ? HardwareTypeGetPayload<S['include'][P]> :
        P extends 'hardwareDocuments' ? Array < HardwareDocumentGetPayload<S['include'][P]>>  :
        P extends 'hardwareComments' ? Array < HardwareCommentGetPayload<S['include'][P]>>  :
        P extends 'article_hardware' ? Array < Article_HardwareGetPayload<S['include'][P]>>  :
        P extends 'firstHardwareOf' ? Array < Hardware_HardwareGetPayload<S['include'][P]>>  :
        P extends 'secondHardwares' ? Array < Hardware_HardwareGetPayload<S['include'][P]>>  :
        P extends '_count' ? HardwareCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (HardwareArgs | HardwareFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'hardwareType' ? HardwareTypeGetPayload<S['select'][P]> :
        P extends 'hardwareDocuments' ? Array < HardwareDocumentGetPayload<S['select'][P]>>  :
        P extends 'hardwareComments' ? Array < HardwareCommentGetPayload<S['select'][P]>>  :
        P extends 'article_hardware' ? Array < Article_HardwareGetPayload<S['select'][P]>>  :
        P extends 'firstHardwareOf' ? Array < Hardware_HardwareGetPayload<S['select'][P]>>  :
        P extends 'secondHardwares' ? Array < Hardware_HardwareGetPayload<S['select'][P]>>  :
        P extends '_count' ? HardwareCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Hardware ? Hardware[P] : never
  } 
      : Hardware


  type HardwareCountArgs = 
    Omit<HardwareFindManyArgs, 'select' | 'include'> & {
      select?: HardwareCountAggregateInputType | true
    }

  export interface HardwareDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Hardware that matches the filter.
     * @param {HardwareFindUniqueArgs} args - Arguments to find a Hardware
     * @example
     * // Get one Hardware
     * const hardware = await prisma.hardware.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HardwareFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HardwareFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Hardware'> extends True ? Prisma__HardwareClient<HardwareGetPayload<T>> : Prisma__HardwareClient<HardwareGetPayload<T> | null, null>

    /**
     * Find one Hardware that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HardwareFindUniqueOrThrowArgs} args - Arguments to find a Hardware
     * @example
     * // Get one Hardware
     * const hardware = await prisma.hardware.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HardwareFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HardwareFindUniqueOrThrowArgs>
    ): Prisma__HardwareClient<HardwareGetPayload<T>>

    /**
     * Find the first Hardware that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareFindFirstArgs} args - Arguments to find a Hardware
     * @example
     * // Get one Hardware
     * const hardware = await prisma.hardware.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HardwareFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HardwareFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Hardware'> extends True ? Prisma__HardwareClient<HardwareGetPayload<T>> : Prisma__HardwareClient<HardwareGetPayload<T> | null, null>

    /**
     * Find the first Hardware that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareFindFirstOrThrowArgs} args - Arguments to find a Hardware
     * @example
     * // Get one Hardware
     * const hardware = await prisma.hardware.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HardwareFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HardwareFindFirstOrThrowArgs>
    ): Prisma__HardwareClient<HardwareGetPayload<T>>

    /**
     * Find zero or more Hardware that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hardware
     * const hardware = await prisma.hardware.findMany()
     * 
     * // Get first 10 Hardware
     * const hardware = await prisma.hardware.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hardwareWithIdOnly = await prisma.hardware.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HardwareFindManyArgs>(
      args?: SelectSubset<T, HardwareFindManyArgs>
    ): Prisma.PrismaPromise<Array<HardwareGetPayload<T>>>

    /**
     * Create a Hardware.
     * @param {HardwareCreateArgs} args - Arguments to create a Hardware.
     * @example
     * // Create one Hardware
     * const Hardware = await prisma.hardware.create({
     *   data: {
     *     // ... data to create a Hardware
     *   }
     * })
     * 
    **/
    create<T extends HardwareCreateArgs>(
      args: SelectSubset<T, HardwareCreateArgs>
    ): Prisma__HardwareClient<HardwareGetPayload<T>>

    /**
     * Create many Hardware.
     *     @param {HardwareCreateManyArgs} args - Arguments to create many Hardware.
     *     @example
     *     // Create many Hardware
     *     const hardware = await prisma.hardware.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HardwareCreateManyArgs>(
      args?: SelectSubset<T, HardwareCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hardware.
     * @param {HardwareDeleteArgs} args - Arguments to delete one Hardware.
     * @example
     * // Delete one Hardware
     * const Hardware = await prisma.hardware.delete({
     *   where: {
     *     // ... filter to delete one Hardware
     *   }
     * })
     * 
    **/
    delete<T extends HardwareDeleteArgs>(
      args: SelectSubset<T, HardwareDeleteArgs>
    ): Prisma__HardwareClient<HardwareGetPayload<T>>

    /**
     * Update one Hardware.
     * @param {HardwareUpdateArgs} args - Arguments to update one Hardware.
     * @example
     * // Update one Hardware
     * const hardware = await prisma.hardware.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HardwareUpdateArgs>(
      args: SelectSubset<T, HardwareUpdateArgs>
    ): Prisma__HardwareClient<HardwareGetPayload<T>>

    /**
     * Delete zero or more Hardware.
     * @param {HardwareDeleteManyArgs} args - Arguments to filter Hardware to delete.
     * @example
     * // Delete a few Hardware
     * const { count } = await prisma.hardware.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HardwareDeleteManyArgs>(
      args?: SelectSubset<T, HardwareDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hardware.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hardware
     * const hardware = await prisma.hardware.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HardwareUpdateManyArgs>(
      args: SelectSubset<T, HardwareUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hardware.
     * @param {HardwareUpsertArgs} args - Arguments to update or create a Hardware.
     * @example
     * // Update or create a Hardware
     * const hardware = await prisma.hardware.upsert({
     *   create: {
     *     // ... data to create a Hardware
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hardware we want to update
     *   }
     * })
    **/
    upsert<T extends HardwareUpsertArgs>(
      args: SelectSubset<T, HardwareUpsertArgs>
    ): Prisma__HardwareClient<HardwareGetPayload<T>>

    /**
     * Count the number of Hardware.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareCountArgs} args - Arguments to filter Hardware to count.
     * @example
     * // Count the number of Hardware
     * const count = await prisma.hardware.count({
     *   where: {
     *     // ... the filter for the Hardware we want to count
     *   }
     * })
    **/
    count<T extends HardwareCountArgs>(
      args?: Subset<T, HardwareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HardwareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hardware.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HardwareAggregateArgs>(args: Subset<T, HardwareAggregateArgs>): Prisma.PrismaPromise<GetHardwareAggregateType<T>>

    /**
     * Group by Hardware.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HardwareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HardwareGroupByArgs['orderBy'] }
        : { orderBy?: HardwareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HardwareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHardwareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Hardware.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HardwareClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    hardwareType<T extends HardwareTypeArgs= {}>(args?: Subset<T, HardwareTypeArgs>): Prisma__HardwareTypeClient<HardwareTypeGetPayload<T> | Null>;

    hardwareDocuments<T extends Hardware$hardwareDocumentsArgs= {}>(args?: Subset<T, Hardware$hardwareDocumentsArgs>): Prisma.PrismaPromise<Array<HardwareDocumentGetPayload<T>>| Null>;

    hardwareComments<T extends Hardware$hardwareCommentsArgs= {}>(args?: Subset<T, Hardware$hardwareCommentsArgs>): Prisma.PrismaPromise<Array<HardwareCommentGetPayload<T>>| Null>;

    article_hardware<T extends Hardware$article_hardwareArgs= {}>(args?: Subset<T, Hardware$article_hardwareArgs>): Prisma.PrismaPromise<Array<Article_HardwareGetPayload<T>>| Null>;

    firstHardwareOf<T extends Hardware$firstHardwareOfArgs= {}>(args?: Subset<T, Hardware$firstHardwareOfArgs>): Prisma.PrismaPromise<Array<Hardware_HardwareGetPayload<T>>| Null>;

    secondHardwares<T extends Hardware$secondHardwaresArgs= {}>(args?: Subset<T, Hardware$secondHardwaresArgs>): Prisma.PrismaPromise<Array<Hardware_HardwareGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Hardware base type for findUnique actions
   */
  export type HardwareFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude | null
    /**
     * Filter, which Hardware to fetch.
     */
    where: HardwareWhereUniqueInput
  }

  /**
   * Hardware findUnique
   */
  export interface HardwareFindUniqueArgs extends HardwareFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Hardware findUniqueOrThrow
   */
  export type HardwareFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude | null
    /**
     * Filter, which Hardware to fetch.
     */
    where: HardwareWhereUniqueInput
  }


  /**
   * Hardware base type for findFirst actions
   */
  export type HardwareFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude | null
    /**
     * Filter, which Hardware to fetch.
     */
    where?: HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hardware to fetch.
     */
    orderBy?: Enumerable<HardwareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hardware.
     */
    cursor?: HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hardware from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hardware.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hardware.
     */
    distinct?: Enumerable<HardwareScalarFieldEnum>
  }

  /**
   * Hardware findFirst
   */
  export interface HardwareFindFirstArgs extends HardwareFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Hardware findFirstOrThrow
   */
  export type HardwareFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude | null
    /**
     * Filter, which Hardware to fetch.
     */
    where?: HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hardware to fetch.
     */
    orderBy?: Enumerable<HardwareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hardware.
     */
    cursor?: HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hardware from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hardware.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hardware.
     */
    distinct?: Enumerable<HardwareScalarFieldEnum>
  }


  /**
   * Hardware findMany
   */
  export type HardwareFindManyArgs = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude | null
    /**
     * Filter, which Hardware to fetch.
     */
    where?: HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hardware to fetch.
     */
    orderBy?: Enumerable<HardwareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hardware.
     */
    cursor?: HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hardware from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hardware.
     */
    skip?: number
    distinct?: Enumerable<HardwareScalarFieldEnum>
  }


  /**
   * Hardware create
   */
  export type HardwareCreateArgs = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude | null
    /**
     * The data needed to create a Hardware.
     */
    data: XOR<HardwareCreateInput, HardwareUncheckedCreateInput>
  }


  /**
   * Hardware createMany
   */
  export type HardwareCreateManyArgs = {
    /**
     * The data used to create many Hardware.
     */
    data: Enumerable<HardwareCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Hardware update
   */
  export type HardwareUpdateArgs = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude | null
    /**
     * The data needed to update a Hardware.
     */
    data: XOR<HardwareUpdateInput, HardwareUncheckedUpdateInput>
    /**
     * Choose, which Hardware to update.
     */
    where: HardwareWhereUniqueInput
  }


  /**
   * Hardware updateMany
   */
  export type HardwareUpdateManyArgs = {
    /**
     * The data used to update Hardware.
     */
    data: XOR<HardwareUpdateManyMutationInput, HardwareUncheckedUpdateManyInput>
    /**
     * Filter which Hardware to update
     */
    where?: HardwareWhereInput
  }


  /**
   * Hardware upsert
   */
  export type HardwareUpsertArgs = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude | null
    /**
     * The filter to search for the Hardware to update in case it exists.
     */
    where: HardwareWhereUniqueInput
    /**
     * In case the Hardware found by the `where` argument doesn't exist, create a new Hardware with this data.
     */
    create: XOR<HardwareCreateInput, HardwareUncheckedCreateInput>
    /**
     * In case the Hardware was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HardwareUpdateInput, HardwareUncheckedUpdateInput>
  }


  /**
   * Hardware delete
   */
  export type HardwareDeleteArgs = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude | null
    /**
     * Filter which Hardware to delete.
     */
    where: HardwareWhereUniqueInput
  }


  /**
   * Hardware deleteMany
   */
  export type HardwareDeleteManyArgs = {
    /**
     * Filter which Hardware to delete
     */
    where?: HardwareWhereInput
  }


  /**
   * Hardware.hardwareDocuments
   */
  export type Hardware$hardwareDocumentsArgs = {
    /**
     * Select specific fields to fetch from the HardwareDocument
     */
    select?: HardwareDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareDocumentInclude | null
    where?: HardwareDocumentWhereInput
    orderBy?: Enumerable<HardwareDocumentOrderByWithRelationInput>
    cursor?: HardwareDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HardwareDocumentScalarFieldEnum>
  }


  /**
   * Hardware.hardwareComments
   */
  export type Hardware$hardwareCommentsArgs = {
    /**
     * Select specific fields to fetch from the HardwareComment
     */
    select?: HardwareCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareCommentInclude | null
    where?: HardwareCommentWhereInput
    orderBy?: Enumerable<HardwareCommentOrderByWithRelationInput>
    cursor?: HardwareCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HardwareCommentScalarFieldEnum>
  }


  /**
   * Hardware.article_hardware
   */
  export type Hardware$article_hardwareArgs = {
    /**
     * Select specific fields to fetch from the Article_Hardware
     */
    select?: Article_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Article_HardwareInclude | null
    where?: Article_HardwareWhereInput
    orderBy?: Enumerable<Article_HardwareOrderByWithRelationInput>
    cursor?: Article_HardwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Article_HardwareScalarFieldEnum>
  }


  /**
   * Hardware.firstHardwareOf
   */
  export type Hardware$firstHardwareOfArgs = {
    /**
     * Select specific fields to fetch from the Hardware_Hardware
     */
    select?: Hardware_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Hardware_HardwareInclude | null
    where?: Hardware_HardwareWhereInput
    orderBy?: Enumerable<Hardware_HardwareOrderByWithRelationInput>
    cursor?: Hardware_HardwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Hardware_HardwareScalarFieldEnum>
  }


  /**
   * Hardware.secondHardwares
   */
  export type Hardware$secondHardwaresArgs = {
    /**
     * Select specific fields to fetch from the Hardware_Hardware
     */
    select?: Hardware_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Hardware_HardwareInclude | null
    where?: Hardware_HardwareWhereInput
    orderBy?: Enumerable<Hardware_HardwareOrderByWithRelationInput>
    cursor?: Hardware_HardwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Hardware_HardwareScalarFieldEnum>
  }


  /**
   * Hardware without action
   */
  export type HardwareArgs = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude | null
  }



  /**
   * Model ArticleDocument
   */


  export type AggregateArticleDocument = {
    _count: ArticleDocumentCountAggregateOutputType | null
    _avg: ArticleDocumentAvgAggregateOutputType | null
    _sum: ArticleDocumentSumAggregateOutputType | null
    _min: ArticleDocumentMinAggregateOutputType | null
    _max: ArticleDocumentMaxAggregateOutputType | null
  }

  export type ArticleDocumentAvgAggregateOutputType = {
    id: number | null
    size: number | null
    documentTypeId: number | null
    userId: number | null
    articleId: number | null
  }

  export type ArticleDocumentSumAggregateOutputType = {
    id: number | null
    size: number | null
    documentTypeId: number | null
    userId: number | null
    articleId: number | null
  }

  export type ArticleDocumentMinAggregateOutputType = {
    id: number | null
    name: string | null
    mimetype: string | null
    buffer: Buffer | null
    size: number | null
    createdAt: Date | null
    documentTypeId: number | null
    userId: number | null
    articleId: number | null
  }

  export type ArticleDocumentMaxAggregateOutputType = {
    id: number | null
    name: string | null
    mimetype: string | null
    buffer: Buffer | null
    size: number | null
    createdAt: Date | null
    documentTypeId: number | null
    userId: number | null
    articleId: number | null
  }

  export type ArticleDocumentCountAggregateOutputType = {
    id: number
    name: number
    mimetype: number
    buffer: number
    size: number
    createdAt: number
    documentTypeId: number
    userId: number
    articleId: number
    _all: number
  }


  export type ArticleDocumentAvgAggregateInputType = {
    id?: true
    size?: true
    documentTypeId?: true
    userId?: true
    articleId?: true
  }

  export type ArticleDocumentSumAggregateInputType = {
    id?: true
    size?: true
    documentTypeId?: true
    userId?: true
    articleId?: true
  }

  export type ArticleDocumentMinAggregateInputType = {
    id?: true
    name?: true
    mimetype?: true
    buffer?: true
    size?: true
    createdAt?: true
    documentTypeId?: true
    userId?: true
    articleId?: true
  }

  export type ArticleDocumentMaxAggregateInputType = {
    id?: true
    name?: true
    mimetype?: true
    buffer?: true
    size?: true
    createdAt?: true
    documentTypeId?: true
    userId?: true
    articleId?: true
  }

  export type ArticleDocumentCountAggregateInputType = {
    id?: true
    name?: true
    mimetype?: true
    buffer?: true
    size?: true
    createdAt?: true
    documentTypeId?: true
    userId?: true
    articleId?: true
    _all?: true
  }

  export type ArticleDocumentAggregateArgs = {
    /**
     * Filter which ArticleDocument to aggregate.
     */
    where?: ArticleDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleDocuments to fetch.
     */
    orderBy?: Enumerable<ArticleDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArticleDocuments
    **/
    _count?: true | ArticleDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleDocumentMaxAggregateInputType
  }

  export type GetArticleDocumentAggregateType<T extends ArticleDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateArticleDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticleDocument[P]>
      : GetScalarType<T[P], AggregateArticleDocument[P]>
  }




  export type ArticleDocumentGroupByArgs = {
    where?: ArticleDocumentWhereInput
    orderBy?: Enumerable<ArticleDocumentOrderByWithAggregationInput>
    by: ArticleDocumentScalarFieldEnum[]
    having?: ArticleDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleDocumentCountAggregateInputType | true
    _avg?: ArticleDocumentAvgAggregateInputType
    _sum?: ArticleDocumentSumAggregateInputType
    _min?: ArticleDocumentMinAggregateInputType
    _max?: ArticleDocumentMaxAggregateInputType
  }


  export type ArticleDocumentGroupByOutputType = {
    id: number
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt: Date
    documentTypeId: number
    userId: number
    articleId: number
    _count: ArticleDocumentCountAggregateOutputType | null
    _avg: ArticleDocumentAvgAggregateOutputType | null
    _sum: ArticleDocumentSumAggregateOutputType | null
    _min: ArticleDocumentMinAggregateOutputType | null
    _max: ArticleDocumentMaxAggregateOutputType | null
  }

  type GetArticleDocumentGroupByPayload<T extends ArticleDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ArticleDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleDocumentGroupByOutputType[P]>
        }
      >
    >


  export type ArticleDocumentSelect = {
    id?: boolean
    name?: boolean
    mimetype?: boolean
    buffer?: boolean
    size?: boolean
    createdAt?: boolean
    documentTypeId?: boolean
    userId?: boolean
    articleId?: boolean
    documentType?: boolean | DocumentTypeArgs
    user?: boolean | UserArgs
    article?: boolean | ArticleArgs
  }


  export type ArticleDocumentInclude = {
    documentType?: boolean | DocumentTypeArgs
    user?: boolean | UserArgs
    article?: boolean | ArticleArgs
  }

  export type ArticleDocumentGetPayload<S extends boolean | null | undefined | ArticleDocumentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ArticleDocument :
    S extends undefined ? never :
    S extends { include: any } & (ArticleDocumentArgs | ArticleDocumentFindManyArgs)
    ? ArticleDocument  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'documentType' ? DocumentTypeGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'article' ? ArticleGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ArticleDocumentArgs | ArticleDocumentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'documentType' ? DocumentTypeGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'article' ? ArticleGetPayload<S['select'][P]> :  P extends keyof ArticleDocument ? ArticleDocument[P] : never
  } 
      : ArticleDocument


  type ArticleDocumentCountArgs = 
    Omit<ArticleDocumentFindManyArgs, 'select' | 'include'> & {
      select?: ArticleDocumentCountAggregateInputType | true
    }

  export interface ArticleDocumentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ArticleDocument that matches the filter.
     * @param {ArticleDocumentFindUniqueArgs} args - Arguments to find a ArticleDocument
     * @example
     * // Get one ArticleDocument
     * const articleDocument = await prisma.articleDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ArticleDocumentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ArticleDocumentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ArticleDocument'> extends True ? Prisma__ArticleDocumentClient<ArticleDocumentGetPayload<T>> : Prisma__ArticleDocumentClient<ArticleDocumentGetPayload<T> | null, null>

    /**
     * Find one ArticleDocument that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ArticleDocumentFindUniqueOrThrowArgs} args - Arguments to find a ArticleDocument
     * @example
     * // Get one ArticleDocument
     * const articleDocument = await prisma.articleDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ArticleDocumentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ArticleDocumentFindUniqueOrThrowArgs>
    ): Prisma__ArticleDocumentClient<ArticleDocumentGetPayload<T>>

    /**
     * Find the first ArticleDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleDocumentFindFirstArgs} args - Arguments to find a ArticleDocument
     * @example
     * // Get one ArticleDocument
     * const articleDocument = await prisma.articleDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ArticleDocumentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ArticleDocumentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ArticleDocument'> extends True ? Prisma__ArticleDocumentClient<ArticleDocumentGetPayload<T>> : Prisma__ArticleDocumentClient<ArticleDocumentGetPayload<T> | null, null>

    /**
     * Find the first ArticleDocument that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleDocumentFindFirstOrThrowArgs} args - Arguments to find a ArticleDocument
     * @example
     * // Get one ArticleDocument
     * const articleDocument = await prisma.articleDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ArticleDocumentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ArticleDocumentFindFirstOrThrowArgs>
    ): Prisma__ArticleDocumentClient<ArticleDocumentGetPayload<T>>

    /**
     * Find zero or more ArticleDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleDocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArticleDocuments
     * const articleDocuments = await prisma.articleDocument.findMany()
     * 
     * // Get first 10 ArticleDocuments
     * const articleDocuments = await prisma.articleDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleDocumentWithIdOnly = await prisma.articleDocument.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ArticleDocumentFindManyArgs>(
      args?: SelectSubset<T, ArticleDocumentFindManyArgs>
    ): Prisma.PrismaPromise<Array<ArticleDocumentGetPayload<T>>>

    /**
     * Create a ArticleDocument.
     * @param {ArticleDocumentCreateArgs} args - Arguments to create a ArticleDocument.
     * @example
     * // Create one ArticleDocument
     * const ArticleDocument = await prisma.articleDocument.create({
     *   data: {
     *     // ... data to create a ArticleDocument
     *   }
     * })
     * 
    **/
    create<T extends ArticleDocumentCreateArgs>(
      args: SelectSubset<T, ArticleDocumentCreateArgs>
    ): Prisma__ArticleDocumentClient<ArticleDocumentGetPayload<T>>

    /**
     * Create many ArticleDocuments.
     *     @param {ArticleDocumentCreateManyArgs} args - Arguments to create many ArticleDocuments.
     *     @example
     *     // Create many ArticleDocuments
     *     const articleDocument = await prisma.articleDocument.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ArticleDocumentCreateManyArgs>(
      args?: SelectSubset<T, ArticleDocumentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ArticleDocument.
     * @param {ArticleDocumentDeleteArgs} args - Arguments to delete one ArticleDocument.
     * @example
     * // Delete one ArticleDocument
     * const ArticleDocument = await prisma.articleDocument.delete({
     *   where: {
     *     // ... filter to delete one ArticleDocument
     *   }
     * })
     * 
    **/
    delete<T extends ArticleDocumentDeleteArgs>(
      args: SelectSubset<T, ArticleDocumentDeleteArgs>
    ): Prisma__ArticleDocumentClient<ArticleDocumentGetPayload<T>>

    /**
     * Update one ArticleDocument.
     * @param {ArticleDocumentUpdateArgs} args - Arguments to update one ArticleDocument.
     * @example
     * // Update one ArticleDocument
     * const articleDocument = await prisma.articleDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ArticleDocumentUpdateArgs>(
      args: SelectSubset<T, ArticleDocumentUpdateArgs>
    ): Prisma__ArticleDocumentClient<ArticleDocumentGetPayload<T>>

    /**
     * Delete zero or more ArticleDocuments.
     * @param {ArticleDocumentDeleteManyArgs} args - Arguments to filter ArticleDocuments to delete.
     * @example
     * // Delete a few ArticleDocuments
     * const { count } = await prisma.articleDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ArticleDocumentDeleteManyArgs>(
      args?: SelectSubset<T, ArticleDocumentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArticleDocuments
     * const articleDocument = await prisma.articleDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ArticleDocumentUpdateManyArgs>(
      args: SelectSubset<T, ArticleDocumentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ArticleDocument.
     * @param {ArticleDocumentUpsertArgs} args - Arguments to update or create a ArticleDocument.
     * @example
     * // Update or create a ArticleDocument
     * const articleDocument = await prisma.articleDocument.upsert({
     *   create: {
     *     // ... data to create a ArticleDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArticleDocument we want to update
     *   }
     * })
    **/
    upsert<T extends ArticleDocumentUpsertArgs>(
      args: SelectSubset<T, ArticleDocumentUpsertArgs>
    ): Prisma__ArticleDocumentClient<ArticleDocumentGetPayload<T>>

    /**
     * Count the number of ArticleDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleDocumentCountArgs} args - Arguments to filter ArticleDocuments to count.
     * @example
     * // Count the number of ArticleDocuments
     * const count = await prisma.articleDocument.count({
     *   where: {
     *     // ... the filter for the ArticleDocuments we want to count
     *   }
     * })
    **/
    count<T extends ArticleDocumentCountArgs>(
      args?: Subset<T, ArticleDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArticleDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleDocumentAggregateArgs>(args: Subset<T, ArticleDocumentAggregateArgs>): Prisma.PrismaPromise<GetArticleDocumentAggregateType<T>>

    /**
     * Group by ArticleDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleDocumentGroupByArgs['orderBy'] }
        : { orderBy?: ArticleDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ArticleDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ArticleDocumentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    documentType<T extends DocumentTypeArgs= {}>(args?: Subset<T, DocumentTypeArgs>): Prisma__DocumentTypeClient<DocumentTypeGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    article<T extends ArticleArgs= {}>(args?: Subset<T, ArticleArgs>): Prisma__ArticleClient<ArticleGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ArticleDocument base type for findUnique actions
   */
  export type ArticleDocumentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ArticleDocument
     */
    select?: ArticleDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleDocumentInclude | null
    /**
     * Filter, which ArticleDocument to fetch.
     */
    where: ArticleDocumentWhereUniqueInput
  }

  /**
   * ArticleDocument findUnique
   */
  export interface ArticleDocumentFindUniqueArgs extends ArticleDocumentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ArticleDocument findUniqueOrThrow
   */
  export type ArticleDocumentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ArticleDocument
     */
    select?: ArticleDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleDocumentInclude | null
    /**
     * Filter, which ArticleDocument to fetch.
     */
    where: ArticleDocumentWhereUniqueInput
  }


  /**
   * ArticleDocument base type for findFirst actions
   */
  export type ArticleDocumentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ArticleDocument
     */
    select?: ArticleDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleDocumentInclude | null
    /**
     * Filter, which ArticleDocument to fetch.
     */
    where?: ArticleDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleDocuments to fetch.
     */
    orderBy?: Enumerable<ArticleDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleDocuments.
     */
    cursor?: ArticleDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleDocuments.
     */
    distinct?: Enumerable<ArticleDocumentScalarFieldEnum>
  }

  /**
   * ArticleDocument findFirst
   */
  export interface ArticleDocumentFindFirstArgs extends ArticleDocumentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ArticleDocument findFirstOrThrow
   */
  export type ArticleDocumentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ArticleDocument
     */
    select?: ArticleDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleDocumentInclude | null
    /**
     * Filter, which ArticleDocument to fetch.
     */
    where?: ArticleDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleDocuments to fetch.
     */
    orderBy?: Enumerable<ArticleDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleDocuments.
     */
    cursor?: ArticleDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleDocuments.
     */
    distinct?: Enumerable<ArticleDocumentScalarFieldEnum>
  }


  /**
   * ArticleDocument findMany
   */
  export type ArticleDocumentFindManyArgs = {
    /**
     * Select specific fields to fetch from the ArticleDocument
     */
    select?: ArticleDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleDocumentInclude | null
    /**
     * Filter, which ArticleDocuments to fetch.
     */
    where?: ArticleDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleDocuments to fetch.
     */
    orderBy?: Enumerable<ArticleDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArticleDocuments.
     */
    cursor?: ArticleDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleDocuments.
     */
    skip?: number
    distinct?: Enumerable<ArticleDocumentScalarFieldEnum>
  }


  /**
   * ArticleDocument create
   */
  export type ArticleDocumentCreateArgs = {
    /**
     * Select specific fields to fetch from the ArticleDocument
     */
    select?: ArticleDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleDocumentInclude | null
    /**
     * The data needed to create a ArticleDocument.
     */
    data: XOR<ArticleDocumentCreateInput, ArticleDocumentUncheckedCreateInput>
  }


  /**
   * ArticleDocument createMany
   */
  export type ArticleDocumentCreateManyArgs = {
    /**
     * The data used to create many ArticleDocuments.
     */
    data: Enumerable<ArticleDocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ArticleDocument update
   */
  export type ArticleDocumentUpdateArgs = {
    /**
     * Select specific fields to fetch from the ArticleDocument
     */
    select?: ArticleDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleDocumentInclude | null
    /**
     * The data needed to update a ArticleDocument.
     */
    data: XOR<ArticleDocumentUpdateInput, ArticleDocumentUncheckedUpdateInput>
    /**
     * Choose, which ArticleDocument to update.
     */
    where: ArticleDocumentWhereUniqueInput
  }


  /**
   * ArticleDocument updateMany
   */
  export type ArticleDocumentUpdateManyArgs = {
    /**
     * The data used to update ArticleDocuments.
     */
    data: XOR<ArticleDocumentUpdateManyMutationInput, ArticleDocumentUncheckedUpdateManyInput>
    /**
     * Filter which ArticleDocuments to update
     */
    where?: ArticleDocumentWhereInput
  }


  /**
   * ArticleDocument upsert
   */
  export type ArticleDocumentUpsertArgs = {
    /**
     * Select specific fields to fetch from the ArticleDocument
     */
    select?: ArticleDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleDocumentInclude | null
    /**
     * The filter to search for the ArticleDocument to update in case it exists.
     */
    where: ArticleDocumentWhereUniqueInput
    /**
     * In case the ArticleDocument found by the `where` argument doesn't exist, create a new ArticleDocument with this data.
     */
    create: XOR<ArticleDocumentCreateInput, ArticleDocumentUncheckedCreateInput>
    /**
     * In case the ArticleDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleDocumentUpdateInput, ArticleDocumentUncheckedUpdateInput>
  }


  /**
   * ArticleDocument delete
   */
  export type ArticleDocumentDeleteArgs = {
    /**
     * Select specific fields to fetch from the ArticleDocument
     */
    select?: ArticleDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleDocumentInclude | null
    /**
     * Filter which ArticleDocument to delete.
     */
    where: ArticleDocumentWhereUniqueInput
  }


  /**
   * ArticleDocument deleteMany
   */
  export type ArticleDocumentDeleteManyArgs = {
    /**
     * Filter which ArticleDocuments to delete
     */
    where?: ArticleDocumentWhereInput
  }


  /**
   * ArticleDocument without action
   */
  export type ArticleDocumentArgs = {
    /**
     * Select specific fields to fetch from the ArticleDocument
     */
    select?: ArticleDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleDocumentInclude | null
  }



  /**
   * Model ArticleComment
   */


  export type AggregateArticleComment = {
    _count: ArticleCommentCountAggregateOutputType | null
    _avg: ArticleCommentAvgAggregateOutputType | null
    _sum: ArticleCommentSumAggregateOutputType | null
    _min: ArticleCommentMinAggregateOutputType | null
    _max: ArticleCommentMaxAggregateOutputType | null
  }

  export type ArticleCommentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    articleId: number | null
  }

  export type ArticleCommentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    articleId: number | null
  }

  export type ArticleCommentMinAggregateOutputType = {
    id: number | null
    content: string | null
    createdAt: Date | null
    deletedAt: Date | null
    modifiedAt: Date | null
    userId: number | null
    articleId: number | null
  }

  export type ArticleCommentMaxAggregateOutputType = {
    id: number | null
    content: string | null
    createdAt: Date | null
    deletedAt: Date | null
    modifiedAt: Date | null
    userId: number | null
    articleId: number | null
  }

  export type ArticleCommentCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    deletedAt: number
    modifiedAt: number
    userId: number
    articleId: number
    _all: number
  }


  export type ArticleCommentAvgAggregateInputType = {
    id?: true
    userId?: true
    articleId?: true
  }

  export type ArticleCommentSumAggregateInputType = {
    id?: true
    userId?: true
    articleId?: true
  }

  export type ArticleCommentMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    deletedAt?: true
    modifiedAt?: true
    userId?: true
    articleId?: true
  }

  export type ArticleCommentMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    deletedAt?: true
    modifiedAt?: true
    userId?: true
    articleId?: true
  }

  export type ArticleCommentCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    deletedAt?: true
    modifiedAt?: true
    userId?: true
    articleId?: true
    _all?: true
  }

  export type ArticleCommentAggregateArgs = {
    /**
     * Filter which ArticleComment to aggregate.
     */
    where?: ArticleCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleComments to fetch.
     */
    orderBy?: Enumerable<ArticleCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArticleComments
    **/
    _count?: true | ArticleCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleCommentMaxAggregateInputType
  }

  export type GetArticleCommentAggregateType<T extends ArticleCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateArticleComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticleComment[P]>
      : GetScalarType<T[P], AggregateArticleComment[P]>
  }




  export type ArticleCommentGroupByArgs = {
    where?: ArticleCommentWhereInput
    orderBy?: Enumerable<ArticleCommentOrderByWithAggregationInput>
    by: ArticleCommentScalarFieldEnum[]
    having?: ArticleCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleCommentCountAggregateInputType | true
    _avg?: ArticleCommentAvgAggregateInputType
    _sum?: ArticleCommentSumAggregateInputType
    _min?: ArticleCommentMinAggregateInputType
    _max?: ArticleCommentMaxAggregateInputType
  }


  export type ArticleCommentGroupByOutputType = {
    id: number
    content: string
    createdAt: Date
    deletedAt: Date | null
    modifiedAt: Date | null
    userId: number
    articleId: number
    _count: ArticleCommentCountAggregateOutputType | null
    _avg: ArticleCommentAvgAggregateOutputType | null
    _sum: ArticleCommentSumAggregateOutputType | null
    _min: ArticleCommentMinAggregateOutputType | null
    _max: ArticleCommentMaxAggregateOutputType | null
  }

  type GetArticleCommentGroupByPayload<T extends ArticleCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ArticleCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleCommentGroupByOutputType[P]>
        }
      >
    >


  export type ArticleCommentSelect = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    modifiedAt?: boolean
    userId?: boolean
    articleId?: boolean
    user?: boolean | UserArgs
    article?: boolean | ArticleArgs
  }


  export type ArticleCommentInclude = {
    user?: boolean | UserArgs
    article?: boolean | ArticleArgs
  }

  export type ArticleCommentGetPayload<S extends boolean | null | undefined | ArticleCommentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ArticleComment :
    S extends undefined ? never :
    S extends { include: any } & (ArticleCommentArgs | ArticleCommentFindManyArgs)
    ? ArticleComment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'article' ? ArticleGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ArticleCommentArgs | ArticleCommentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'article' ? ArticleGetPayload<S['select'][P]> :  P extends keyof ArticleComment ? ArticleComment[P] : never
  } 
      : ArticleComment


  type ArticleCommentCountArgs = 
    Omit<ArticleCommentFindManyArgs, 'select' | 'include'> & {
      select?: ArticleCommentCountAggregateInputType | true
    }

  export interface ArticleCommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ArticleComment that matches the filter.
     * @param {ArticleCommentFindUniqueArgs} args - Arguments to find a ArticleComment
     * @example
     * // Get one ArticleComment
     * const articleComment = await prisma.articleComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ArticleCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ArticleCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ArticleComment'> extends True ? Prisma__ArticleCommentClient<ArticleCommentGetPayload<T>> : Prisma__ArticleCommentClient<ArticleCommentGetPayload<T> | null, null>

    /**
     * Find one ArticleComment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ArticleCommentFindUniqueOrThrowArgs} args - Arguments to find a ArticleComment
     * @example
     * // Get one ArticleComment
     * const articleComment = await prisma.articleComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ArticleCommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ArticleCommentFindUniqueOrThrowArgs>
    ): Prisma__ArticleCommentClient<ArticleCommentGetPayload<T>>

    /**
     * Find the first ArticleComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCommentFindFirstArgs} args - Arguments to find a ArticleComment
     * @example
     * // Get one ArticleComment
     * const articleComment = await prisma.articleComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ArticleCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ArticleCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ArticleComment'> extends True ? Prisma__ArticleCommentClient<ArticleCommentGetPayload<T>> : Prisma__ArticleCommentClient<ArticleCommentGetPayload<T> | null, null>

    /**
     * Find the first ArticleComment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCommentFindFirstOrThrowArgs} args - Arguments to find a ArticleComment
     * @example
     * // Get one ArticleComment
     * const articleComment = await prisma.articleComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ArticleCommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ArticleCommentFindFirstOrThrowArgs>
    ): Prisma__ArticleCommentClient<ArticleCommentGetPayload<T>>

    /**
     * Find zero or more ArticleComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArticleComments
     * const articleComments = await prisma.articleComment.findMany()
     * 
     * // Get first 10 ArticleComments
     * const articleComments = await prisma.articleComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleCommentWithIdOnly = await prisma.articleComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ArticleCommentFindManyArgs>(
      args?: SelectSubset<T, ArticleCommentFindManyArgs>
    ): Prisma.PrismaPromise<Array<ArticleCommentGetPayload<T>>>

    /**
     * Create a ArticleComment.
     * @param {ArticleCommentCreateArgs} args - Arguments to create a ArticleComment.
     * @example
     * // Create one ArticleComment
     * const ArticleComment = await prisma.articleComment.create({
     *   data: {
     *     // ... data to create a ArticleComment
     *   }
     * })
     * 
    **/
    create<T extends ArticleCommentCreateArgs>(
      args: SelectSubset<T, ArticleCommentCreateArgs>
    ): Prisma__ArticleCommentClient<ArticleCommentGetPayload<T>>

    /**
     * Create many ArticleComments.
     *     @param {ArticleCommentCreateManyArgs} args - Arguments to create many ArticleComments.
     *     @example
     *     // Create many ArticleComments
     *     const articleComment = await prisma.articleComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ArticleCommentCreateManyArgs>(
      args?: SelectSubset<T, ArticleCommentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ArticleComment.
     * @param {ArticleCommentDeleteArgs} args - Arguments to delete one ArticleComment.
     * @example
     * // Delete one ArticleComment
     * const ArticleComment = await prisma.articleComment.delete({
     *   where: {
     *     // ... filter to delete one ArticleComment
     *   }
     * })
     * 
    **/
    delete<T extends ArticleCommentDeleteArgs>(
      args: SelectSubset<T, ArticleCommentDeleteArgs>
    ): Prisma__ArticleCommentClient<ArticleCommentGetPayload<T>>

    /**
     * Update one ArticleComment.
     * @param {ArticleCommentUpdateArgs} args - Arguments to update one ArticleComment.
     * @example
     * // Update one ArticleComment
     * const articleComment = await prisma.articleComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ArticleCommentUpdateArgs>(
      args: SelectSubset<T, ArticleCommentUpdateArgs>
    ): Prisma__ArticleCommentClient<ArticleCommentGetPayload<T>>

    /**
     * Delete zero or more ArticleComments.
     * @param {ArticleCommentDeleteManyArgs} args - Arguments to filter ArticleComments to delete.
     * @example
     * // Delete a few ArticleComments
     * const { count } = await prisma.articleComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ArticleCommentDeleteManyArgs>(
      args?: SelectSubset<T, ArticleCommentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArticleComments
     * const articleComment = await prisma.articleComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ArticleCommentUpdateManyArgs>(
      args: SelectSubset<T, ArticleCommentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ArticleComment.
     * @param {ArticleCommentUpsertArgs} args - Arguments to update or create a ArticleComment.
     * @example
     * // Update or create a ArticleComment
     * const articleComment = await prisma.articleComment.upsert({
     *   create: {
     *     // ... data to create a ArticleComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArticleComment we want to update
     *   }
     * })
    **/
    upsert<T extends ArticleCommentUpsertArgs>(
      args: SelectSubset<T, ArticleCommentUpsertArgs>
    ): Prisma__ArticleCommentClient<ArticleCommentGetPayload<T>>

    /**
     * Count the number of ArticleComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCommentCountArgs} args - Arguments to filter ArticleComments to count.
     * @example
     * // Count the number of ArticleComments
     * const count = await prisma.articleComment.count({
     *   where: {
     *     // ... the filter for the ArticleComments we want to count
     *   }
     * })
    **/
    count<T extends ArticleCommentCountArgs>(
      args?: Subset<T, ArticleCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArticleComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleCommentAggregateArgs>(args: Subset<T, ArticleCommentAggregateArgs>): Prisma.PrismaPromise<GetArticleCommentAggregateType<T>>

    /**
     * Group by ArticleComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleCommentGroupByArgs['orderBy'] }
        : { orderBy?: ArticleCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ArticleComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ArticleCommentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    article<T extends ArticleArgs= {}>(args?: Subset<T, ArticleArgs>): Prisma__ArticleClient<ArticleGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ArticleComment base type for findUnique actions
   */
  export type ArticleCommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleCommentInclude | null
    /**
     * Filter, which ArticleComment to fetch.
     */
    where: ArticleCommentWhereUniqueInput
  }

  /**
   * ArticleComment findUnique
   */
  export interface ArticleCommentFindUniqueArgs extends ArticleCommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ArticleComment findUniqueOrThrow
   */
  export type ArticleCommentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleCommentInclude | null
    /**
     * Filter, which ArticleComment to fetch.
     */
    where: ArticleCommentWhereUniqueInput
  }


  /**
   * ArticleComment base type for findFirst actions
   */
  export type ArticleCommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleCommentInclude | null
    /**
     * Filter, which ArticleComment to fetch.
     */
    where?: ArticleCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleComments to fetch.
     */
    orderBy?: Enumerable<ArticleCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleComments.
     */
    cursor?: ArticleCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleComments.
     */
    distinct?: Enumerable<ArticleCommentScalarFieldEnum>
  }

  /**
   * ArticleComment findFirst
   */
  export interface ArticleCommentFindFirstArgs extends ArticleCommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ArticleComment findFirstOrThrow
   */
  export type ArticleCommentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleCommentInclude | null
    /**
     * Filter, which ArticleComment to fetch.
     */
    where?: ArticleCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleComments to fetch.
     */
    orderBy?: Enumerable<ArticleCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleComments.
     */
    cursor?: ArticleCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleComments.
     */
    distinct?: Enumerable<ArticleCommentScalarFieldEnum>
  }


  /**
   * ArticleComment findMany
   */
  export type ArticleCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleCommentInclude | null
    /**
     * Filter, which ArticleComments to fetch.
     */
    where?: ArticleCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleComments to fetch.
     */
    orderBy?: Enumerable<ArticleCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArticleComments.
     */
    cursor?: ArticleCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleComments.
     */
    skip?: number
    distinct?: Enumerable<ArticleCommentScalarFieldEnum>
  }


  /**
   * ArticleComment create
   */
  export type ArticleCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleCommentInclude | null
    /**
     * The data needed to create a ArticleComment.
     */
    data: XOR<ArticleCommentCreateInput, ArticleCommentUncheckedCreateInput>
  }


  /**
   * ArticleComment createMany
   */
  export type ArticleCommentCreateManyArgs = {
    /**
     * The data used to create many ArticleComments.
     */
    data: Enumerable<ArticleCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ArticleComment update
   */
  export type ArticleCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleCommentInclude | null
    /**
     * The data needed to update a ArticleComment.
     */
    data: XOR<ArticleCommentUpdateInput, ArticleCommentUncheckedUpdateInput>
    /**
     * Choose, which ArticleComment to update.
     */
    where: ArticleCommentWhereUniqueInput
  }


  /**
   * ArticleComment updateMany
   */
  export type ArticleCommentUpdateManyArgs = {
    /**
     * The data used to update ArticleComments.
     */
    data: XOR<ArticleCommentUpdateManyMutationInput, ArticleCommentUncheckedUpdateManyInput>
    /**
     * Filter which ArticleComments to update
     */
    where?: ArticleCommentWhereInput
  }


  /**
   * ArticleComment upsert
   */
  export type ArticleCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleCommentInclude | null
    /**
     * The filter to search for the ArticleComment to update in case it exists.
     */
    where: ArticleCommentWhereUniqueInput
    /**
     * In case the ArticleComment found by the `where` argument doesn't exist, create a new ArticleComment with this data.
     */
    create: XOR<ArticleCommentCreateInput, ArticleCommentUncheckedCreateInput>
    /**
     * In case the ArticleComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleCommentUpdateInput, ArticleCommentUncheckedUpdateInput>
  }


  /**
   * ArticleComment delete
   */
  export type ArticleCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleCommentInclude | null
    /**
     * Filter which ArticleComment to delete.
     */
    where: ArticleCommentWhereUniqueInput
  }


  /**
   * ArticleComment deleteMany
   */
  export type ArticleCommentDeleteManyArgs = {
    /**
     * Filter which ArticleComments to delete
     */
    where?: ArticleCommentWhereInput
  }


  /**
   * ArticleComment without action
   */
  export type ArticleCommentArgs = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleCommentInclude | null
  }



  /**
   * Model HardwareDocument
   */


  export type AggregateHardwareDocument = {
    _count: HardwareDocumentCountAggregateOutputType | null
    _avg: HardwareDocumentAvgAggregateOutputType | null
    _sum: HardwareDocumentSumAggregateOutputType | null
    _min: HardwareDocumentMinAggregateOutputType | null
    _max: HardwareDocumentMaxAggregateOutputType | null
  }

  export type HardwareDocumentAvgAggregateOutputType = {
    id: number | null
    size: number | null
    documentTypeId: number | null
    userId: number | null
    hardwareId: number | null
  }

  export type HardwareDocumentSumAggregateOutputType = {
    id: number | null
    size: number | null
    documentTypeId: number | null
    userId: number | null
    hardwareId: number | null
  }

  export type HardwareDocumentMinAggregateOutputType = {
    id: number | null
    name: string | null
    mimetype: string | null
    buffer: Buffer | null
    size: number | null
    createdAt: Date | null
    documentTypeId: number | null
    userId: number | null
    hardwareId: number | null
  }

  export type HardwareDocumentMaxAggregateOutputType = {
    id: number | null
    name: string | null
    mimetype: string | null
    buffer: Buffer | null
    size: number | null
    createdAt: Date | null
    documentTypeId: number | null
    userId: number | null
    hardwareId: number | null
  }

  export type HardwareDocumentCountAggregateOutputType = {
    id: number
    name: number
    mimetype: number
    buffer: number
    size: number
    createdAt: number
    documentTypeId: number
    userId: number
    hardwareId: number
    _all: number
  }


  export type HardwareDocumentAvgAggregateInputType = {
    id?: true
    size?: true
    documentTypeId?: true
    userId?: true
    hardwareId?: true
  }

  export type HardwareDocumentSumAggregateInputType = {
    id?: true
    size?: true
    documentTypeId?: true
    userId?: true
    hardwareId?: true
  }

  export type HardwareDocumentMinAggregateInputType = {
    id?: true
    name?: true
    mimetype?: true
    buffer?: true
    size?: true
    createdAt?: true
    documentTypeId?: true
    userId?: true
    hardwareId?: true
  }

  export type HardwareDocumentMaxAggregateInputType = {
    id?: true
    name?: true
    mimetype?: true
    buffer?: true
    size?: true
    createdAt?: true
    documentTypeId?: true
    userId?: true
    hardwareId?: true
  }

  export type HardwareDocumentCountAggregateInputType = {
    id?: true
    name?: true
    mimetype?: true
    buffer?: true
    size?: true
    createdAt?: true
    documentTypeId?: true
    userId?: true
    hardwareId?: true
    _all?: true
  }

  export type HardwareDocumentAggregateArgs = {
    /**
     * Filter which HardwareDocument to aggregate.
     */
    where?: HardwareDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HardwareDocuments to fetch.
     */
    orderBy?: Enumerable<HardwareDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HardwareDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HardwareDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HardwareDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HardwareDocuments
    **/
    _count?: true | HardwareDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HardwareDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HardwareDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HardwareDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HardwareDocumentMaxAggregateInputType
  }

  export type GetHardwareDocumentAggregateType<T extends HardwareDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateHardwareDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHardwareDocument[P]>
      : GetScalarType<T[P], AggregateHardwareDocument[P]>
  }




  export type HardwareDocumentGroupByArgs = {
    where?: HardwareDocumentWhereInput
    orderBy?: Enumerable<HardwareDocumentOrderByWithAggregationInput>
    by: HardwareDocumentScalarFieldEnum[]
    having?: HardwareDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HardwareDocumentCountAggregateInputType | true
    _avg?: HardwareDocumentAvgAggregateInputType
    _sum?: HardwareDocumentSumAggregateInputType
    _min?: HardwareDocumentMinAggregateInputType
    _max?: HardwareDocumentMaxAggregateInputType
  }


  export type HardwareDocumentGroupByOutputType = {
    id: number
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt: Date
    documentTypeId: number
    userId: number
    hardwareId: number
    _count: HardwareDocumentCountAggregateOutputType | null
    _avg: HardwareDocumentAvgAggregateOutputType | null
    _sum: HardwareDocumentSumAggregateOutputType | null
    _min: HardwareDocumentMinAggregateOutputType | null
    _max: HardwareDocumentMaxAggregateOutputType | null
  }

  type GetHardwareDocumentGroupByPayload<T extends HardwareDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HardwareDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HardwareDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HardwareDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], HardwareDocumentGroupByOutputType[P]>
        }
      >
    >


  export type HardwareDocumentSelect = {
    id?: boolean
    name?: boolean
    mimetype?: boolean
    buffer?: boolean
    size?: boolean
    createdAt?: boolean
    documentTypeId?: boolean
    userId?: boolean
    hardwareId?: boolean
    documentType?: boolean | DocumentTypeArgs
    user?: boolean | UserArgs
    hardware?: boolean | HardwareArgs
  }


  export type HardwareDocumentInclude = {
    documentType?: boolean | DocumentTypeArgs
    user?: boolean | UserArgs
    hardware?: boolean | HardwareArgs
  }

  export type HardwareDocumentGetPayload<S extends boolean | null | undefined | HardwareDocumentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HardwareDocument :
    S extends undefined ? never :
    S extends { include: any } & (HardwareDocumentArgs | HardwareDocumentFindManyArgs)
    ? HardwareDocument  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'documentType' ? DocumentTypeGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'hardware' ? HardwareGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (HardwareDocumentArgs | HardwareDocumentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'documentType' ? DocumentTypeGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'hardware' ? HardwareGetPayload<S['select'][P]> :  P extends keyof HardwareDocument ? HardwareDocument[P] : never
  } 
      : HardwareDocument


  type HardwareDocumentCountArgs = 
    Omit<HardwareDocumentFindManyArgs, 'select' | 'include'> & {
      select?: HardwareDocumentCountAggregateInputType | true
    }

  export interface HardwareDocumentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one HardwareDocument that matches the filter.
     * @param {HardwareDocumentFindUniqueArgs} args - Arguments to find a HardwareDocument
     * @example
     * // Get one HardwareDocument
     * const hardwareDocument = await prisma.hardwareDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HardwareDocumentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HardwareDocumentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HardwareDocument'> extends True ? Prisma__HardwareDocumentClient<HardwareDocumentGetPayload<T>> : Prisma__HardwareDocumentClient<HardwareDocumentGetPayload<T> | null, null>

    /**
     * Find one HardwareDocument that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HardwareDocumentFindUniqueOrThrowArgs} args - Arguments to find a HardwareDocument
     * @example
     * // Get one HardwareDocument
     * const hardwareDocument = await prisma.hardwareDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HardwareDocumentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HardwareDocumentFindUniqueOrThrowArgs>
    ): Prisma__HardwareDocumentClient<HardwareDocumentGetPayload<T>>

    /**
     * Find the first HardwareDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareDocumentFindFirstArgs} args - Arguments to find a HardwareDocument
     * @example
     * // Get one HardwareDocument
     * const hardwareDocument = await prisma.hardwareDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HardwareDocumentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HardwareDocumentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HardwareDocument'> extends True ? Prisma__HardwareDocumentClient<HardwareDocumentGetPayload<T>> : Prisma__HardwareDocumentClient<HardwareDocumentGetPayload<T> | null, null>

    /**
     * Find the first HardwareDocument that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareDocumentFindFirstOrThrowArgs} args - Arguments to find a HardwareDocument
     * @example
     * // Get one HardwareDocument
     * const hardwareDocument = await prisma.hardwareDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HardwareDocumentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HardwareDocumentFindFirstOrThrowArgs>
    ): Prisma__HardwareDocumentClient<HardwareDocumentGetPayload<T>>

    /**
     * Find zero or more HardwareDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareDocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HardwareDocuments
     * const hardwareDocuments = await prisma.hardwareDocument.findMany()
     * 
     * // Get first 10 HardwareDocuments
     * const hardwareDocuments = await prisma.hardwareDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hardwareDocumentWithIdOnly = await prisma.hardwareDocument.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HardwareDocumentFindManyArgs>(
      args?: SelectSubset<T, HardwareDocumentFindManyArgs>
    ): Prisma.PrismaPromise<Array<HardwareDocumentGetPayload<T>>>

    /**
     * Create a HardwareDocument.
     * @param {HardwareDocumentCreateArgs} args - Arguments to create a HardwareDocument.
     * @example
     * // Create one HardwareDocument
     * const HardwareDocument = await prisma.hardwareDocument.create({
     *   data: {
     *     // ... data to create a HardwareDocument
     *   }
     * })
     * 
    **/
    create<T extends HardwareDocumentCreateArgs>(
      args: SelectSubset<T, HardwareDocumentCreateArgs>
    ): Prisma__HardwareDocumentClient<HardwareDocumentGetPayload<T>>

    /**
     * Create many HardwareDocuments.
     *     @param {HardwareDocumentCreateManyArgs} args - Arguments to create many HardwareDocuments.
     *     @example
     *     // Create many HardwareDocuments
     *     const hardwareDocument = await prisma.hardwareDocument.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HardwareDocumentCreateManyArgs>(
      args?: SelectSubset<T, HardwareDocumentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HardwareDocument.
     * @param {HardwareDocumentDeleteArgs} args - Arguments to delete one HardwareDocument.
     * @example
     * // Delete one HardwareDocument
     * const HardwareDocument = await prisma.hardwareDocument.delete({
     *   where: {
     *     // ... filter to delete one HardwareDocument
     *   }
     * })
     * 
    **/
    delete<T extends HardwareDocumentDeleteArgs>(
      args: SelectSubset<T, HardwareDocumentDeleteArgs>
    ): Prisma__HardwareDocumentClient<HardwareDocumentGetPayload<T>>

    /**
     * Update one HardwareDocument.
     * @param {HardwareDocumentUpdateArgs} args - Arguments to update one HardwareDocument.
     * @example
     * // Update one HardwareDocument
     * const hardwareDocument = await prisma.hardwareDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HardwareDocumentUpdateArgs>(
      args: SelectSubset<T, HardwareDocumentUpdateArgs>
    ): Prisma__HardwareDocumentClient<HardwareDocumentGetPayload<T>>

    /**
     * Delete zero or more HardwareDocuments.
     * @param {HardwareDocumentDeleteManyArgs} args - Arguments to filter HardwareDocuments to delete.
     * @example
     * // Delete a few HardwareDocuments
     * const { count } = await prisma.hardwareDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HardwareDocumentDeleteManyArgs>(
      args?: SelectSubset<T, HardwareDocumentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HardwareDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HardwareDocuments
     * const hardwareDocument = await prisma.hardwareDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HardwareDocumentUpdateManyArgs>(
      args: SelectSubset<T, HardwareDocumentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HardwareDocument.
     * @param {HardwareDocumentUpsertArgs} args - Arguments to update or create a HardwareDocument.
     * @example
     * // Update or create a HardwareDocument
     * const hardwareDocument = await prisma.hardwareDocument.upsert({
     *   create: {
     *     // ... data to create a HardwareDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HardwareDocument we want to update
     *   }
     * })
    **/
    upsert<T extends HardwareDocumentUpsertArgs>(
      args: SelectSubset<T, HardwareDocumentUpsertArgs>
    ): Prisma__HardwareDocumentClient<HardwareDocumentGetPayload<T>>

    /**
     * Count the number of HardwareDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareDocumentCountArgs} args - Arguments to filter HardwareDocuments to count.
     * @example
     * // Count the number of HardwareDocuments
     * const count = await prisma.hardwareDocument.count({
     *   where: {
     *     // ... the filter for the HardwareDocuments we want to count
     *   }
     * })
    **/
    count<T extends HardwareDocumentCountArgs>(
      args?: Subset<T, HardwareDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HardwareDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HardwareDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HardwareDocumentAggregateArgs>(args: Subset<T, HardwareDocumentAggregateArgs>): Prisma.PrismaPromise<GetHardwareDocumentAggregateType<T>>

    /**
     * Group by HardwareDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HardwareDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HardwareDocumentGroupByArgs['orderBy'] }
        : { orderBy?: HardwareDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HardwareDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHardwareDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HardwareDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HardwareDocumentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    documentType<T extends DocumentTypeArgs= {}>(args?: Subset<T, DocumentTypeArgs>): Prisma__DocumentTypeClient<DocumentTypeGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    hardware<T extends HardwareArgs= {}>(args?: Subset<T, HardwareArgs>): Prisma__HardwareClient<HardwareGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HardwareDocument base type for findUnique actions
   */
  export type HardwareDocumentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the HardwareDocument
     */
    select?: HardwareDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareDocumentInclude | null
    /**
     * Filter, which HardwareDocument to fetch.
     */
    where: HardwareDocumentWhereUniqueInput
  }

  /**
   * HardwareDocument findUnique
   */
  export interface HardwareDocumentFindUniqueArgs extends HardwareDocumentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HardwareDocument findUniqueOrThrow
   */
  export type HardwareDocumentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HardwareDocument
     */
    select?: HardwareDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareDocumentInclude | null
    /**
     * Filter, which HardwareDocument to fetch.
     */
    where: HardwareDocumentWhereUniqueInput
  }


  /**
   * HardwareDocument base type for findFirst actions
   */
  export type HardwareDocumentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the HardwareDocument
     */
    select?: HardwareDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareDocumentInclude | null
    /**
     * Filter, which HardwareDocument to fetch.
     */
    where?: HardwareDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HardwareDocuments to fetch.
     */
    orderBy?: Enumerable<HardwareDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HardwareDocuments.
     */
    cursor?: HardwareDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HardwareDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HardwareDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HardwareDocuments.
     */
    distinct?: Enumerable<HardwareDocumentScalarFieldEnum>
  }

  /**
   * HardwareDocument findFirst
   */
  export interface HardwareDocumentFindFirstArgs extends HardwareDocumentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HardwareDocument findFirstOrThrow
   */
  export type HardwareDocumentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HardwareDocument
     */
    select?: HardwareDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareDocumentInclude | null
    /**
     * Filter, which HardwareDocument to fetch.
     */
    where?: HardwareDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HardwareDocuments to fetch.
     */
    orderBy?: Enumerable<HardwareDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HardwareDocuments.
     */
    cursor?: HardwareDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HardwareDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HardwareDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HardwareDocuments.
     */
    distinct?: Enumerable<HardwareDocumentScalarFieldEnum>
  }


  /**
   * HardwareDocument findMany
   */
  export type HardwareDocumentFindManyArgs = {
    /**
     * Select specific fields to fetch from the HardwareDocument
     */
    select?: HardwareDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareDocumentInclude | null
    /**
     * Filter, which HardwareDocuments to fetch.
     */
    where?: HardwareDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HardwareDocuments to fetch.
     */
    orderBy?: Enumerable<HardwareDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HardwareDocuments.
     */
    cursor?: HardwareDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HardwareDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HardwareDocuments.
     */
    skip?: number
    distinct?: Enumerable<HardwareDocumentScalarFieldEnum>
  }


  /**
   * HardwareDocument create
   */
  export type HardwareDocumentCreateArgs = {
    /**
     * Select specific fields to fetch from the HardwareDocument
     */
    select?: HardwareDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareDocumentInclude | null
    /**
     * The data needed to create a HardwareDocument.
     */
    data: XOR<HardwareDocumentCreateInput, HardwareDocumentUncheckedCreateInput>
  }


  /**
   * HardwareDocument createMany
   */
  export type HardwareDocumentCreateManyArgs = {
    /**
     * The data used to create many HardwareDocuments.
     */
    data: Enumerable<HardwareDocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HardwareDocument update
   */
  export type HardwareDocumentUpdateArgs = {
    /**
     * Select specific fields to fetch from the HardwareDocument
     */
    select?: HardwareDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareDocumentInclude | null
    /**
     * The data needed to update a HardwareDocument.
     */
    data: XOR<HardwareDocumentUpdateInput, HardwareDocumentUncheckedUpdateInput>
    /**
     * Choose, which HardwareDocument to update.
     */
    where: HardwareDocumentWhereUniqueInput
  }


  /**
   * HardwareDocument updateMany
   */
  export type HardwareDocumentUpdateManyArgs = {
    /**
     * The data used to update HardwareDocuments.
     */
    data: XOR<HardwareDocumentUpdateManyMutationInput, HardwareDocumentUncheckedUpdateManyInput>
    /**
     * Filter which HardwareDocuments to update
     */
    where?: HardwareDocumentWhereInput
  }


  /**
   * HardwareDocument upsert
   */
  export type HardwareDocumentUpsertArgs = {
    /**
     * Select specific fields to fetch from the HardwareDocument
     */
    select?: HardwareDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareDocumentInclude | null
    /**
     * The filter to search for the HardwareDocument to update in case it exists.
     */
    where: HardwareDocumentWhereUniqueInput
    /**
     * In case the HardwareDocument found by the `where` argument doesn't exist, create a new HardwareDocument with this data.
     */
    create: XOR<HardwareDocumentCreateInput, HardwareDocumentUncheckedCreateInput>
    /**
     * In case the HardwareDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HardwareDocumentUpdateInput, HardwareDocumentUncheckedUpdateInput>
  }


  /**
   * HardwareDocument delete
   */
  export type HardwareDocumentDeleteArgs = {
    /**
     * Select specific fields to fetch from the HardwareDocument
     */
    select?: HardwareDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareDocumentInclude | null
    /**
     * Filter which HardwareDocument to delete.
     */
    where: HardwareDocumentWhereUniqueInput
  }


  /**
   * HardwareDocument deleteMany
   */
  export type HardwareDocumentDeleteManyArgs = {
    /**
     * Filter which HardwareDocuments to delete
     */
    where?: HardwareDocumentWhereInput
  }


  /**
   * HardwareDocument without action
   */
  export type HardwareDocumentArgs = {
    /**
     * Select specific fields to fetch from the HardwareDocument
     */
    select?: HardwareDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareDocumentInclude | null
  }



  /**
   * Model HardwareComment
   */


  export type AggregateHardwareComment = {
    _count: HardwareCommentCountAggregateOutputType | null
    _avg: HardwareCommentAvgAggregateOutputType | null
    _sum: HardwareCommentSumAggregateOutputType | null
    _min: HardwareCommentMinAggregateOutputType | null
    _max: HardwareCommentMaxAggregateOutputType | null
  }

  export type HardwareCommentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    hardwareId: number | null
  }

  export type HardwareCommentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    hardwareId: number | null
  }

  export type HardwareCommentMinAggregateOutputType = {
    id: number | null
    content: string | null
    createdAt: Date | null
    deletedAt: Date | null
    modifiedAt: Date | null
    userId: number | null
    hardwareId: number | null
  }

  export type HardwareCommentMaxAggregateOutputType = {
    id: number | null
    content: string | null
    createdAt: Date | null
    deletedAt: Date | null
    modifiedAt: Date | null
    userId: number | null
    hardwareId: number | null
  }

  export type HardwareCommentCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    deletedAt: number
    modifiedAt: number
    userId: number
    hardwareId: number
    _all: number
  }


  export type HardwareCommentAvgAggregateInputType = {
    id?: true
    userId?: true
    hardwareId?: true
  }

  export type HardwareCommentSumAggregateInputType = {
    id?: true
    userId?: true
    hardwareId?: true
  }

  export type HardwareCommentMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    deletedAt?: true
    modifiedAt?: true
    userId?: true
    hardwareId?: true
  }

  export type HardwareCommentMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    deletedAt?: true
    modifiedAt?: true
    userId?: true
    hardwareId?: true
  }

  export type HardwareCommentCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    deletedAt?: true
    modifiedAt?: true
    userId?: true
    hardwareId?: true
    _all?: true
  }

  export type HardwareCommentAggregateArgs = {
    /**
     * Filter which HardwareComment to aggregate.
     */
    where?: HardwareCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HardwareComments to fetch.
     */
    orderBy?: Enumerable<HardwareCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HardwareCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HardwareComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HardwareComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HardwareComments
    **/
    _count?: true | HardwareCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HardwareCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HardwareCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HardwareCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HardwareCommentMaxAggregateInputType
  }

  export type GetHardwareCommentAggregateType<T extends HardwareCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateHardwareComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHardwareComment[P]>
      : GetScalarType<T[P], AggregateHardwareComment[P]>
  }




  export type HardwareCommentGroupByArgs = {
    where?: HardwareCommentWhereInput
    orderBy?: Enumerable<HardwareCommentOrderByWithAggregationInput>
    by: HardwareCommentScalarFieldEnum[]
    having?: HardwareCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HardwareCommentCountAggregateInputType | true
    _avg?: HardwareCommentAvgAggregateInputType
    _sum?: HardwareCommentSumAggregateInputType
    _min?: HardwareCommentMinAggregateInputType
    _max?: HardwareCommentMaxAggregateInputType
  }


  export type HardwareCommentGroupByOutputType = {
    id: number
    content: string
    createdAt: Date
    deletedAt: Date | null
    modifiedAt: Date | null
    userId: number
    hardwareId: number
    _count: HardwareCommentCountAggregateOutputType | null
    _avg: HardwareCommentAvgAggregateOutputType | null
    _sum: HardwareCommentSumAggregateOutputType | null
    _min: HardwareCommentMinAggregateOutputType | null
    _max: HardwareCommentMaxAggregateOutputType | null
  }

  type GetHardwareCommentGroupByPayload<T extends HardwareCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HardwareCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HardwareCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HardwareCommentGroupByOutputType[P]>
            : GetScalarType<T[P], HardwareCommentGroupByOutputType[P]>
        }
      >
    >


  export type HardwareCommentSelect = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    modifiedAt?: boolean
    userId?: boolean
    hardwareId?: boolean
    user?: boolean | UserArgs
    hardware?: boolean | HardwareArgs
  }


  export type HardwareCommentInclude = {
    user?: boolean | UserArgs
    hardware?: boolean | HardwareArgs
  }

  export type HardwareCommentGetPayload<S extends boolean | null | undefined | HardwareCommentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HardwareComment :
    S extends undefined ? never :
    S extends { include: any } & (HardwareCommentArgs | HardwareCommentFindManyArgs)
    ? HardwareComment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'hardware' ? HardwareGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (HardwareCommentArgs | HardwareCommentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'hardware' ? HardwareGetPayload<S['select'][P]> :  P extends keyof HardwareComment ? HardwareComment[P] : never
  } 
      : HardwareComment


  type HardwareCommentCountArgs = 
    Omit<HardwareCommentFindManyArgs, 'select' | 'include'> & {
      select?: HardwareCommentCountAggregateInputType | true
    }

  export interface HardwareCommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one HardwareComment that matches the filter.
     * @param {HardwareCommentFindUniqueArgs} args - Arguments to find a HardwareComment
     * @example
     * // Get one HardwareComment
     * const hardwareComment = await prisma.hardwareComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HardwareCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HardwareCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HardwareComment'> extends True ? Prisma__HardwareCommentClient<HardwareCommentGetPayload<T>> : Prisma__HardwareCommentClient<HardwareCommentGetPayload<T> | null, null>

    /**
     * Find one HardwareComment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HardwareCommentFindUniqueOrThrowArgs} args - Arguments to find a HardwareComment
     * @example
     * // Get one HardwareComment
     * const hardwareComment = await prisma.hardwareComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HardwareCommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HardwareCommentFindUniqueOrThrowArgs>
    ): Prisma__HardwareCommentClient<HardwareCommentGetPayload<T>>

    /**
     * Find the first HardwareComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareCommentFindFirstArgs} args - Arguments to find a HardwareComment
     * @example
     * // Get one HardwareComment
     * const hardwareComment = await prisma.hardwareComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HardwareCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HardwareCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HardwareComment'> extends True ? Prisma__HardwareCommentClient<HardwareCommentGetPayload<T>> : Prisma__HardwareCommentClient<HardwareCommentGetPayload<T> | null, null>

    /**
     * Find the first HardwareComment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareCommentFindFirstOrThrowArgs} args - Arguments to find a HardwareComment
     * @example
     * // Get one HardwareComment
     * const hardwareComment = await prisma.hardwareComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HardwareCommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HardwareCommentFindFirstOrThrowArgs>
    ): Prisma__HardwareCommentClient<HardwareCommentGetPayload<T>>

    /**
     * Find zero or more HardwareComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HardwareComments
     * const hardwareComments = await prisma.hardwareComment.findMany()
     * 
     * // Get first 10 HardwareComments
     * const hardwareComments = await prisma.hardwareComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hardwareCommentWithIdOnly = await prisma.hardwareComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HardwareCommentFindManyArgs>(
      args?: SelectSubset<T, HardwareCommentFindManyArgs>
    ): Prisma.PrismaPromise<Array<HardwareCommentGetPayload<T>>>

    /**
     * Create a HardwareComment.
     * @param {HardwareCommentCreateArgs} args - Arguments to create a HardwareComment.
     * @example
     * // Create one HardwareComment
     * const HardwareComment = await prisma.hardwareComment.create({
     *   data: {
     *     // ... data to create a HardwareComment
     *   }
     * })
     * 
    **/
    create<T extends HardwareCommentCreateArgs>(
      args: SelectSubset<T, HardwareCommentCreateArgs>
    ): Prisma__HardwareCommentClient<HardwareCommentGetPayload<T>>

    /**
     * Create many HardwareComments.
     *     @param {HardwareCommentCreateManyArgs} args - Arguments to create many HardwareComments.
     *     @example
     *     // Create many HardwareComments
     *     const hardwareComment = await prisma.hardwareComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HardwareCommentCreateManyArgs>(
      args?: SelectSubset<T, HardwareCommentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HardwareComment.
     * @param {HardwareCommentDeleteArgs} args - Arguments to delete one HardwareComment.
     * @example
     * // Delete one HardwareComment
     * const HardwareComment = await prisma.hardwareComment.delete({
     *   where: {
     *     // ... filter to delete one HardwareComment
     *   }
     * })
     * 
    **/
    delete<T extends HardwareCommentDeleteArgs>(
      args: SelectSubset<T, HardwareCommentDeleteArgs>
    ): Prisma__HardwareCommentClient<HardwareCommentGetPayload<T>>

    /**
     * Update one HardwareComment.
     * @param {HardwareCommentUpdateArgs} args - Arguments to update one HardwareComment.
     * @example
     * // Update one HardwareComment
     * const hardwareComment = await prisma.hardwareComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HardwareCommentUpdateArgs>(
      args: SelectSubset<T, HardwareCommentUpdateArgs>
    ): Prisma__HardwareCommentClient<HardwareCommentGetPayload<T>>

    /**
     * Delete zero or more HardwareComments.
     * @param {HardwareCommentDeleteManyArgs} args - Arguments to filter HardwareComments to delete.
     * @example
     * // Delete a few HardwareComments
     * const { count } = await prisma.hardwareComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HardwareCommentDeleteManyArgs>(
      args?: SelectSubset<T, HardwareCommentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HardwareComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HardwareComments
     * const hardwareComment = await prisma.hardwareComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HardwareCommentUpdateManyArgs>(
      args: SelectSubset<T, HardwareCommentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HardwareComment.
     * @param {HardwareCommentUpsertArgs} args - Arguments to update or create a HardwareComment.
     * @example
     * // Update or create a HardwareComment
     * const hardwareComment = await prisma.hardwareComment.upsert({
     *   create: {
     *     // ... data to create a HardwareComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HardwareComment we want to update
     *   }
     * })
    **/
    upsert<T extends HardwareCommentUpsertArgs>(
      args: SelectSubset<T, HardwareCommentUpsertArgs>
    ): Prisma__HardwareCommentClient<HardwareCommentGetPayload<T>>

    /**
     * Count the number of HardwareComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareCommentCountArgs} args - Arguments to filter HardwareComments to count.
     * @example
     * // Count the number of HardwareComments
     * const count = await prisma.hardwareComment.count({
     *   where: {
     *     // ... the filter for the HardwareComments we want to count
     *   }
     * })
    **/
    count<T extends HardwareCommentCountArgs>(
      args?: Subset<T, HardwareCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HardwareCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HardwareComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HardwareCommentAggregateArgs>(args: Subset<T, HardwareCommentAggregateArgs>): Prisma.PrismaPromise<GetHardwareCommentAggregateType<T>>

    /**
     * Group by HardwareComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HardwareCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HardwareCommentGroupByArgs['orderBy'] }
        : { orderBy?: HardwareCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HardwareCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHardwareCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HardwareComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HardwareCommentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    hardware<T extends HardwareArgs= {}>(args?: Subset<T, HardwareArgs>): Prisma__HardwareClient<HardwareGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HardwareComment base type for findUnique actions
   */
  export type HardwareCommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the HardwareComment
     */
    select?: HardwareCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareCommentInclude | null
    /**
     * Filter, which HardwareComment to fetch.
     */
    where: HardwareCommentWhereUniqueInput
  }

  /**
   * HardwareComment findUnique
   */
  export interface HardwareCommentFindUniqueArgs extends HardwareCommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HardwareComment findUniqueOrThrow
   */
  export type HardwareCommentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HardwareComment
     */
    select?: HardwareCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareCommentInclude | null
    /**
     * Filter, which HardwareComment to fetch.
     */
    where: HardwareCommentWhereUniqueInput
  }


  /**
   * HardwareComment base type for findFirst actions
   */
  export type HardwareCommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the HardwareComment
     */
    select?: HardwareCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareCommentInclude | null
    /**
     * Filter, which HardwareComment to fetch.
     */
    where?: HardwareCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HardwareComments to fetch.
     */
    orderBy?: Enumerable<HardwareCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HardwareComments.
     */
    cursor?: HardwareCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HardwareComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HardwareComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HardwareComments.
     */
    distinct?: Enumerable<HardwareCommentScalarFieldEnum>
  }

  /**
   * HardwareComment findFirst
   */
  export interface HardwareCommentFindFirstArgs extends HardwareCommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HardwareComment findFirstOrThrow
   */
  export type HardwareCommentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HardwareComment
     */
    select?: HardwareCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareCommentInclude | null
    /**
     * Filter, which HardwareComment to fetch.
     */
    where?: HardwareCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HardwareComments to fetch.
     */
    orderBy?: Enumerable<HardwareCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HardwareComments.
     */
    cursor?: HardwareCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HardwareComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HardwareComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HardwareComments.
     */
    distinct?: Enumerable<HardwareCommentScalarFieldEnum>
  }


  /**
   * HardwareComment findMany
   */
  export type HardwareCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the HardwareComment
     */
    select?: HardwareCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareCommentInclude | null
    /**
     * Filter, which HardwareComments to fetch.
     */
    where?: HardwareCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HardwareComments to fetch.
     */
    orderBy?: Enumerable<HardwareCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HardwareComments.
     */
    cursor?: HardwareCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HardwareComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HardwareComments.
     */
    skip?: number
    distinct?: Enumerable<HardwareCommentScalarFieldEnum>
  }


  /**
   * HardwareComment create
   */
  export type HardwareCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the HardwareComment
     */
    select?: HardwareCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareCommentInclude | null
    /**
     * The data needed to create a HardwareComment.
     */
    data: XOR<HardwareCommentCreateInput, HardwareCommentUncheckedCreateInput>
  }


  /**
   * HardwareComment createMany
   */
  export type HardwareCommentCreateManyArgs = {
    /**
     * The data used to create many HardwareComments.
     */
    data: Enumerable<HardwareCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HardwareComment update
   */
  export type HardwareCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the HardwareComment
     */
    select?: HardwareCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareCommentInclude | null
    /**
     * The data needed to update a HardwareComment.
     */
    data: XOR<HardwareCommentUpdateInput, HardwareCommentUncheckedUpdateInput>
    /**
     * Choose, which HardwareComment to update.
     */
    where: HardwareCommentWhereUniqueInput
  }


  /**
   * HardwareComment updateMany
   */
  export type HardwareCommentUpdateManyArgs = {
    /**
     * The data used to update HardwareComments.
     */
    data: XOR<HardwareCommentUpdateManyMutationInput, HardwareCommentUncheckedUpdateManyInput>
    /**
     * Filter which HardwareComments to update
     */
    where?: HardwareCommentWhereInput
  }


  /**
   * HardwareComment upsert
   */
  export type HardwareCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the HardwareComment
     */
    select?: HardwareCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareCommentInclude | null
    /**
     * The filter to search for the HardwareComment to update in case it exists.
     */
    where: HardwareCommentWhereUniqueInput
    /**
     * In case the HardwareComment found by the `where` argument doesn't exist, create a new HardwareComment with this data.
     */
    create: XOR<HardwareCommentCreateInput, HardwareCommentUncheckedCreateInput>
    /**
     * In case the HardwareComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HardwareCommentUpdateInput, HardwareCommentUncheckedUpdateInput>
  }


  /**
   * HardwareComment delete
   */
  export type HardwareCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the HardwareComment
     */
    select?: HardwareCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareCommentInclude | null
    /**
     * Filter which HardwareComment to delete.
     */
    where: HardwareCommentWhereUniqueInput
  }


  /**
   * HardwareComment deleteMany
   */
  export type HardwareCommentDeleteManyArgs = {
    /**
     * Filter which HardwareComments to delete
     */
    where?: HardwareCommentWhereInput
  }


  /**
   * HardwareComment without action
   */
  export type HardwareCommentArgs = {
    /**
     * Select specific fields to fetch from the HardwareComment
     */
    select?: HardwareCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareCommentInclude | null
  }



  /**
   * Model Article_Hardware
   */


  export type AggregateArticle_Hardware = {
    _count: Article_HardwareCountAggregateOutputType | null
    _avg: Article_HardwareAvgAggregateOutputType | null
    _sum: Article_HardwareSumAggregateOutputType | null
    _min: Article_HardwareMinAggregateOutputType | null
    _max: Article_HardwareMaxAggregateOutputType | null
  }

  export type Article_HardwareAvgAggregateOutputType = {
    articleId: number | null
    hardwareId: number | null
    userId: number | null
  }

  export type Article_HardwareSumAggregateOutputType = {
    articleId: number | null
    hardwareId: number | null
    userId: number | null
  }

  export type Article_HardwareMinAggregateOutputType = {
    assigneddAt: Date | null
    articleId: number | null
    hardwareId: number | null
    userId: number | null
  }

  export type Article_HardwareMaxAggregateOutputType = {
    assigneddAt: Date | null
    articleId: number | null
    hardwareId: number | null
    userId: number | null
  }

  export type Article_HardwareCountAggregateOutputType = {
    assigneddAt: number
    articleId: number
    hardwareId: number
    userId: number
    _all: number
  }


  export type Article_HardwareAvgAggregateInputType = {
    articleId?: true
    hardwareId?: true
    userId?: true
  }

  export type Article_HardwareSumAggregateInputType = {
    articleId?: true
    hardwareId?: true
    userId?: true
  }

  export type Article_HardwareMinAggregateInputType = {
    assigneddAt?: true
    articleId?: true
    hardwareId?: true
    userId?: true
  }

  export type Article_HardwareMaxAggregateInputType = {
    assigneddAt?: true
    articleId?: true
    hardwareId?: true
    userId?: true
  }

  export type Article_HardwareCountAggregateInputType = {
    assigneddAt?: true
    articleId?: true
    hardwareId?: true
    userId?: true
    _all?: true
  }

  export type Article_HardwareAggregateArgs = {
    /**
     * Filter which Article_Hardware to aggregate.
     */
    where?: Article_HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Article_Hardwares to fetch.
     */
    orderBy?: Enumerable<Article_HardwareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Article_HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Article_Hardwares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Article_Hardwares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Article_Hardwares
    **/
    _count?: true | Article_HardwareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Article_HardwareAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Article_HardwareSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Article_HardwareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Article_HardwareMaxAggregateInputType
  }

  export type GetArticle_HardwareAggregateType<T extends Article_HardwareAggregateArgs> = {
        [P in keyof T & keyof AggregateArticle_Hardware]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticle_Hardware[P]>
      : GetScalarType<T[P], AggregateArticle_Hardware[P]>
  }




  export type Article_HardwareGroupByArgs = {
    where?: Article_HardwareWhereInput
    orderBy?: Enumerable<Article_HardwareOrderByWithAggregationInput>
    by: Article_HardwareScalarFieldEnum[]
    having?: Article_HardwareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Article_HardwareCountAggregateInputType | true
    _avg?: Article_HardwareAvgAggregateInputType
    _sum?: Article_HardwareSumAggregateInputType
    _min?: Article_HardwareMinAggregateInputType
    _max?: Article_HardwareMaxAggregateInputType
  }


  export type Article_HardwareGroupByOutputType = {
    assigneddAt: Date
    articleId: number
    hardwareId: number
    userId: number
    _count: Article_HardwareCountAggregateOutputType | null
    _avg: Article_HardwareAvgAggregateOutputType | null
    _sum: Article_HardwareSumAggregateOutputType | null
    _min: Article_HardwareMinAggregateOutputType | null
    _max: Article_HardwareMaxAggregateOutputType | null
  }

  type GetArticle_HardwareGroupByPayload<T extends Article_HardwareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Article_HardwareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Article_HardwareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Article_HardwareGroupByOutputType[P]>
            : GetScalarType<T[P], Article_HardwareGroupByOutputType[P]>
        }
      >
    >


  export type Article_HardwareSelect = {
    assigneddAt?: boolean
    articleId?: boolean
    hardwareId?: boolean
    userId?: boolean
    article?: boolean | ArticleArgs
    hardware?: boolean | HardwareArgs
    user?: boolean | UserArgs
  }


  export type Article_HardwareInclude = {
    article?: boolean | ArticleArgs
    hardware?: boolean | HardwareArgs
    user?: boolean | UserArgs
  }

  export type Article_HardwareGetPayload<S extends boolean | null | undefined | Article_HardwareArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Article_Hardware :
    S extends undefined ? never :
    S extends { include: any } & (Article_HardwareArgs | Article_HardwareFindManyArgs)
    ? Article_Hardware  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'article' ? ArticleGetPayload<S['include'][P]> :
        P extends 'hardware' ? HardwareGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (Article_HardwareArgs | Article_HardwareFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'article' ? ArticleGetPayload<S['select'][P]> :
        P extends 'hardware' ? HardwareGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Article_Hardware ? Article_Hardware[P] : never
  } 
      : Article_Hardware


  type Article_HardwareCountArgs = 
    Omit<Article_HardwareFindManyArgs, 'select' | 'include'> & {
      select?: Article_HardwareCountAggregateInputType | true
    }

  export interface Article_HardwareDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Article_Hardware that matches the filter.
     * @param {Article_HardwareFindUniqueArgs} args - Arguments to find a Article_Hardware
     * @example
     * // Get one Article_Hardware
     * const article_Hardware = await prisma.article_Hardware.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Article_HardwareFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Article_HardwareFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Article_Hardware'> extends True ? Prisma__Article_HardwareClient<Article_HardwareGetPayload<T>> : Prisma__Article_HardwareClient<Article_HardwareGetPayload<T> | null, null>

    /**
     * Find one Article_Hardware that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Article_HardwareFindUniqueOrThrowArgs} args - Arguments to find a Article_Hardware
     * @example
     * // Get one Article_Hardware
     * const article_Hardware = await prisma.article_Hardware.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Article_HardwareFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Article_HardwareFindUniqueOrThrowArgs>
    ): Prisma__Article_HardwareClient<Article_HardwareGetPayload<T>>

    /**
     * Find the first Article_Hardware that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Article_HardwareFindFirstArgs} args - Arguments to find a Article_Hardware
     * @example
     * // Get one Article_Hardware
     * const article_Hardware = await prisma.article_Hardware.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Article_HardwareFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Article_HardwareFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Article_Hardware'> extends True ? Prisma__Article_HardwareClient<Article_HardwareGetPayload<T>> : Prisma__Article_HardwareClient<Article_HardwareGetPayload<T> | null, null>

    /**
     * Find the first Article_Hardware that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Article_HardwareFindFirstOrThrowArgs} args - Arguments to find a Article_Hardware
     * @example
     * // Get one Article_Hardware
     * const article_Hardware = await prisma.article_Hardware.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Article_HardwareFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Article_HardwareFindFirstOrThrowArgs>
    ): Prisma__Article_HardwareClient<Article_HardwareGetPayload<T>>

    /**
     * Find zero or more Article_Hardwares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Article_HardwareFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Article_Hardwares
     * const article_Hardwares = await prisma.article_Hardware.findMany()
     * 
     * // Get first 10 Article_Hardwares
     * const article_Hardwares = await prisma.article_Hardware.findMany({ take: 10 })
     * 
     * // Only select the `assigneddAt`
     * const article_HardwareWithAssigneddAtOnly = await prisma.article_Hardware.findMany({ select: { assigneddAt: true } })
     * 
    **/
    findMany<T extends Article_HardwareFindManyArgs>(
      args?: SelectSubset<T, Article_HardwareFindManyArgs>
    ): Prisma.PrismaPromise<Array<Article_HardwareGetPayload<T>>>

    /**
     * Create a Article_Hardware.
     * @param {Article_HardwareCreateArgs} args - Arguments to create a Article_Hardware.
     * @example
     * // Create one Article_Hardware
     * const Article_Hardware = await prisma.article_Hardware.create({
     *   data: {
     *     // ... data to create a Article_Hardware
     *   }
     * })
     * 
    **/
    create<T extends Article_HardwareCreateArgs>(
      args: SelectSubset<T, Article_HardwareCreateArgs>
    ): Prisma__Article_HardwareClient<Article_HardwareGetPayload<T>>

    /**
     * Create many Article_Hardwares.
     *     @param {Article_HardwareCreateManyArgs} args - Arguments to create many Article_Hardwares.
     *     @example
     *     // Create many Article_Hardwares
     *     const article_Hardware = await prisma.article_Hardware.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Article_HardwareCreateManyArgs>(
      args?: SelectSubset<T, Article_HardwareCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Article_Hardware.
     * @param {Article_HardwareDeleteArgs} args - Arguments to delete one Article_Hardware.
     * @example
     * // Delete one Article_Hardware
     * const Article_Hardware = await prisma.article_Hardware.delete({
     *   where: {
     *     // ... filter to delete one Article_Hardware
     *   }
     * })
     * 
    **/
    delete<T extends Article_HardwareDeleteArgs>(
      args: SelectSubset<T, Article_HardwareDeleteArgs>
    ): Prisma__Article_HardwareClient<Article_HardwareGetPayload<T>>

    /**
     * Update one Article_Hardware.
     * @param {Article_HardwareUpdateArgs} args - Arguments to update one Article_Hardware.
     * @example
     * // Update one Article_Hardware
     * const article_Hardware = await prisma.article_Hardware.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Article_HardwareUpdateArgs>(
      args: SelectSubset<T, Article_HardwareUpdateArgs>
    ): Prisma__Article_HardwareClient<Article_HardwareGetPayload<T>>

    /**
     * Delete zero or more Article_Hardwares.
     * @param {Article_HardwareDeleteManyArgs} args - Arguments to filter Article_Hardwares to delete.
     * @example
     * // Delete a few Article_Hardwares
     * const { count } = await prisma.article_Hardware.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Article_HardwareDeleteManyArgs>(
      args?: SelectSubset<T, Article_HardwareDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Article_Hardwares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Article_HardwareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Article_Hardwares
     * const article_Hardware = await prisma.article_Hardware.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Article_HardwareUpdateManyArgs>(
      args: SelectSubset<T, Article_HardwareUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Article_Hardware.
     * @param {Article_HardwareUpsertArgs} args - Arguments to update or create a Article_Hardware.
     * @example
     * // Update or create a Article_Hardware
     * const article_Hardware = await prisma.article_Hardware.upsert({
     *   create: {
     *     // ... data to create a Article_Hardware
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Article_Hardware we want to update
     *   }
     * })
    **/
    upsert<T extends Article_HardwareUpsertArgs>(
      args: SelectSubset<T, Article_HardwareUpsertArgs>
    ): Prisma__Article_HardwareClient<Article_HardwareGetPayload<T>>

    /**
     * Count the number of Article_Hardwares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Article_HardwareCountArgs} args - Arguments to filter Article_Hardwares to count.
     * @example
     * // Count the number of Article_Hardwares
     * const count = await prisma.article_Hardware.count({
     *   where: {
     *     // ... the filter for the Article_Hardwares we want to count
     *   }
     * })
    **/
    count<T extends Article_HardwareCountArgs>(
      args?: Subset<T, Article_HardwareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Article_HardwareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Article_Hardware.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Article_HardwareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Article_HardwareAggregateArgs>(args: Subset<T, Article_HardwareAggregateArgs>): Prisma.PrismaPromise<GetArticle_HardwareAggregateType<T>>

    /**
     * Group by Article_Hardware.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Article_HardwareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Article_HardwareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Article_HardwareGroupByArgs['orderBy'] }
        : { orderBy?: Article_HardwareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Article_HardwareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticle_HardwareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Article_Hardware.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Article_HardwareClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    article<T extends ArticleArgs= {}>(args?: Subset<T, ArticleArgs>): Prisma__ArticleClient<ArticleGetPayload<T> | Null>;

    hardware<T extends HardwareArgs= {}>(args?: Subset<T, HardwareArgs>): Prisma__HardwareClient<HardwareGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Article_Hardware base type for findUnique actions
   */
  export type Article_HardwareFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Article_Hardware
     */
    select?: Article_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Article_HardwareInclude | null
    /**
     * Filter, which Article_Hardware to fetch.
     */
    where: Article_HardwareWhereUniqueInput
  }

  /**
   * Article_Hardware findUnique
   */
  export interface Article_HardwareFindUniqueArgs extends Article_HardwareFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Article_Hardware findUniqueOrThrow
   */
  export type Article_HardwareFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Article_Hardware
     */
    select?: Article_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Article_HardwareInclude | null
    /**
     * Filter, which Article_Hardware to fetch.
     */
    where: Article_HardwareWhereUniqueInput
  }


  /**
   * Article_Hardware base type for findFirst actions
   */
  export type Article_HardwareFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Article_Hardware
     */
    select?: Article_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Article_HardwareInclude | null
    /**
     * Filter, which Article_Hardware to fetch.
     */
    where?: Article_HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Article_Hardwares to fetch.
     */
    orderBy?: Enumerable<Article_HardwareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Article_Hardwares.
     */
    cursor?: Article_HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Article_Hardwares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Article_Hardwares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Article_Hardwares.
     */
    distinct?: Enumerable<Article_HardwareScalarFieldEnum>
  }

  /**
   * Article_Hardware findFirst
   */
  export interface Article_HardwareFindFirstArgs extends Article_HardwareFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Article_Hardware findFirstOrThrow
   */
  export type Article_HardwareFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Article_Hardware
     */
    select?: Article_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Article_HardwareInclude | null
    /**
     * Filter, which Article_Hardware to fetch.
     */
    where?: Article_HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Article_Hardwares to fetch.
     */
    orderBy?: Enumerable<Article_HardwareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Article_Hardwares.
     */
    cursor?: Article_HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Article_Hardwares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Article_Hardwares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Article_Hardwares.
     */
    distinct?: Enumerable<Article_HardwareScalarFieldEnum>
  }


  /**
   * Article_Hardware findMany
   */
  export type Article_HardwareFindManyArgs = {
    /**
     * Select specific fields to fetch from the Article_Hardware
     */
    select?: Article_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Article_HardwareInclude | null
    /**
     * Filter, which Article_Hardwares to fetch.
     */
    where?: Article_HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Article_Hardwares to fetch.
     */
    orderBy?: Enumerable<Article_HardwareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Article_Hardwares.
     */
    cursor?: Article_HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Article_Hardwares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Article_Hardwares.
     */
    skip?: number
    distinct?: Enumerable<Article_HardwareScalarFieldEnum>
  }


  /**
   * Article_Hardware create
   */
  export type Article_HardwareCreateArgs = {
    /**
     * Select specific fields to fetch from the Article_Hardware
     */
    select?: Article_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Article_HardwareInclude | null
    /**
     * The data needed to create a Article_Hardware.
     */
    data: XOR<Article_HardwareCreateInput, Article_HardwareUncheckedCreateInput>
  }


  /**
   * Article_Hardware createMany
   */
  export type Article_HardwareCreateManyArgs = {
    /**
     * The data used to create many Article_Hardwares.
     */
    data: Enumerable<Article_HardwareCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Article_Hardware update
   */
  export type Article_HardwareUpdateArgs = {
    /**
     * Select specific fields to fetch from the Article_Hardware
     */
    select?: Article_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Article_HardwareInclude | null
    /**
     * The data needed to update a Article_Hardware.
     */
    data: XOR<Article_HardwareUpdateInput, Article_HardwareUncheckedUpdateInput>
    /**
     * Choose, which Article_Hardware to update.
     */
    where: Article_HardwareWhereUniqueInput
  }


  /**
   * Article_Hardware updateMany
   */
  export type Article_HardwareUpdateManyArgs = {
    /**
     * The data used to update Article_Hardwares.
     */
    data: XOR<Article_HardwareUpdateManyMutationInput, Article_HardwareUncheckedUpdateManyInput>
    /**
     * Filter which Article_Hardwares to update
     */
    where?: Article_HardwareWhereInput
  }


  /**
   * Article_Hardware upsert
   */
  export type Article_HardwareUpsertArgs = {
    /**
     * Select specific fields to fetch from the Article_Hardware
     */
    select?: Article_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Article_HardwareInclude | null
    /**
     * The filter to search for the Article_Hardware to update in case it exists.
     */
    where: Article_HardwareWhereUniqueInput
    /**
     * In case the Article_Hardware found by the `where` argument doesn't exist, create a new Article_Hardware with this data.
     */
    create: XOR<Article_HardwareCreateInput, Article_HardwareUncheckedCreateInput>
    /**
     * In case the Article_Hardware was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Article_HardwareUpdateInput, Article_HardwareUncheckedUpdateInput>
  }


  /**
   * Article_Hardware delete
   */
  export type Article_HardwareDeleteArgs = {
    /**
     * Select specific fields to fetch from the Article_Hardware
     */
    select?: Article_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Article_HardwareInclude | null
    /**
     * Filter which Article_Hardware to delete.
     */
    where: Article_HardwareWhereUniqueInput
  }


  /**
   * Article_Hardware deleteMany
   */
  export type Article_HardwareDeleteManyArgs = {
    /**
     * Filter which Article_Hardwares to delete
     */
    where?: Article_HardwareWhereInput
  }


  /**
   * Article_Hardware without action
   */
  export type Article_HardwareArgs = {
    /**
     * Select specific fields to fetch from the Article_Hardware
     */
    select?: Article_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Article_HardwareInclude | null
  }



  /**
   * Model Hardware_Hardware
   */


  export type AggregateHardware_Hardware = {
    _count: Hardware_HardwareCountAggregateOutputType | null
    _avg: Hardware_HardwareAvgAggregateOutputType | null
    _sum: Hardware_HardwareSumAggregateOutputType | null
    _min: Hardware_HardwareMinAggregateOutputType | null
    _max: Hardware_HardwareMaxAggregateOutputType | null
  }

  export type Hardware_HardwareAvgAggregateOutputType = {
    firstHardwareId: number | null
    secondHardwareId: number | null
    userId: number | null
  }

  export type Hardware_HardwareSumAggregateOutputType = {
    firstHardwareId: number | null
    secondHardwareId: number | null
    userId: number | null
  }

  export type Hardware_HardwareMinAggregateOutputType = {
    assigneddAt: Date | null
    firstHardwareId: number | null
    secondHardwareId: number | null
    userId: number | null
  }

  export type Hardware_HardwareMaxAggregateOutputType = {
    assigneddAt: Date | null
    firstHardwareId: number | null
    secondHardwareId: number | null
    userId: number | null
  }

  export type Hardware_HardwareCountAggregateOutputType = {
    assigneddAt: number
    firstHardwareId: number
    secondHardwareId: number
    userId: number
    _all: number
  }


  export type Hardware_HardwareAvgAggregateInputType = {
    firstHardwareId?: true
    secondHardwareId?: true
    userId?: true
  }

  export type Hardware_HardwareSumAggregateInputType = {
    firstHardwareId?: true
    secondHardwareId?: true
    userId?: true
  }

  export type Hardware_HardwareMinAggregateInputType = {
    assigneddAt?: true
    firstHardwareId?: true
    secondHardwareId?: true
    userId?: true
  }

  export type Hardware_HardwareMaxAggregateInputType = {
    assigneddAt?: true
    firstHardwareId?: true
    secondHardwareId?: true
    userId?: true
  }

  export type Hardware_HardwareCountAggregateInputType = {
    assigneddAt?: true
    firstHardwareId?: true
    secondHardwareId?: true
    userId?: true
    _all?: true
  }

  export type Hardware_HardwareAggregateArgs = {
    /**
     * Filter which Hardware_Hardware to aggregate.
     */
    where?: Hardware_HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hardware_Hardwares to fetch.
     */
    orderBy?: Enumerable<Hardware_HardwareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Hardware_HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hardware_Hardwares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hardware_Hardwares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hardware_Hardwares
    **/
    _count?: true | Hardware_HardwareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Hardware_HardwareAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Hardware_HardwareSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Hardware_HardwareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Hardware_HardwareMaxAggregateInputType
  }

  export type GetHardware_HardwareAggregateType<T extends Hardware_HardwareAggregateArgs> = {
        [P in keyof T & keyof AggregateHardware_Hardware]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHardware_Hardware[P]>
      : GetScalarType<T[P], AggregateHardware_Hardware[P]>
  }




  export type Hardware_HardwareGroupByArgs = {
    where?: Hardware_HardwareWhereInput
    orderBy?: Enumerable<Hardware_HardwareOrderByWithAggregationInput>
    by: Hardware_HardwareScalarFieldEnum[]
    having?: Hardware_HardwareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Hardware_HardwareCountAggregateInputType | true
    _avg?: Hardware_HardwareAvgAggregateInputType
    _sum?: Hardware_HardwareSumAggregateInputType
    _min?: Hardware_HardwareMinAggregateInputType
    _max?: Hardware_HardwareMaxAggregateInputType
  }


  export type Hardware_HardwareGroupByOutputType = {
    assigneddAt: Date
    firstHardwareId: number
    secondHardwareId: number
    userId: number
    _count: Hardware_HardwareCountAggregateOutputType | null
    _avg: Hardware_HardwareAvgAggregateOutputType | null
    _sum: Hardware_HardwareSumAggregateOutputType | null
    _min: Hardware_HardwareMinAggregateOutputType | null
    _max: Hardware_HardwareMaxAggregateOutputType | null
  }

  type GetHardware_HardwareGroupByPayload<T extends Hardware_HardwareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Hardware_HardwareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Hardware_HardwareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Hardware_HardwareGroupByOutputType[P]>
            : GetScalarType<T[P], Hardware_HardwareGroupByOutputType[P]>
        }
      >
    >


  export type Hardware_HardwareSelect = {
    assigneddAt?: boolean
    firstHardwareId?: boolean
    secondHardwareId?: boolean
    userId?: boolean
    firstHardware?: boolean | HardwareArgs
    secondHardware?: boolean | HardwareArgs
    user?: boolean | UserArgs
  }


  export type Hardware_HardwareInclude = {
    firstHardware?: boolean | HardwareArgs
    secondHardware?: boolean | HardwareArgs
    user?: boolean | UserArgs
  }

  export type Hardware_HardwareGetPayload<S extends boolean | null | undefined | Hardware_HardwareArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Hardware_Hardware :
    S extends undefined ? never :
    S extends { include: any } & (Hardware_HardwareArgs | Hardware_HardwareFindManyArgs)
    ? Hardware_Hardware  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'firstHardware' ? HardwareGetPayload<S['include'][P]> :
        P extends 'secondHardware' ? HardwareGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (Hardware_HardwareArgs | Hardware_HardwareFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'firstHardware' ? HardwareGetPayload<S['select'][P]> :
        P extends 'secondHardware' ? HardwareGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Hardware_Hardware ? Hardware_Hardware[P] : never
  } 
      : Hardware_Hardware


  type Hardware_HardwareCountArgs = 
    Omit<Hardware_HardwareFindManyArgs, 'select' | 'include'> & {
      select?: Hardware_HardwareCountAggregateInputType | true
    }

  export interface Hardware_HardwareDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Hardware_Hardware that matches the filter.
     * @param {Hardware_HardwareFindUniqueArgs} args - Arguments to find a Hardware_Hardware
     * @example
     * // Get one Hardware_Hardware
     * const hardware_Hardware = await prisma.hardware_Hardware.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Hardware_HardwareFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Hardware_HardwareFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Hardware_Hardware'> extends True ? Prisma__Hardware_HardwareClient<Hardware_HardwareGetPayload<T>> : Prisma__Hardware_HardwareClient<Hardware_HardwareGetPayload<T> | null, null>

    /**
     * Find one Hardware_Hardware that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Hardware_HardwareFindUniqueOrThrowArgs} args - Arguments to find a Hardware_Hardware
     * @example
     * // Get one Hardware_Hardware
     * const hardware_Hardware = await prisma.hardware_Hardware.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Hardware_HardwareFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Hardware_HardwareFindUniqueOrThrowArgs>
    ): Prisma__Hardware_HardwareClient<Hardware_HardwareGetPayload<T>>

    /**
     * Find the first Hardware_Hardware that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hardware_HardwareFindFirstArgs} args - Arguments to find a Hardware_Hardware
     * @example
     * // Get one Hardware_Hardware
     * const hardware_Hardware = await prisma.hardware_Hardware.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Hardware_HardwareFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Hardware_HardwareFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Hardware_Hardware'> extends True ? Prisma__Hardware_HardwareClient<Hardware_HardwareGetPayload<T>> : Prisma__Hardware_HardwareClient<Hardware_HardwareGetPayload<T> | null, null>

    /**
     * Find the first Hardware_Hardware that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hardware_HardwareFindFirstOrThrowArgs} args - Arguments to find a Hardware_Hardware
     * @example
     * // Get one Hardware_Hardware
     * const hardware_Hardware = await prisma.hardware_Hardware.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Hardware_HardwareFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Hardware_HardwareFindFirstOrThrowArgs>
    ): Prisma__Hardware_HardwareClient<Hardware_HardwareGetPayload<T>>

    /**
     * Find zero or more Hardware_Hardwares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hardware_HardwareFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hardware_Hardwares
     * const hardware_Hardwares = await prisma.hardware_Hardware.findMany()
     * 
     * // Get first 10 Hardware_Hardwares
     * const hardware_Hardwares = await prisma.hardware_Hardware.findMany({ take: 10 })
     * 
     * // Only select the `assigneddAt`
     * const hardware_HardwareWithAssigneddAtOnly = await prisma.hardware_Hardware.findMany({ select: { assigneddAt: true } })
     * 
    **/
    findMany<T extends Hardware_HardwareFindManyArgs>(
      args?: SelectSubset<T, Hardware_HardwareFindManyArgs>
    ): Prisma.PrismaPromise<Array<Hardware_HardwareGetPayload<T>>>

    /**
     * Create a Hardware_Hardware.
     * @param {Hardware_HardwareCreateArgs} args - Arguments to create a Hardware_Hardware.
     * @example
     * // Create one Hardware_Hardware
     * const Hardware_Hardware = await prisma.hardware_Hardware.create({
     *   data: {
     *     // ... data to create a Hardware_Hardware
     *   }
     * })
     * 
    **/
    create<T extends Hardware_HardwareCreateArgs>(
      args: SelectSubset<T, Hardware_HardwareCreateArgs>
    ): Prisma__Hardware_HardwareClient<Hardware_HardwareGetPayload<T>>

    /**
     * Create many Hardware_Hardwares.
     *     @param {Hardware_HardwareCreateManyArgs} args - Arguments to create many Hardware_Hardwares.
     *     @example
     *     // Create many Hardware_Hardwares
     *     const hardware_Hardware = await prisma.hardware_Hardware.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Hardware_HardwareCreateManyArgs>(
      args?: SelectSubset<T, Hardware_HardwareCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hardware_Hardware.
     * @param {Hardware_HardwareDeleteArgs} args - Arguments to delete one Hardware_Hardware.
     * @example
     * // Delete one Hardware_Hardware
     * const Hardware_Hardware = await prisma.hardware_Hardware.delete({
     *   where: {
     *     // ... filter to delete one Hardware_Hardware
     *   }
     * })
     * 
    **/
    delete<T extends Hardware_HardwareDeleteArgs>(
      args: SelectSubset<T, Hardware_HardwareDeleteArgs>
    ): Prisma__Hardware_HardwareClient<Hardware_HardwareGetPayload<T>>

    /**
     * Update one Hardware_Hardware.
     * @param {Hardware_HardwareUpdateArgs} args - Arguments to update one Hardware_Hardware.
     * @example
     * // Update one Hardware_Hardware
     * const hardware_Hardware = await prisma.hardware_Hardware.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Hardware_HardwareUpdateArgs>(
      args: SelectSubset<T, Hardware_HardwareUpdateArgs>
    ): Prisma__Hardware_HardwareClient<Hardware_HardwareGetPayload<T>>

    /**
     * Delete zero or more Hardware_Hardwares.
     * @param {Hardware_HardwareDeleteManyArgs} args - Arguments to filter Hardware_Hardwares to delete.
     * @example
     * // Delete a few Hardware_Hardwares
     * const { count } = await prisma.hardware_Hardware.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Hardware_HardwareDeleteManyArgs>(
      args?: SelectSubset<T, Hardware_HardwareDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hardware_Hardwares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hardware_HardwareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hardware_Hardwares
     * const hardware_Hardware = await prisma.hardware_Hardware.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Hardware_HardwareUpdateManyArgs>(
      args: SelectSubset<T, Hardware_HardwareUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hardware_Hardware.
     * @param {Hardware_HardwareUpsertArgs} args - Arguments to update or create a Hardware_Hardware.
     * @example
     * // Update or create a Hardware_Hardware
     * const hardware_Hardware = await prisma.hardware_Hardware.upsert({
     *   create: {
     *     // ... data to create a Hardware_Hardware
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hardware_Hardware we want to update
     *   }
     * })
    **/
    upsert<T extends Hardware_HardwareUpsertArgs>(
      args: SelectSubset<T, Hardware_HardwareUpsertArgs>
    ): Prisma__Hardware_HardwareClient<Hardware_HardwareGetPayload<T>>

    /**
     * Count the number of Hardware_Hardwares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hardware_HardwareCountArgs} args - Arguments to filter Hardware_Hardwares to count.
     * @example
     * // Count the number of Hardware_Hardwares
     * const count = await prisma.hardware_Hardware.count({
     *   where: {
     *     // ... the filter for the Hardware_Hardwares we want to count
     *   }
     * })
    **/
    count<T extends Hardware_HardwareCountArgs>(
      args?: Subset<T, Hardware_HardwareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Hardware_HardwareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hardware_Hardware.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hardware_HardwareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Hardware_HardwareAggregateArgs>(args: Subset<T, Hardware_HardwareAggregateArgs>): Prisma.PrismaPromise<GetHardware_HardwareAggregateType<T>>

    /**
     * Group by Hardware_Hardware.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hardware_HardwareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Hardware_HardwareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Hardware_HardwareGroupByArgs['orderBy'] }
        : { orderBy?: Hardware_HardwareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Hardware_HardwareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHardware_HardwareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Hardware_Hardware.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Hardware_HardwareClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    firstHardware<T extends HardwareArgs= {}>(args?: Subset<T, HardwareArgs>): Prisma__HardwareClient<HardwareGetPayload<T> | Null>;

    secondHardware<T extends HardwareArgs= {}>(args?: Subset<T, HardwareArgs>): Prisma__HardwareClient<HardwareGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Hardware_Hardware base type for findUnique actions
   */
  export type Hardware_HardwareFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Hardware_Hardware
     */
    select?: Hardware_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Hardware_HardwareInclude | null
    /**
     * Filter, which Hardware_Hardware to fetch.
     */
    where: Hardware_HardwareWhereUniqueInput
  }

  /**
   * Hardware_Hardware findUnique
   */
  export interface Hardware_HardwareFindUniqueArgs extends Hardware_HardwareFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Hardware_Hardware findUniqueOrThrow
   */
  export type Hardware_HardwareFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Hardware_Hardware
     */
    select?: Hardware_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Hardware_HardwareInclude | null
    /**
     * Filter, which Hardware_Hardware to fetch.
     */
    where: Hardware_HardwareWhereUniqueInput
  }


  /**
   * Hardware_Hardware base type for findFirst actions
   */
  export type Hardware_HardwareFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Hardware_Hardware
     */
    select?: Hardware_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Hardware_HardwareInclude | null
    /**
     * Filter, which Hardware_Hardware to fetch.
     */
    where?: Hardware_HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hardware_Hardwares to fetch.
     */
    orderBy?: Enumerable<Hardware_HardwareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hardware_Hardwares.
     */
    cursor?: Hardware_HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hardware_Hardwares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hardware_Hardwares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hardware_Hardwares.
     */
    distinct?: Enumerable<Hardware_HardwareScalarFieldEnum>
  }

  /**
   * Hardware_Hardware findFirst
   */
  export interface Hardware_HardwareFindFirstArgs extends Hardware_HardwareFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Hardware_Hardware findFirstOrThrow
   */
  export type Hardware_HardwareFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Hardware_Hardware
     */
    select?: Hardware_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Hardware_HardwareInclude | null
    /**
     * Filter, which Hardware_Hardware to fetch.
     */
    where?: Hardware_HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hardware_Hardwares to fetch.
     */
    orderBy?: Enumerable<Hardware_HardwareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hardware_Hardwares.
     */
    cursor?: Hardware_HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hardware_Hardwares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hardware_Hardwares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hardware_Hardwares.
     */
    distinct?: Enumerable<Hardware_HardwareScalarFieldEnum>
  }


  /**
   * Hardware_Hardware findMany
   */
  export type Hardware_HardwareFindManyArgs = {
    /**
     * Select specific fields to fetch from the Hardware_Hardware
     */
    select?: Hardware_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Hardware_HardwareInclude | null
    /**
     * Filter, which Hardware_Hardwares to fetch.
     */
    where?: Hardware_HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hardware_Hardwares to fetch.
     */
    orderBy?: Enumerable<Hardware_HardwareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hardware_Hardwares.
     */
    cursor?: Hardware_HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hardware_Hardwares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hardware_Hardwares.
     */
    skip?: number
    distinct?: Enumerable<Hardware_HardwareScalarFieldEnum>
  }


  /**
   * Hardware_Hardware create
   */
  export type Hardware_HardwareCreateArgs = {
    /**
     * Select specific fields to fetch from the Hardware_Hardware
     */
    select?: Hardware_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Hardware_HardwareInclude | null
    /**
     * The data needed to create a Hardware_Hardware.
     */
    data: XOR<Hardware_HardwareCreateInput, Hardware_HardwareUncheckedCreateInput>
  }


  /**
   * Hardware_Hardware createMany
   */
  export type Hardware_HardwareCreateManyArgs = {
    /**
     * The data used to create many Hardware_Hardwares.
     */
    data: Enumerable<Hardware_HardwareCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Hardware_Hardware update
   */
  export type Hardware_HardwareUpdateArgs = {
    /**
     * Select specific fields to fetch from the Hardware_Hardware
     */
    select?: Hardware_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Hardware_HardwareInclude | null
    /**
     * The data needed to update a Hardware_Hardware.
     */
    data: XOR<Hardware_HardwareUpdateInput, Hardware_HardwareUncheckedUpdateInput>
    /**
     * Choose, which Hardware_Hardware to update.
     */
    where: Hardware_HardwareWhereUniqueInput
  }


  /**
   * Hardware_Hardware updateMany
   */
  export type Hardware_HardwareUpdateManyArgs = {
    /**
     * The data used to update Hardware_Hardwares.
     */
    data: XOR<Hardware_HardwareUpdateManyMutationInput, Hardware_HardwareUncheckedUpdateManyInput>
    /**
     * Filter which Hardware_Hardwares to update
     */
    where?: Hardware_HardwareWhereInput
  }


  /**
   * Hardware_Hardware upsert
   */
  export type Hardware_HardwareUpsertArgs = {
    /**
     * Select specific fields to fetch from the Hardware_Hardware
     */
    select?: Hardware_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Hardware_HardwareInclude | null
    /**
     * The filter to search for the Hardware_Hardware to update in case it exists.
     */
    where: Hardware_HardwareWhereUniqueInput
    /**
     * In case the Hardware_Hardware found by the `where` argument doesn't exist, create a new Hardware_Hardware with this data.
     */
    create: XOR<Hardware_HardwareCreateInput, Hardware_HardwareUncheckedCreateInput>
    /**
     * In case the Hardware_Hardware was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Hardware_HardwareUpdateInput, Hardware_HardwareUncheckedUpdateInput>
  }


  /**
   * Hardware_Hardware delete
   */
  export type Hardware_HardwareDeleteArgs = {
    /**
     * Select specific fields to fetch from the Hardware_Hardware
     */
    select?: Hardware_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Hardware_HardwareInclude | null
    /**
     * Filter which Hardware_Hardware to delete.
     */
    where: Hardware_HardwareWhereUniqueInput
  }


  /**
   * Hardware_Hardware deleteMany
   */
  export type Hardware_HardwareDeleteManyArgs = {
    /**
     * Filter which Hardware_Hardwares to delete
     */
    where?: Hardware_HardwareWhereInput
  }


  /**
   * Hardware_Hardware without action
   */
  export type Hardware_HardwareArgs = {
    /**
     * Select specific fields to fetch from the Hardware_Hardware
     */
    select?: Hardware_HardwareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Hardware_HardwareInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ArticleCommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    modifiedAt: 'modifiedAt',
    userId: 'userId',
    articleId: 'articleId'
  };

  export type ArticleCommentScalarFieldEnum = (typeof ArticleCommentScalarFieldEnum)[keyof typeof ArticleCommentScalarFieldEnum]


  export const ArticleDocumentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    mimetype: 'mimetype',
    buffer: 'buffer',
    size: 'size',
    createdAt: 'createdAt',
    documentTypeId: 'documentTypeId',
    userId: 'userId',
    articleId: 'articleId'
  };

  export type ArticleDocumentScalarFieldEnum = (typeof ArticleDocumentScalarFieldEnum)[keyof typeof ArticleDocumentScalarFieldEnum]


  export const ArticleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subDescription: 'subDescription',
    description: 'description',
    isPublished: 'isPublished',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    modifiedAt: 'modifiedAt',
    userId: 'userId',
    articleTypeId: 'articleTypeId',
    articleId: 'articleId'
  };

  export type ArticleScalarFieldEnum = (typeof ArticleScalarFieldEnum)[keyof typeof ArticleScalarFieldEnum]


  export const ArticleTypeScalarFieldEnum: {
    id: 'id',
    type: 'type'
  };

  export type ArticleTypeScalarFieldEnum = (typeof ArticleTypeScalarFieldEnum)[keyof typeof ArticleTypeScalarFieldEnum]


  export const Article_HardwareScalarFieldEnum: {
    assigneddAt: 'assigneddAt',
    articleId: 'articleId',
    hardwareId: 'hardwareId',
    userId: 'userId'
  };

  export type Article_HardwareScalarFieldEnum = (typeof Article_HardwareScalarFieldEnum)[keyof typeof Article_HardwareScalarFieldEnum]


  export const DocumentTypeScalarFieldEnum: {
    id: 'id',
    type: 'type'
  };

  export type DocumentTypeScalarFieldEnum = (typeof DocumentTypeScalarFieldEnum)[keyof typeof DocumentTypeScalarFieldEnum]


  export const HardwareCommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    modifiedAt: 'modifiedAt',
    userId: 'userId',
    hardwareId: 'hardwareId'
  };

  export type HardwareCommentScalarFieldEnum = (typeof HardwareCommentScalarFieldEnum)[keyof typeof HardwareCommentScalarFieldEnum]


  export const HardwareDocumentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    mimetype: 'mimetype',
    buffer: 'buffer',
    size: 'size',
    createdAt: 'createdAt',
    documentTypeId: 'documentTypeId',
    userId: 'userId',
    hardwareId: 'hardwareId'
  };

  export type HardwareDocumentScalarFieldEnum = (typeof HardwareDocumentScalarFieldEnum)[keyof typeof HardwareDocumentScalarFieldEnum]


  export const HardwareScalarFieldEnum: {
    id: 'id',
    name: 'name',
    brand: 'brand',
    subDescription: 'subDescription',
    description: 'description',
    isDiy: 'isDiy',
    creationDate: 'creationDate',
    discontinuationDate: 'discontinuationDate',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    modifiedAt: 'modifiedAt',
    commercialLinks: 'commercialLinks',
    userId: 'userId',
    hardwareTypeId: 'hardwareTypeId'
  };

  export type HardwareScalarFieldEnum = (typeof HardwareScalarFieldEnum)[keyof typeof HardwareScalarFieldEnum]


  export const HardwareTypeScalarFieldEnum: {
    id: 'id',
    type: 'type'
  };

  export type HardwareTypeScalarFieldEnum = (typeof HardwareTypeScalarFieldEnum)[keyof typeof HardwareTypeScalarFieldEnum]


  export const Hardware_HardwareScalarFieldEnum: {
    assigneddAt: 'assigneddAt',
    firstHardwareId: 'firstHardwareId',
    secondHardwareId: 'secondHardwareId',
    userId: 'userId'
  };

  export type Hardware_HardwareScalarFieldEnum = (typeof Hardware_HardwareScalarFieldEnum)[keyof typeof Hardware_HardwareScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const RoleScalarFieldEnum: {
    id: 'id',
    role: 'role'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstname: 'firstname',
    lastname: 'lastname',
    username: 'username',
    email: 'email',
    password: 'password',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    roleId: 'roleId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type RoleWhereInput = {
    AND?: Enumerable<RoleWhereInput>
    OR?: Enumerable<RoleWhereInput>
    NOT?: Enumerable<RoleWhereInput>
    id?: IntFilter | number
    role?: StringFilter | string
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = {
    id?: number
    role?: string
  }

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    role?: StringWithAggregatesFilter | string
  }

  export type ArticleTypeWhereInput = {
    AND?: Enumerable<ArticleTypeWhereInput>
    OR?: Enumerable<ArticleTypeWhereInput>
    NOT?: Enumerable<ArticleTypeWhereInput>
    id?: IntFilter | number
    type?: StringFilter | string
    articles?: ArticleListRelationFilter
  }

  export type ArticleTypeOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    articles?: ArticleOrderByRelationAggregateInput
  }

  export type ArticleTypeWhereUniqueInput = {
    id?: number
    type?: string
  }

  export type ArticleTypeOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    _count?: ArticleTypeCountOrderByAggregateInput
    _avg?: ArticleTypeAvgOrderByAggregateInput
    _max?: ArticleTypeMaxOrderByAggregateInput
    _min?: ArticleTypeMinOrderByAggregateInput
    _sum?: ArticleTypeSumOrderByAggregateInput
  }

  export type ArticleTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ArticleTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<ArticleTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ArticleTypeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: StringWithAggregatesFilter | string
  }

  export type HardwareTypeWhereInput = {
    AND?: Enumerable<HardwareTypeWhereInput>
    OR?: Enumerable<HardwareTypeWhereInput>
    NOT?: Enumerable<HardwareTypeWhereInput>
    id?: IntFilter | number
    type?: StringFilter | string
    hardwares?: HardwareListRelationFilter
  }

  export type HardwareTypeOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    hardwares?: HardwareOrderByRelationAggregateInput
  }

  export type HardwareTypeWhereUniqueInput = {
    id?: number
    type?: string
  }

  export type HardwareTypeOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    _count?: HardwareTypeCountOrderByAggregateInput
    _avg?: HardwareTypeAvgOrderByAggregateInput
    _max?: HardwareTypeMaxOrderByAggregateInput
    _min?: HardwareTypeMinOrderByAggregateInput
    _sum?: HardwareTypeSumOrderByAggregateInput
  }

  export type HardwareTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HardwareTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<HardwareTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HardwareTypeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: StringWithAggregatesFilter | string
  }

  export type DocumentTypeWhereInput = {
    AND?: Enumerable<DocumentTypeWhereInput>
    OR?: Enumerable<DocumentTypeWhereInput>
    NOT?: Enumerable<DocumentTypeWhereInput>
    id?: IntFilter | number
    type?: StringFilter | string
    articleDocuments?: ArticleDocumentListRelationFilter
    hardwareDocument?: HardwareDocumentListRelationFilter
  }

  export type DocumentTypeOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    articleDocuments?: ArticleDocumentOrderByRelationAggregateInput
    hardwareDocument?: HardwareDocumentOrderByRelationAggregateInput
  }

  export type DocumentTypeWhereUniqueInput = {
    id?: number
    type?: string
  }

  export type DocumentTypeOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    _count?: DocumentTypeCountOrderByAggregateInput
    _avg?: DocumentTypeAvgOrderByAggregateInput
    _max?: DocumentTypeMaxOrderByAggregateInput
    _min?: DocumentTypeMinOrderByAggregateInput
    _sum?: DocumentTypeSumOrderByAggregateInput
  }

  export type DocumentTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DocumentTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<DocumentTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DocumentTypeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: StringWithAggregatesFilter | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    firstname?: StringFilter | string
    lastname?: StringFilter | string
    username?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    roleId?: IntFilter | number
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    articles?: ArticleListRelationFilter
    articleDocuments?: ArticleDocumentListRelationFilter
    articleComments?: ArticleCommentListRelationFilter
    hardwares?: HardwareListRelationFilter
    hardwareDocuments?: HardwareDocumentListRelationFilter
    hardwareComments?: HardwareCommentListRelationFilter
    article_hardware?: Article_HardwareListRelationFilter
    hardware_hardware?: Hardware_HardwareListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    roleId?: SortOrder
    role?: RoleOrderByWithRelationInput
    articles?: ArticleOrderByRelationAggregateInput
    articleDocuments?: ArticleDocumentOrderByRelationAggregateInput
    articleComments?: ArticleCommentOrderByRelationAggregateInput
    hardwares?: HardwareOrderByRelationAggregateInput
    hardwareDocuments?: HardwareDocumentOrderByRelationAggregateInput
    hardwareComments?: HardwareCommentOrderByRelationAggregateInput
    article_hardware?: Article_HardwareOrderByRelationAggregateInput
    hardware_hardware?: Hardware_HardwareOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    username?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    roleId?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    firstname?: StringWithAggregatesFilter | string
    lastname?: StringWithAggregatesFilter | string
    username?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    roleId?: IntWithAggregatesFilter | number
  }

  export type ArticleWhereInput = {
    AND?: Enumerable<ArticleWhereInput>
    OR?: Enumerable<ArticleWhereInput>
    NOT?: Enumerable<ArticleWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    subDescription?: StringFilter | string
    description?: StringFilter | string
    isPublished?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    modifiedAt?: DateTimeNullableFilter | Date | string | null
    userId?: IntFilter | number
    articleTypeId?: IntFilter | number
    articleId?: IntNullableFilter | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    articleType?: XOR<ArticleTypeRelationFilter, ArticleTypeWhereInput>
    article?: XOR<ArticleRelationFilter, ArticleWhereInput> | null
    articles?: ArticleListRelationFilter
    articleDocuments?: ArticleDocumentListRelationFilter
    articleComments?: ArticleCommentListRelationFilter
    article_hardware?: Article_HardwareListRelationFilter
  }

  export type ArticleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subDescription?: SortOrder
    description?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    userId?: SortOrder
    articleTypeId?: SortOrder
    articleId?: SortOrder
    user?: UserOrderByWithRelationInput
    articleType?: ArticleTypeOrderByWithRelationInput
    article?: ArticleOrderByWithRelationInput
    articles?: ArticleOrderByRelationAggregateInput
    articleDocuments?: ArticleDocumentOrderByRelationAggregateInput
    articleComments?: ArticleCommentOrderByRelationAggregateInput
    article_hardware?: Article_HardwareOrderByRelationAggregateInput
  }

  export type ArticleWhereUniqueInput = {
    id?: number
  }

  export type ArticleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subDescription?: SortOrder
    description?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    userId?: SortOrder
    articleTypeId?: SortOrder
    articleId?: SortOrder
    _count?: ArticleCountOrderByAggregateInput
    _avg?: ArticleAvgOrderByAggregateInput
    _max?: ArticleMaxOrderByAggregateInput
    _min?: ArticleMinOrderByAggregateInput
    _sum?: ArticleSumOrderByAggregateInput
  }

  export type ArticleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ArticleScalarWhereWithAggregatesInput>
    OR?: Enumerable<ArticleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ArticleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    subDescription?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    isPublished?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    modifiedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    userId?: IntWithAggregatesFilter | number
    articleTypeId?: IntWithAggregatesFilter | number
    articleId?: IntNullableWithAggregatesFilter | number | null
  }

  export type HardwareWhereInput = {
    AND?: Enumerable<HardwareWhereInput>
    OR?: Enumerable<HardwareWhereInput>
    NOT?: Enumerable<HardwareWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    brand?: StringFilter | string
    subDescription?: StringFilter | string
    description?: StringFilter | string
    isDiy?: BoolFilter | boolean
    creationDate?: DateTimeFilter | Date | string
    discontinuationDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    modifiedAt?: DateTimeNullableFilter | Date | string | null
    commercialLinks?: StringNullableListFilter
    userId?: IntFilter | number
    hardwareTypeId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    hardwareType?: XOR<HardwareTypeRelationFilter, HardwareTypeWhereInput>
    hardwareDocuments?: HardwareDocumentListRelationFilter
    hardwareComments?: HardwareCommentListRelationFilter
    article_hardware?: Article_HardwareListRelationFilter
    firstHardwareOf?: Hardware_HardwareListRelationFilter
    secondHardwares?: Hardware_HardwareListRelationFilter
  }

  export type HardwareOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    subDescription?: SortOrder
    description?: SortOrder
    isDiy?: SortOrder
    creationDate?: SortOrder
    discontinuationDate?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    commercialLinks?: SortOrder
    userId?: SortOrder
    hardwareTypeId?: SortOrder
    user?: UserOrderByWithRelationInput
    hardwareType?: HardwareTypeOrderByWithRelationInput
    hardwareDocuments?: HardwareDocumentOrderByRelationAggregateInput
    hardwareComments?: HardwareCommentOrderByRelationAggregateInput
    article_hardware?: Article_HardwareOrderByRelationAggregateInput
    firstHardwareOf?: Hardware_HardwareOrderByRelationAggregateInput
    secondHardwares?: Hardware_HardwareOrderByRelationAggregateInput
  }

  export type HardwareWhereUniqueInput = {
    id?: number
  }

  export type HardwareOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    subDescription?: SortOrder
    description?: SortOrder
    isDiy?: SortOrder
    creationDate?: SortOrder
    discontinuationDate?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    commercialLinks?: SortOrder
    userId?: SortOrder
    hardwareTypeId?: SortOrder
    _count?: HardwareCountOrderByAggregateInput
    _avg?: HardwareAvgOrderByAggregateInput
    _max?: HardwareMaxOrderByAggregateInput
    _min?: HardwareMinOrderByAggregateInput
    _sum?: HardwareSumOrderByAggregateInput
  }

  export type HardwareScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HardwareScalarWhereWithAggregatesInput>
    OR?: Enumerable<HardwareScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HardwareScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    brand?: StringWithAggregatesFilter | string
    subDescription?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    isDiy?: BoolWithAggregatesFilter | boolean
    creationDate?: DateTimeWithAggregatesFilter | Date | string
    discontinuationDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    modifiedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    commercialLinks?: StringNullableListFilter
    userId?: IntWithAggregatesFilter | number
    hardwareTypeId?: IntWithAggregatesFilter | number
  }

  export type ArticleDocumentWhereInput = {
    AND?: Enumerable<ArticleDocumentWhereInput>
    OR?: Enumerable<ArticleDocumentWhereInput>
    NOT?: Enumerable<ArticleDocumentWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    mimetype?: StringFilter | string
    buffer?: BytesFilter | Buffer
    size?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    documentTypeId?: IntFilter | number
    userId?: IntFilter | number
    articleId?: IntFilter | number
    documentType?: XOR<DocumentTypeRelationFilter, DocumentTypeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    article?: XOR<ArticleRelationFilter, ArticleWhereInput>
  }

  export type ArticleDocumentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    mimetype?: SortOrder
    buffer?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    documentTypeId?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
    documentType?: DocumentTypeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    article?: ArticleOrderByWithRelationInput
  }

  export type ArticleDocumentWhereUniqueInput = {
    id?: number
  }

  export type ArticleDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    mimetype?: SortOrder
    buffer?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    documentTypeId?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
    _count?: ArticleDocumentCountOrderByAggregateInput
    _avg?: ArticleDocumentAvgOrderByAggregateInput
    _max?: ArticleDocumentMaxOrderByAggregateInput
    _min?: ArticleDocumentMinOrderByAggregateInput
    _sum?: ArticleDocumentSumOrderByAggregateInput
  }

  export type ArticleDocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ArticleDocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<ArticleDocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ArticleDocumentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    mimetype?: StringWithAggregatesFilter | string
    buffer?: BytesWithAggregatesFilter | Buffer
    size?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    documentTypeId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    articleId?: IntWithAggregatesFilter | number
  }

  export type ArticleCommentWhereInput = {
    AND?: Enumerable<ArticleCommentWhereInput>
    OR?: Enumerable<ArticleCommentWhereInput>
    NOT?: Enumerable<ArticleCommentWhereInput>
    id?: IntFilter | number
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    modifiedAt?: DateTimeNullableFilter | Date | string | null
    userId?: IntFilter | number
    articleId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    article?: XOR<ArticleRelationFilter, ArticleWhereInput>
  }

  export type ArticleCommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
    user?: UserOrderByWithRelationInput
    article?: ArticleOrderByWithRelationInput
  }

  export type ArticleCommentWhereUniqueInput = {
    id?: number
  }

  export type ArticleCommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
    _count?: ArticleCommentCountOrderByAggregateInput
    _avg?: ArticleCommentAvgOrderByAggregateInput
    _max?: ArticleCommentMaxOrderByAggregateInput
    _min?: ArticleCommentMinOrderByAggregateInput
    _sum?: ArticleCommentSumOrderByAggregateInput
  }

  export type ArticleCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ArticleCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<ArticleCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ArticleCommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    content?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    modifiedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    userId?: IntWithAggregatesFilter | number
    articleId?: IntWithAggregatesFilter | number
  }

  export type HardwareDocumentWhereInput = {
    AND?: Enumerable<HardwareDocumentWhereInput>
    OR?: Enumerable<HardwareDocumentWhereInput>
    NOT?: Enumerable<HardwareDocumentWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    mimetype?: StringFilter | string
    buffer?: BytesFilter | Buffer
    size?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    documentTypeId?: IntFilter | number
    userId?: IntFilter | number
    hardwareId?: IntFilter | number
    documentType?: XOR<DocumentTypeRelationFilter, DocumentTypeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    hardware?: XOR<HardwareRelationFilter, HardwareWhereInput>
  }

  export type HardwareDocumentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    mimetype?: SortOrder
    buffer?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    documentTypeId?: SortOrder
    userId?: SortOrder
    hardwareId?: SortOrder
    documentType?: DocumentTypeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    hardware?: HardwareOrderByWithRelationInput
  }

  export type HardwareDocumentWhereUniqueInput = {
    id?: number
  }

  export type HardwareDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    mimetype?: SortOrder
    buffer?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    documentTypeId?: SortOrder
    userId?: SortOrder
    hardwareId?: SortOrder
    _count?: HardwareDocumentCountOrderByAggregateInput
    _avg?: HardwareDocumentAvgOrderByAggregateInput
    _max?: HardwareDocumentMaxOrderByAggregateInput
    _min?: HardwareDocumentMinOrderByAggregateInput
    _sum?: HardwareDocumentSumOrderByAggregateInput
  }

  export type HardwareDocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HardwareDocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<HardwareDocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HardwareDocumentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    mimetype?: StringWithAggregatesFilter | string
    buffer?: BytesWithAggregatesFilter | Buffer
    size?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    documentTypeId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    hardwareId?: IntWithAggregatesFilter | number
  }

  export type HardwareCommentWhereInput = {
    AND?: Enumerable<HardwareCommentWhereInput>
    OR?: Enumerable<HardwareCommentWhereInput>
    NOT?: Enumerable<HardwareCommentWhereInput>
    id?: IntFilter | number
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    modifiedAt?: DateTimeNullableFilter | Date | string | null
    userId?: IntFilter | number
    hardwareId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    hardware?: XOR<HardwareRelationFilter, HardwareWhereInput>
  }

  export type HardwareCommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    userId?: SortOrder
    hardwareId?: SortOrder
    user?: UserOrderByWithRelationInput
    hardware?: HardwareOrderByWithRelationInput
  }

  export type HardwareCommentWhereUniqueInput = {
    id?: number
  }

  export type HardwareCommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    userId?: SortOrder
    hardwareId?: SortOrder
    _count?: HardwareCommentCountOrderByAggregateInput
    _avg?: HardwareCommentAvgOrderByAggregateInput
    _max?: HardwareCommentMaxOrderByAggregateInput
    _min?: HardwareCommentMinOrderByAggregateInput
    _sum?: HardwareCommentSumOrderByAggregateInput
  }

  export type HardwareCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HardwareCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<HardwareCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HardwareCommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    content?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    modifiedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    userId?: IntWithAggregatesFilter | number
    hardwareId?: IntWithAggregatesFilter | number
  }

  export type Article_HardwareWhereInput = {
    AND?: Enumerable<Article_HardwareWhereInput>
    OR?: Enumerable<Article_HardwareWhereInput>
    NOT?: Enumerable<Article_HardwareWhereInput>
    assigneddAt?: DateTimeFilter | Date | string
    articleId?: IntFilter | number
    hardwareId?: IntFilter | number
    userId?: IntFilter | number
    article?: XOR<ArticleRelationFilter, ArticleWhereInput>
    hardware?: XOR<HardwareRelationFilter, HardwareWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type Article_HardwareOrderByWithRelationInput = {
    assigneddAt?: SortOrder
    articleId?: SortOrder
    hardwareId?: SortOrder
    userId?: SortOrder
    article?: ArticleOrderByWithRelationInput
    hardware?: HardwareOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type Article_HardwareWhereUniqueInput = {
    articleHardwareId?: Article_HardwareArticleHardwareIdCompoundUniqueInput
  }

  export type Article_HardwareOrderByWithAggregationInput = {
    assigneddAt?: SortOrder
    articleId?: SortOrder
    hardwareId?: SortOrder
    userId?: SortOrder
    _count?: Article_HardwareCountOrderByAggregateInput
    _avg?: Article_HardwareAvgOrderByAggregateInput
    _max?: Article_HardwareMaxOrderByAggregateInput
    _min?: Article_HardwareMinOrderByAggregateInput
    _sum?: Article_HardwareSumOrderByAggregateInput
  }

  export type Article_HardwareScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Article_HardwareScalarWhereWithAggregatesInput>
    OR?: Enumerable<Article_HardwareScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Article_HardwareScalarWhereWithAggregatesInput>
    assigneddAt?: DateTimeWithAggregatesFilter | Date | string
    articleId?: IntWithAggregatesFilter | number
    hardwareId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
  }

  export type Hardware_HardwareWhereInput = {
    AND?: Enumerable<Hardware_HardwareWhereInput>
    OR?: Enumerable<Hardware_HardwareWhereInput>
    NOT?: Enumerable<Hardware_HardwareWhereInput>
    assigneddAt?: DateTimeFilter | Date | string
    firstHardwareId?: IntFilter | number
    secondHardwareId?: IntFilter | number
    userId?: IntFilter | number
    firstHardware?: XOR<HardwareRelationFilter, HardwareWhereInput>
    secondHardware?: XOR<HardwareRelationFilter, HardwareWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type Hardware_HardwareOrderByWithRelationInput = {
    assigneddAt?: SortOrder
    firstHardwareId?: SortOrder
    secondHardwareId?: SortOrder
    userId?: SortOrder
    firstHardware?: HardwareOrderByWithRelationInput
    secondHardware?: HardwareOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type Hardware_HardwareWhereUniqueInput = {
    hardwareRelationId?: Hardware_HardwareHardwareRelationIdCompoundUniqueInput
  }

  export type Hardware_HardwareOrderByWithAggregationInput = {
    assigneddAt?: SortOrder
    firstHardwareId?: SortOrder
    secondHardwareId?: SortOrder
    userId?: SortOrder
    _count?: Hardware_HardwareCountOrderByAggregateInput
    _avg?: Hardware_HardwareAvgOrderByAggregateInput
    _max?: Hardware_HardwareMaxOrderByAggregateInput
    _min?: Hardware_HardwareMinOrderByAggregateInput
    _sum?: Hardware_HardwareSumOrderByAggregateInput
  }

  export type Hardware_HardwareScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Hardware_HardwareScalarWhereWithAggregatesInput>
    OR?: Enumerable<Hardware_HardwareScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Hardware_HardwareScalarWhereWithAggregatesInput>
    assigneddAt?: DateTimeWithAggregatesFilter | Date | string
    firstHardwareId?: IntWithAggregatesFilter | number
    secondHardwareId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
  }

  export type RoleCreateInput = {
    role: string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    role: string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    role: string
  }

  export type RoleUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleTypeCreateInput = {
    type: string
    articles?: ArticleCreateNestedManyWithoutArticleTypeInput
  }

  export type ArticleTypeUncheckedCreateInput = {
    id?: number
    type: string
    articles?: ArticleUncheckedCreateNestedManyWithoutArticleTypeInput
  }

  export type ArticleTypeUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    articles?: ArticleUpdateManyWithoutArticleTypeNestedInput
  }

  export type ArticleTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    articles?: ArticleUncheckedUpdateManyWithoutArticleTypeNestedInput
  }

  export type ArticleTypeCreateManyInput = {
    id?: number
    type: string
  }

  export type ArticleTypeUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type HardwareTypeCreateInput = {
    type: string
    hardwares?: HardwareCreateNestedManyWithoutHardwareTypeInput
  }

  export type HardwareTypeUncheckedCreateInput = {
    id?: number
    type: string
    hardwares?: HardwareUncheckedCreateNestedManyWithoutHardwareTypeInput
  }

  export type HardwareTypeUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    hardwares?: HardwareUpdateManyWithoutHardwareTypeNestedInput
  }

  export type HardwareTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    hardwares?: HardwareUncheckedUpdateManyWithoutHardwareTypeNestedInput
  }

  export type HardwareTypeCreateManyInput = {
    id?: number
    type: string
  }

  export type HardwareTypeUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
  }

  export type HardwareTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentTypeCreateInput = {
    type: string
    articleDocuments?: ArticleDocumentCreateNestedManyWithoutDocumentTypeInput
    hardwareDocument?: HardwareDocumentCreateNestedManyWithoutDocumentTypeInput
  }

  export type DocumentTypeUncheckedCreateInput = {
    id?: number
    type: string
    articleDocuments?: ArticleDocumentUncheckedCreateNestedManyWithoutDocumentTypeInput
    hardwareDocument?: HardwareDocumentUncheckedCreateNestedManyWithoutDocumentTypeInput
  }

  export type DocumentTypeUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    articleDocuments?: ArticleDocumentUpdateManyWithoutDocumentTypeNestedInput
    hardwareDocument?: HardwareDocumentUpdateManyWithoutDocumentTypeNestedInput
  }

  export type DocumentTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    articleDocuments?: ArticleDocumentUncheckedUpdateManyWithoutDocumentTypeNestedInput
    hardwareDocument?: HardwareDocumentUncheckedUpdateManyWithoutDocumentTypeNestedInput
  }

  export type DocumentTypeCreateManyInput = {
    id?: number
    type: string
  }

  export type DocumentTypeUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    role: RoleCreateNestedOneWithoutUsersInput
    articles?: ArticleCreateNestedManyWithoutUserInput
    articleDocuments?: ArticleDocumentCreateNestedManyWithoutUserInput
    articleComments?: ArticleCommentCreateNestedManyWithoutUserInput
    hardwares?: HardwareCreateNestedManyWithoutUserInput
    hardwareDocuments?: HardwareDocumentCreateNestedManyWithoutUserInput
    hardwareComments?: HardwareCommentCreateNestedManyWithoutUserInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutUserInput
    hardware_hardware?: Hardware_HardwareCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    roleId: number
    articles?: ArticleUncheckedCreateNestedManyWithoutUserInput
    articleDocuments?: ArticleDocumentUncheckedCreateNestedManyWithoutUserInput
    articleComments?: ArticleCommentUncheckedCreateNestedManyWithoutUserInput
    hardwares?: HardwareUncheckedCreateNestedManyWithoutUserInput
    hardwareDocuments?: HardwareDocumentUncheckedCreateNestedManyWithoutUserInput
    hardwareComments?: HardwareCommentUncheckedCreateNestedManyWithoutUserInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutUserInput
    hardware_hardware?: Hardware_HardwareUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    articles?: ArticleUpdateManyWithoutUserNestedInput
    articleDocuments?: ArticleDocumentUpdateManyWithoutUserNestedInput
    articleComments?: ArticleCommentUpdateManyWithoutUserNestedInput
    hardwares?: HardwareUpdateManyWithoutUserNestedInput
    hardwareDocuments?: HardwareDocumentUpdateManyWithoutUserNestedInput
    hardwareComments?: HardwareCommentUpdateManyWithoutUserNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutUserNestedInput
    hardware_hardware?: Hardware_HardwareUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    articles?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    articleDocuments?: ArticleDocumentUncheckedUpdateManyWithoutUserNestedInput
    articleComments?: ArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    hardwares?: HardwareUncheckedUpdateManyWithoutUserNestedInput
    hardwareDocuments?: HardwareDocumentUncheckedUpdateManyWithoutUserNestedInput
    hardwareComments?: HardwareCommentUncheckedUpdateManyWithoutUserNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutUserNestedInput
    hardware_hardware?: Hardware_HardwareUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    roleId: number
  }

  export type UserUpdateManyMutationInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type ArticleCreateInput = {
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    user: UserCreateNestedOneWithoutArticlesInput
    articleType: ArticleTypeCreateNestedOneWithoutArticlesInput
    article?: ArticleCreateNestedOneWithoutArticlesInput
    articles?: ArticleCreateNestedManyWithoutArticleInput
    articleDocuments?: ArticleDocumentCreateNestedManyWithoutArticleInput
    articleComments?: ArticleCommentCreateNestedManyWithoutArticleInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateInput = {
    id?: number
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    userId: number
    articleTypeId: number
    articleId?: number | null
    articles?: ArticleUncheckedCreateNestedManyWithoutArticleInput
    articleDocuments?: ArticleDocumentUncheckedCreateNestedManyWithoutArticleInput
    articleComments?: ArticleCommentUncheckedCreateNestedManyWithoutArticleInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutArticlesNestedInput
    articleType?: ArticleTypeUpdateOneRequiredWithoutArticlesNestedInput
    article?: ArticleUpdateOneWithoutArticlesNestedInput
    articles?: ArticleUpdateManyWithoutArticleNestedInput
    articleDocuments?: ArticleDocumentUpdateManyWithoutArticleNestedInput
    articleComments?: ArticleCommentUpdateManyWithoutArticleNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    articleTypeId?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    articles?: ArticleUncheckedUpdateManyWithoutArticleNestedInput
    articleDocuments?: ArticleDocumentUncheckedUpdateManyWithoutArticleNestedInput
    articleComments?: ArticleCommentUncheckedUpdateManyWithoutArticleNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleCreateManyInput = {
    id?: number
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    userId: number
    articleTypeId: number
    articleId?: number | null
  }

  export type ArticleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArticleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    articleTypeId?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HardwareCreateInput = {
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    user: UserCreateNestedOneWithoutHardwaresInput
    hardwareType: HardwareTypeCreateNestedOneWithoutHardwaresInput
    hardwareDocuments?: HardwareDocumentCreateNestedManyWithoutHardwareInput
    hardwareComments?: HardwareCommentCreateNestedManyWithoutHardwareInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutHardwareInput
    firstHardwareOf?: Hardware_HardwareCreateNestedManyWithoutFirstHardwareInput
    secondHardwares?: Hardware_HardwareCreateNestedManyWithoutSecondHardwareInput
  }

  export type HardwareUncheckedCreateInput = {
    id?: number
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    userId: number
    hardwareTypeId: number
    hardwareDocuments?: HardwareDocumentUncheckedCreateNestedManyWithoutHardwareInput
    hardwareComments?: HardwareCommentUncheckedCreateNestedManyWithoutHardwareInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutHardwareInput
    firstHardwareOf?: Hardware_HardwareUncheckedCreateNestedManyWithoutFirstHardwareInput
    secondHardwares?: Hardware_HardwareUncheckedCreateNestedManyWithoutSecondHardwareInput
  }

  export type HardwareUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
    user?: UserUpdateOneRequiredWithoutHardwaresNestedInput
    hardwareType?: HardwareTypeUpdateOneRequiredWithoutHardwaresNestedInput
    hardwareDocuments?: HardwareDocumentUpdateManyWithoutHardwareNestedInput
    hardwareComments?: HardwareCommentUpdateManyWithoutHardwareNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutHardwareNestedInput
    firstHardwareOf?: Hardware_HardwareUpdateManyWithoutFirstHardwareNestedInput
    secondHardwares?: Hardware_HardwareUpdateManyWithoutSecondHardwareNestedInput
  }

  export type HardwareUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
    userId?: IntFieldUpdateOperationsInput | number
    hardwareTypeId?: IntFieldUpdateOperationsInput | number
    hardwareDocuments?: HardwareDocumentUncheckedUpdateManyWithoutHardwareNestedInput
    hardwareComments?: HardwareCommentUncheckedUpdateManyWithoutHardwareNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutHardwareNestedInput
    firstHardwareOf?: Hardware_HardwareUncheckedUpdateManyWithoutFirstHardwareNestedInput
    secondHardwares?: Hardware_HardwareUncheckedUpdateManyWithoutSecondHardwareNestedInput
  }

  export type HardwareCreateManyInput = {
    id?: number
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    userId: number
    hardwareTypeId: number
  }

  export type HardwareUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
  }

  export type HardwareUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
    userId?: IntFieldUpdateOperationsInput | number
    hardwareTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type ArticleDocumentCreateInput = {
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    documentType: DocumentTypeCreateNestedOneWithoutArticleDocumentsInput
    user: UserCreateNestedOneWithoutArticleDocumentsInput
    article: ArticleCreateNestedOneWithoutArticleDocumentsInput
  }

  export type ArticleDocumentUncheckedCreateInput = {
    id?: number
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    documentTypeId: number
    userId: number
    articleId: number
  }

  export type ArticleDocumentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentType?: DocumentTypeUpdateOneRequiredWithoutArticleDocumentsNestedInput
    user?: UserUpdateOneRequiredWithoutArticleDocumentsNestedInput
    article?: ArticleUpdateOneRequiredWithoutArticleDocumentsNestedInput
  }

  export type ArticleDocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentTypeId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
  }

  export type ArticleDocumentCreateManyInput = {
    id?: number
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    documentTypeId: number
    userId: number
    articleId: number
  }

  export type ArticleDocumentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleDocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentTypeId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
  }

  export type ArticleCommentCreateInput = {
    content: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    user: UserCreateNestedOneWithoutArticleCommentsInput
    article: ArticleCreateNestedOneWithoutArticleCommentsInput
  }

  export type ArticleCommentUncheckedCreateInput = {
    id?: number
    content: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    userId: number
    articleId: number
  }

  export type ArticleCommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutArticleCommentsNestedInput
    article?: ArticleUpdateOneRequiredWithoutArticleCommentsNestedInput
  }

  export type ArticleCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
  }

  export type ArticleCommentCreateManyInput = {
    id?: number
    content: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    userId: number
    articleId: number
  }

  export type ArticleCommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArticleCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
  }

  export type HardwareDocumentCreateInput = {
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    documentType: DocumentTypeCreateNestedOneWithoutHardwareDocumentInput
    user: UserCreateNestedOneWithoutHardwareDocumentsInput
    hardware: HardwareCreateNestedOneWithoutHardwareDocumentsInput
  }

  export type HardwareDocumentUncheckedCreateInput = {
    id?: number
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    documentTypeId: number
    userId: number
    hardwareId: number
  }

  export type HardwareDocumentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentType?: DocumentTypeUpdateOneRequiredWithoutHardwareDocumentNestedInput
    user?: UserUpdateOneRequiredWithoutHardwareDocumentsNestedInput
    hardware?: HardwareUpdateOneRequiredWithoutHardwareDocumentsNestedInput
  }

  export type HardwareDocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentTypeId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    hardwareId?: IntFieldUpdateOperationsInput | number
  }

  export type HardwareDocumentCreateManyInput = {
    id?: number
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    documentTypeId: number
    userId: number
    hardwareId: number
  }

  export type HardwareDocumentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HardwareDocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentTypeId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    hardwareId?: IntFieldUpdateOperationsInput | number
  }

  export type HardwareCommentCreateInput = {
    content: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    user: UserCreateNestedOneWithoutHardwareCommentsInput
    hardware: HardwareCreateNestedOneWithoutHardwareCommentsInput
  }

  export type HardwareCommentUncheckedCreateInput = {
    id?: number
    content: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    userId: number
    hardwareId: number
  }

  export type HardwareCommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutHardwareCommentsNestedInput
    hardware?: HardwareUpdateOneRequiredWithoutHardwareCommentsNestedInput
  }

  export type HardwareCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    hardwareId?: IntFieldUpdateOperationsInput | number
  }

  export type HardwareCommentCreateManyInput = {
    id?: number
    content: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    userId: number
    hardwareId: number
  }

  export type HardwareCommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HardwareCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    hardwareId?: IntFieldUpdateOperationsInput | number
  }

  export type Article_HardwareCreateInput = {
    assigneddAt?: Date | string
    article: ArticleCreateNestedOneWithoutArticle_hardwareInput
    hardware: HardwareCreateNestedOneWithoutArticle_hardwareInput
    user: UserCreateNestedOneWithoutArticle_hardwareInput
  }

  export type Article_HardwareUncheckedCreateInput = {
    assigneddAt?: Date | string
    articleId: number
    hardwareId: number
    userId: number
  }

  export type Article_HardwareUpdateInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: ArticleUpdateOneRequiredWithoutArticle_hardwareNestedInput
    hardware?: HardwareUpdateOneRequiredWithoutArticle_hardwareNestedInput
    user?: UserUpdateOneRequiredWithoutArticle_hardwareNestedInput
  }

  export type Article_HardwareUncheckedUpdateInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articleId?: IntFieldUpdateOperationsInput | number
    hardwareId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type Article_HardwareCreateManyInput = {
    assigneddAt?: Date | string
    articleId: number
    hardwareId: number
    userId: number
  }

  export type Article_HardwareUpdateManyMutationInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Article_HardwareUncheckedUpdateManyInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articleId?: IntFieldUpdateOperationsInput | number
    hardwareId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type Hardware_HardwareCreateInput = {
    assigneddAt?: Date | string
    firstHardware: HardwareCreateNestedOneWithoutFirstHardwareOfInput
    secondHardware: HardwareCreateNestedOneWithoutSecondHardwaresInput
    user: UserCreateNestedOneWithoutHardware_hardwareInput
  }

  export type Hardware_HardwareUncheckedCreateInput = {
    assigneddAt?: Date | string
    firstHardwareId: number
    secondHardwareId: number
    userId: number
  }

  export type Hardware_HardwareUpdateInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstHardware?: HardwareUpdateOneRequiredWithoutFirstHardwareOfNestedInput
    secondHardware?: HardwareUpdateOneRequiredWithoutSecondHardwaresNestedInput
    user?: UserUpdateOneRequiredWithoutHardware_hardwareNestedInput
  }

  export type Hardware_HardwareUncheckedUpdateInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstHardwareId?: IntFieldUpdateOperationsInput | number
    secondHardwareId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type Hardware_HardwareCreateManyInput = {
    assigneddAt?: Date | string
    firstHardwareId: number
    secondHardwareId: number
    userId: number
  }

  export type Hardware_HardwareUpdateManyMutationInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Hardware_HardwareUncheckedUpdateManyInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstHardwareId?: IntFieldUpdateOperationsInput | number
    secondHardwareId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type ArticleListRelationFilter = {
    every?: ArticleWhereInput
    some?: ArticleWhereInput
    none?: ArticleWhereInput
  }

  export type ArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArticleTypeCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type ArticleTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ArticleTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type ArticleTypeMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type ArticleTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HardwareListRelationFilter = {
    every?: HardwareWhereInput
    some?: HardwareWhereInput
    none?: HardwareWhereInput
  }

  export type HardwareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HardwareTypeCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type HardwareTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HardwareTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type HardwareTypeMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type HardwareTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ArticleDocumentListRelationFilter = {
    every?: ArticleDocumentWhereInput
    some?: ArticleDocumentWhereInput
    none?: ArticleDocumentWhereInput
  }

  export type HardwareDocumentListRelationFilter = {
    every?: HardwareDocumentWhereInput
    some?: HardwareDocumentWhereInput
    none?: HardwareDocumentWhereInput
  }

  export type ArticleDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HardwareDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentTypeCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type DocumentTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DocumentTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type DocumentTypeMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type DocumentTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type ArticleCommentListRelationFilter = {
    every?: ArticleCommentWhereInput
    some?: ArticleCommentWhereInput
    none?: ArticleCommentWhereInput
  }

  export type HardwareCommentListRelationFilter = {
    every?: HardwareCommentWhereInput
    some?: HardwareCommentWhereInput
    none?: HardwareCommentWhereInput
  }

  export type Article_HardwareListRelationFilter = {
    every?: Article_HardwareWhereInput
    some?: Article_HardwareWhereInput
    none?: Article_HardwareWhereInput
  }

  export type Hardware_HardwareListRelationFilter = {
    every?: Hardware_HardwareWhereInput
    some?: Hardware_HardwareWhereInput
    none?: Hardware_HardwareWhereInput
  }

  export type ArticleCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HardwareCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Article_HardwareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Hardware_HardwareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    roleId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    roleId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    roleId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ArticleTypeRelationFilter = {
    is?: ArticleTypeWhereInput
    isNot?: ArticleTypeWhereInput
  }

  export type ArticleRelationFilter = {
    is?: ArticleWhereInput | null
    isNot?: ArticleWhereInput | null
  }

  export type ArticleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subDescription?: SortOrder
    description?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    userId?: SortOrder
    articleTypeId?: SortOrder
    articleId?: SortOrder
  }

  export type ArticleAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    articleTypeId?: SortOrder
    articleId?: SortOrder
  }

  export type ArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subDescription?: SortOrder
    description?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    userId?: SortOrder
    articleTypeId?: SortOrder
    articleId?: SortOrder
  }

  export type ArticleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subDescription?: SortOrder
    description?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    userId?: SortOrder
    articleTypeId?: SortOrder
    articleId?: SortOrder
  }

  export type ArticleSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    articleTypeId?: SortOrder
    articleId?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type HardwareTypeRelationFilter = {
    is?: HardwareTypeWhereInput
    isNot?: HardwareTypeWhereInput
  }

  export type HardwareCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    subDescription?: SortOrder
    description?: SortOrder
    isDiy?: SortOrder
    creationDate?: SortOrder
    discontinuationDate?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    commercialLinks?: SortOrder
    userId?: SortOrder
    hardwareTypeId?: SortOrder
  }

  export type HardwareAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    hardwareTypeId?: SortOrder
  }

  export type HardwareMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    subDescription?: SortOrder
    description?: SortOrder
    isDiy?: SortOrder
    creationDate?: SortOrder
    discontinuationDate?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    userId?: SortOrder
    hardwareTypeId?: SortOrder
  }

  export type HardwareMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    subDescription?: SortOrder
    description?: SortOrder
    isDiy?: SortOrder
    creationDate?: SortOrder
    discontinuationDate?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    userId?: SortOrder
    hardwareTypeId?: SortOrder
  }

  export type HardwareSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    hardwareTypeId?: SortOrder
  }

  export type BytesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesFilter | Buffer
  }

  export type DocumentTypeRelationFilter = {
    is?: DocumentTypeWhereInput
    isNot?: DocumentTypeWhereInput
  }

  export type ArticleDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    mimetype?: SortOrder
    buffer?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    documentTypeId?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
  }

  export type ArticleDocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    documentTypeId?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
  }

  export type ArticleDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    mimetype?: SortOrder
    buffer?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    documentTypeId?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
  }

  export type ArticleDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    mimetype?: SortOrder
    buffer?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    documentTypeId?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
  }

  export type ArticleDocumentSumOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    documentTypeId?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
  }

  export type BytesWithAggregatesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesWithAggregatesFilter | Buffer
    _count?: NestedIntFilter
    _min?: NestedBytesFilter
    _max?: NestedBytesFilter
  }

  export type ArticleCommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
  }

  export type ArticleCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
  }

  export type ArticleCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
  }

  export type ArticleCommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
  }

  export type ArticleCommentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
  }

  export type HardwareRelationFilter = {
    is?: HardwareWhereInput
    isNot?: HardwareWhereInput
  }

  export type HardwareDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    mimetype?: SortOrder
    buffer?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    documentTypeId?: SortOrder
    userId?: SortOrder
    hardwareId?: SortOrder
  }

  export type HardwareDocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    documentTypeId?: SortOrder
    userId?: SortOrder
    hardwareId?: SortOrder
  }

  export type HardwareDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    mimetype?: SortOrder
    buffer?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    documentTypeId?: SortOrder
    userId?: SortOrder
    hardwareId?: SortOrder
  }

  export type HardwareDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    mimetype?: SortOrder
    buffer?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    documentTypeId?: SortOrder
    userId?: SortOrder
    hardwareId?: SortOrder
  }

  export type HardwareDocumentSumOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    documentTypeId?: SortOrder
    userId?: SortOrder
    hardwareId?: SortOrder
  }

  export type HardwareCommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    userId?: SortOrder
    hardwareId?: SortOrder
  }

  export type HardwareCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    hardwareId?: SortOrder
  }

  export type HardwareCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    userId?: SortOrder
    hardwareId?: SortOrder
  }

  export type HardwareCommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    modifiedAt?: SortOrder
    userId?: SortOrder
    hardwareId?: SortOrder
  }

  export type HardwareCommentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    hardwareId?: SortOrder
  }

  export type Article_HardwareArticleHardwareIdCompoundUniqueInput = {
    articleId: number
    hardwareId: number
  }

  export type Article_HardwareCountOrderByAggregateInput = {
    assigneddAt?: SortOrder
    articleId?: SortOrder
    hardwareId?: SortOrder
    userId?: SortOrder
  }

  export type Article_HardwareAvgOrderByAggregateInput = {
    articleId?: SortOrder
    hardwareId?: SortOrder
    userId?: SortOrder
  }

  export type Article_HardwareMaxOrderByAggregateInput = {
    assigneddAt?: SortOrder
    articleId?: SortOrder
    hardwareId?: SortOrder
    userId?: SortOrder
  }

  export type Article_HardwareMinOrderByAggregateInput = {
    assigneddAt?: SortOrder
    articleId?: SortOrder
    hardwareId?: SortOrder
    userId?: SortOrder
  }

  export type Article_HardwareSumOrderByAggregateInput = {
    articleId?: SortOrder
    hardwareId?: SortOrder
    userId?: SortOrder
  }

  export type Hardware_HardwareHardwareRelationIdCompoundUniqueInput = {
    firstHardwareId: number
    secondHardwareId: number
  }

  export type Hardware_HardwareCountOrderByAggregateInput = {
    assigneddAt?: SortOrder
    firstHardwareId?: SortOrder
    secondHardwareId?: SortOrder
    userId?: SortOrder
  }

  export type Hardware_HardwareAvgOrderByAggregateInput = {
    firstHardwareId?: SortOrder
    secondHardwareId?: SortOrder
    userId?: SortOrder
  }

  export type Hardware_HardwareMaxOrderByAggregateInput = {
    assigneddAt?: SortOrder
    firstHardwareId?: SortOrder
    secondHardwareId?: SortOrder
    userId?: SortOrder
  }

  export type Hardware_HardwareMinOrderByAggregateInput = {
    assigneddAt?: SortOrder
    firstHardwareId?: SortOrder
    secondHardwareId?: SortOrder
    userId?: SortOrder
  }

  export type Hardware_HardwareSumOrderByAggregateInput = {
    firstHardwareId?: SortOrder
    secondHardwareId?: SortOrder
    userId?: SortOrder
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type ArticleCreateNestedManyWithoutArticleTypeInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutArticleTypeInput>, Enumerable<ArticleUncheckedCreateWithoutArticleTypeInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutArticleTypeInput>
    createMany?: ArticleCreateManyArticleTypeInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type ArticleUncheckedCreateNestedManyWithoutArticleTypeInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutArticleTypeInput>, Enumerable<ArticleUncheckedCreateWithoutArticleTypeInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutArticleTypeInput>
    createMany?: ArticleCreateManyArticleTypeInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type ArticleUpdateManyWithoutArticleTypeNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutArticleTypeInput>, Enumerable<ArticleUncheckedCreateWithoutArticleTypeInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutArticleTypeInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutArticleTypeInput>
    createMany?: ArticleCreateManyArticleTypeInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutArticleTypeInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutArticleTypeInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type ArticleUncheckedUpdateManyWithoutArticleTypeNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutArticleTypeInput>, Enumerable<ArticleUncheckedCreateWithoutArticleTypeInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutArticleTypeInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutArticleTypeInput>
    createMany?: ArticleCreateManyArticleTypeInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutArticleTypeInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutArticleTypeInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type HardwareCreateNestedManyWithoutHardwareTypeInput = {
    create?: XOR<Enumerable<HardwareCreateWithoutHardwareTypeInput>, Enumerable<HardwareUncheckedCreateWithoutHardwareTypeInput>>
    connectOrCreate?: Enumerable<HardwareCreateOrConnectWithoutHardwareTypeInput>
    createMany?: HardwareCreateManyHardwareTypeInputEnvelope
    connect?: Enumerable<HardwareWhereUniqueInput>
  }

  export type HardwareUncheckedCreateNestedManyWithoutHardwareTypeInput = {
    create?: XOR<Enumerable<HardwareCreateWithoutHardwareTypeInput>, Enumerable<HardwareUncheckedCreateWithoutHardwareTypeInput>>
    connectOrCreate?: Enumerable<HardwareCreateOrConnectWithoutHardwareTypeInput>
    createMany?: HardwareCreateManyHardwareTypeInputEnvelope
    connect?: Enumerable<HardwareWhereUniqueInput>
  }

  export type HardwareUpdateManyWithoutHardwareTypeNestedInput = {
    create?: XOR<Enumerable<HardwareCreateWithoutHardwareTypeInput>, Enumerable<HardwareUncheckedCreateWithoutHardwareTypeInput>>
    connectOrCreate?: Enumerable<HardwareCreateOrConnectWithoutHardwareTypeInput>
    upsert?: Enumerable<HardwareUpsertWithWhereUniqueWithoutHardwareTypeInput>
    createMany?: HardwareCreateManyHardwareTypeInputEnvelope
    set?: Enumerable<HardwareWhereUniqueInput>
    disconnect?: Enumerable<HardwareWhereUniqueInput>
    delete?: Enumerable<HardwareWhereUniqueInput>
    connect?: Enumerable<HardwareWhereUniqueInput>
    update?: Enumerable<HardwareUpdateWithWhereUniqueWithoutHardwareTypeInput>
    updateMany?: Enumerable<HardwareUpdateManyWithWhereWithoutHardwareTypeInput>
    deleteMany?: Enumerable<HardwareScalarWhereInput>
  }

  export type HardwareUncheckedUpdateManyWithoutHardwareTypeNestedInput = {
    create?: XOR<Enumerable<HardwareCreateWithoutHardwareTypeInput>, Enumerable<HardwareUncheckedCreateWithoutHardwareTypeInput>>
    connectOrCreate?: Enumerable<HardwareCreateOrConnectWithoutHardwareTypeInput>
    upsert?: Enumerable<HardwareUpsertWithWhereUniqueWithoutHardwareTypeInput>
    createMany?: HardwareCreateManyHardwareTypeInputEnvelope
    set?: Enumerable<HardwareWhereUniqueInput>
    disconnect?: Enumerable<HardwareWhereUniqueInput>
    delete?: Enumerable<HardwareWhereUniqueInput>
    connect?: Enumerable<HardwareWhereUniqueInput>
    update?: Enumerable<HardwareUpdateWithWhereUniqueWithoutHardwareTypeInput>
    updateMany?: Enumerable<HardwareUpdateManyWithWhereWithoutHardwareTypeInput>
    deleteMany?: Enumerable<HardwareScalarWhereInput>
  }

  export type ArticleDocumentCreateNestedManyWithoutDocumentTypeInput = {
    create?: XOR<Enumerable<ArticleDocumentCreateWithoutDocumentTypeInput>, Enumerable<ArticleDocumentUncheckedCreateWithoutDocumentTypeInput>>
    connectOrCreate?: Enumerable<ArticleDocumentCreateOrConnectWithoutDocumentTypeInput>
    createMany?: ArticleDocumentCreateManyDocumentTypeInputEnvelope
    connect?: Enumerable<ArticleDocumentWhereUniqueInput>
  }

  export type HardwareDocumentCreateNestedManyWithoutDocumentTypeInput = {
    create?: XOR<Enumerable<HardwareDocumentCreateWithoutDocumentTypeInput>, Enumerable<HardwareDocumentUncheckedCreateWithoutDocumentTypeInput>>
    connectOrCreate?: Enumerable<HardwareDocumentCreateOrConnectWithoutDocumentTypeInput>
    createMany?: HardwareDocumentCreateManyDocumentTypeInputEnvelope
    connect?: Enumerable<HardwareDocumentWhereUniqueInput>
  }

  export type ArticleDocumentUncheckedCreateNestedManyWithoutDocumentTypeInput = {
    create?: XOR<Enumerable<ArticleDocumentCreateWithoutDocumentTypeInput>, Enumerable<ArticleDocumentUncheckedCreateWithoutDocumentTypeInput>>
    connectOrCreate?: Enumerable<ArticleDocumentCreateOrConnectWithoutDocumentTypeInput>
    createMany?: ArticleDocumentCreateManyDocumentTypeInputEnvelope
    connect?: Enumerable<ArticleDocumentWhereUniqueInput>
  }

  export type HardwareDocumentUncheckedCreateNestedManyWithoutDocumentTypeInput = {
    create?: XOR<Enumerable<HardwareDocumentCreateWithoutDocumentTypeInput>, Enumerable<HardwareDocumentUncheckedCreateWithoutDocumentTypeInput>>
    connectOrCreate?: Enumerable<HardwareDocumentCreateOrConnectWithoutDocumentTypeInput>
    createMany?: HardwareDocumentCreateManyDocumentTypeInputEnvelope
    connect?: Enumerable<HardwareDocumentWhereUniqueInput>
  }

  export type ArticleDocumentUpdateManyWithoutDocumentTypeNestedInput = {
    create?: XOR<Enumerable<ArticleDocumentCreateWithoutDocumentTypeInput>, Enumerable<ArticleDocumentUncheckedCreateWithoutDocumentTypeInput>>
    connectOrCreate?: Enumerable<ArticleDocumentCreateOrConnectWithoutDocumentTypeInput>
    upsert?: Enumerable<ArticleDocumentUpsertWithWhereUniqueWithoutDocumentTypeInput>
    createMany?: ArticleDocumentCreateManyDocumentTypeInputEnvelope
    set?: Enumerable<ArticleDocumentWhereUniqueInput>
    disconnect?: Enumerable<ArticleDocumentWhereUniqueInput>
    delete?: Enumerable<ArticleDocumentWhereUniqueInput>
    connect?: Enumerable<ArticleDocumentWhereUniqueInput>
    update?: Enumerable<ArticleDocumentUpdateWithWhereUniqueWithoutDocumentTypeInput>
    updateMany?: Enumerable<ArticleDocumentUpdateManyWithWhereWithoutDocumentTypeInput>
    deleteMany?: Enumerable<ArticleDocumentScalarWhereInput>
  }

  export type HardwareDocumentUpdateManyWithoutDocumentTypeNestedInput = {
    create?: XOR<Enumerable<HardwareDocumentCreateWithoutDocumentTypeInput>, Enumerable<HardwareDocumentUncheckedCreateWithoutDocumentTypeInput>>
    connectOrCreate?: Enumerable<HardwareDocumentCreateOrConnectWithoutDocumentTypeInput>
    upsert?: Enumerable<HardwareDocumentUpsertWithWhereUniqueWithoutDocumentTypeInput>
    createMany?: HardwareDocumentCreateManyDocumentTypeInputEnvelope
    set?: Enumerable<HardwareDocumentWhereUniqueInput>
    disconnect?: Enumerable<HardwareDocumentWhereUniqueInput>
    delete?: Enumerable<HardwareDocumentWhereUniqueInput>
    connect?: Enumerable<HardwareDocumentWhereUniqueInput>
    update?: Enumerable<HardwareDocumentUpdateWithWhereUniqueWithoutDocumentTypeInput>
    updateMany?: Enumerable<HardwareDocumentUpdateManyWithWhereWithoutDocumentTypeInput>
    deleteMany?: Enumerable<HardwareDocumentScalarWhereInput>
  }

  export type ArticleDocumentUncheckedUpdateManyWithoutDocumentTypeNestedInput = {
    create?: XOR<Enumerable<ArticleDocumentCreateWithoutDocumentTypeInput>, Enumerable<ArticleDocumentUncheckedCreateWithoutDocumentTypeInput>>
    connectOrCreate?: Enumerable<ArticleDocumentCreateOrConnectWithoutDocumentTypeInput>
    upsert?: Enumerable<ArticleDocumentUpsertWithWhereUniqueWithoutDocumentTypeInput>
    createMany?: ArticleDocumentCreateManyDocumentTypeInputEnvelope
    set?: Enumerable<ArticleDocumentWhereUniqueInput>
    disconnect?: Enumerable<ArticleDocumentWhereUniqueInput>
    delete?: Enumerable<ArticleDocumentWhereUniqueInput>
    connect?: Enumerable<ArticleDocumentWhereUniqueInput>
    update?: Enumerable<ArticleDocumentUpdateWithWhereUniqueWithoutDocumentTypeInput>
    updateMany?: Enumerable<ArticleDocumentUpdateManyWithWhereWithoutDocumentTypeInput>
    deleteMany?: Enumerable<ArticleDocumentScalarWhereInput>
  }

  export type HardwareDocumentUncheckedUpdateManyWithoutDocumentTypeNestedInput = {
    create?: XOR<Enumerable<HardwareDocumentCreateWithoutDocumentTypeInput>, Enumerable<HardwareDocumentUncheckedCreateWithoutDocumentTypeInput>>
    connectOrCreate?: Enumerable<HardwareDocumentCreateOrConnectWithoutDocumentTypeInput>
    upsert?: Enumerable<HardwareDocumentUpsertWithWhereUniqueWithoutDocumentTypeInput>
    createMany?: HardwareDocumentCreateManyDocumentTypeInputEnvelope
    set?: Enumerable<HardwareDocumentWhereUniqueInput>
    disconnect?: Enumerable<HardwareDocumentWhereUniqueInput>
    delete?: Enumerable<HardwareDocumentWhereUniqueInput>
    connect?: Enumerable<HardwareDocumentWhereUniqueInput>
    update?: Enumerable<HardwareDocumentUpdateWithWhereUniqueWithoutDocumentTypeInput>
    updateMany?: Enumerable<HardwareDocumentUpdateManyWithWhereWithoutDocumentTypeInput>
    deleteMany?: Enumerable<HardwareDocumentScalarWhereInput>
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type ArticleCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutUserInput>, Enumerable<ArticleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutUserInput>
    createMany?: ArticleCreateManyUserInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type ArticleDocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ArticleDocumentCreateWithoutUserInput>, Enumerable<ArticleDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ArticleDocumentCreateOrConnectWithoutUserInput>
    createMany?: ArticleDocumentCreateManyUserInputEnvelope
    connect?: Enumerable<ArticleDocumentWhereUniqueInput>
  }

  export type ArticleCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ArticleCommentCreateWithoutUserInput>, Enumerable<ArticleCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ArticleCommentCreateOrConnectWithoutUserInput>
    createMany?: ArticleCommentCreateManyUserInputEnvelope
    connect?: Enumerable<ArticleCommentWhereUniqueInput>
  }

  export type HardwareCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<HardwareCreateWithoutUserInput>, Enumerable<HardwareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HardwareCreateOrConnectWithoutUserInput>
    createMany?: HardwareCreateManyUserInputEnvelope
    connect?: Enumerable<HardwareWhereUniqueInput>
  }

  export type HardwareDocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<HardwareDocumentCreateWithoutUserInput>, Enumerable<HardwareDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HardwareDocumentCreateOrConnectWithoutUserInput>
    createMany?: HardwareDocumentCreateManyUserInputEnvelope
    connect?: Enumerable<HardwareDocumentWhereUniqueInput>
  }

  export type HardwareCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<HardwareCommentCreateWithoutUserInput>, Enumerable<HardwareCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HardwareCommentCreateOrConnectWithoutUserInput>
    createMany?: HardwareCommentCreateManyUserInputEnvelope
    connect?: Enumerable<HardwareCommentWhereUniqueInput>
  }

  export type Article_HardwareCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<Article_HardwareCreateWithoutUserInput>, Enumerable<Article_HardwareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Article_HardwareCreateOrConnectWithoutUserInput>
    createMany?: Article_HardwareCreateManyUserInputEnvelope
    connect?: Enumerable<Article_HardwareWhereUniqueInput>
  }

  export type Hardware_HardwareCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<Hardware_HardwareCreateWithoutUserInput>, Enumerable<Hardware_HardwareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Hardware_HardwareCreateOrConnectWithoutUserInput>
    createMany?: Hardware_HardwareCreateManyUserInputEnvelope
    connect?: Enumerable<Hardware_HardwareWhereUniqueInput>
  }

  export type ArticleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutUserInput>, Enumerable<ArticleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutUserInput>
    createMany?: ArticleCreateManyUserInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type ArticleDocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ArticleDocumentCreateWithoutUserInput>, Enumerable<ArticleDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ArticleDocumentCreateOrConnectWithoutUserInput>
    createMany?: ArticleDocumentCreateManyUserInputEnvelope
    connect?: Enumerable<ArticleDocumentWhereUniqueInput>
  }

  export type ArticleCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ArticleCommentCreateWithoutUserInput>, Enumerable<ArticleCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ArticleCommentCreateOrConnectWithoutUserInput>
    createMany?: ArticleCommentCreateManyUserInputEnvelope
    connect?: Enumerable<ArticleCommentWhereUniqueInput>
  }

  export type HardwareUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<HardwareCreateWithoutUserInput>, Enumerable<HardwareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HardwareCreateOrConnectWithoutUserInput>
    createMany?: HardwareCreateManyUserInputEnvelope
    connect?: Enumerable<HardwareWhereUniqueInput>
  }

  export type HardwareDocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<HardwareDocumentCreateWithoutUserInput>, Enumerable<HardwareDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HardwareDocumentCreateOrConnectWithoutUserInput>
    createMany?: HardwareDocumentCreateManyUserInputEnvelope
    connect?: Enumerable<HardwareDocumentWhereUniqueInput>
  }

  export type HardwareCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<HardwareCommentCreateWithoutUserInput>, Enumerable<HardwareCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HardwareCommentCreateOrConnectWithoutUserInput>
    createMany?: HardwareCommentCreateManyUserInputEnvelope
    connect?: Enumerable<HardwareCommentWhereUniqueInput>
  }

  export type Article_HardwareUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<Article_HardwareCreateWithoutUserInput>, Enumerable<Article_HardwareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Article_HardwareCreateOrConnectWithoutUserInput>
    createMany?: Article_HardwareCreateManyUserInputEnvelope
    connect?: Enumerable<Article_HardwareWhereUniqueInput>
  }

  export type Hardware_HardwareUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<Hardware_HardwareCreateWithoutUserInput>, Enumerable<Hardware_HardwareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Hardware_HardwareCreateOrConnectWithoutUserInput>
    createMany?: Hardware_HardwareCreateManyUserInputEnvelope
    connect?: Enumerable<Hardware_HardwareWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type ArticleUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutUserInput>, Enumerable<ArticleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ArticleCreateManyUserInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type ArticleDocumentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ArticleDocumentCreateWithoutUserInput>, Enumerable<ArticleDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ArticleDocumentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ArticleDocumentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ArticleDocumentCreateManyUserInputEnvelope
    set?: Enumerable<ArticleDocumentWhereUniqueInput>
    disconnect?: Enumerable<ArticleDocumentWhereUniqueInput>
    delete?: Enumerable<ArticleDocumentWhereUniqueInput>
    connect?: Enumerable<ArticleDocumentWhereUniqueInput>
    update?: Enumerable<ArticleDocumentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ArticleDocumentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ArticleDocumentScalarWhereInput>
  }

  export type ArticleCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ArticleCommentCreateWithoutUserInput>, Enumerable<ArticleCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ArticleCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ArticleCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ArticleCommentCreateManyUserInputEnvelope
    set?: Enumerable<ArticleCommentWhereUniqueInput>
    disconnect?: Enumerable<ArticleCommentWhereUniqueInput>
    delete?: Enumerable<ArticleCommentWhereUniqueInput>
    connect?: Enumerable<ArticleCommentWhereUniqueInput>
    update?: Enumerable<ArticleCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ArticleCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ArticleCommentScalarWhereInput>
  }

  export type HardwareUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<HardwareCreateWithoutUserInput>, Enumerable<HardwareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HardwareCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<HardwareUpsertWithWhereUniqueWithoutUserInput>
    createMany?: HardwareCreateManyUserInputEnvelope
    set?: Enumerable<HardwareWhereUniqueInput>
    disconnect?: Enumerable<HardwareWhereUniqueInput>
    delete?: Enumerable<HardwareWhereUniqueInput>
    connect?: Enumerable<HardwareWhereUniqueInput>
    update?: Enumerable<HardwareUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<HardwareUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<HardwareScalarWhereInput>
  }

  export type HardwareDocumentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<HardwareDocumentCreateWithoutUserInput>, Enumerable<HardwareDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HardwareDocumentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<HardwareDocumentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: HardwareDocumentCreateManyUserInputEnvelope
    set?: Enumerable<HardwareDocumentWhereUniqueInput>
    disconnect?: Enumerable<HardwareDocumentWhereUniqueInput>
    delete?: Enumerable<HardwareDocumentWhereUniqueInput>
    connect?: Enumerable<HardwareDocumentWhereUniqueInput>
    update?: Enumerable<HardwareDocumentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<HardwareDocumentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<HardwareDocumentScalarWhereInput>
  }

  export type HardwareCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<HardwareCommentCreateWithoutUserInput>, Enumerable<HardwareCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HardwareCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<HardwareCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: HardwareCommentCreateManyUserInputEnvelope
    set?: Enumerable<HardwareCommentWhereUniqueInput>
    disconnect?: Enumerable<HardwareCommentWhereUniqueInput>
    delete?: Enumerable<HardwareCommentWhereUniqueInput>
    connect?: Enumerable<HardwareCommentWhereUniqueInput>
    update?: Enumerable<HardwareCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<HardwareCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<HardwareCommentScalarWhereInput>
  }

  export type Article_HardwareUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<Article_HardwareCreateWithoutUserInput>, Enumerable<Article_HardwareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Article_HardwareCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<Article_HardwareUpsertWithWhereUniqueWithoutUserInput>
    createMany?: Article_HardwareCreateManyUserInputEnvelope
    set?: Enumerable<Article_HardwareWhereUniqueInput>
    disconnect?: Enumerable<Article_HardwareWhereUniqueInput>
    delete?: Enumerable<Article_HardwareWhereUniqueInput>
    connect?: Enumerable<Article_HardwareWhereUniqueInput>
    update?: Enumerable<Article_HardwareUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<Article_HardwareUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<Article_HardwareScalarWhereInput>
  }

  export type Hardware_HardwareUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<Hardware_HardwareCreateWithoutUserInput>, Enumerable<Hardware_HardwareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Hardware_HardwareCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<Hardware_HardwareUpsertWithWhereUniqueWithoutUserInput>
    createMany?: Hardware_HardwareCreateManyUserInputEnvelope
    set?: Enumerable<Hardware_HardwareWhereUniqueInput>
    disconnect?: Enumerable<Hardware_HardwareWhereUniqueInput>
    delete?: Enumerable<Hardware_HardwareWhereUniqueInput>
    connect?: Enumerable<Hardware_HardwareWhereUniqueInput>
    update?: Enumerable<Hardware_HardwareUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<Hardware_HardwareUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<Hardware_HardwareScalarWhereInput>
  }

  export type ArticleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutUserInput>, Enumerable<ArticleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ArticleCreateManyUserInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type ArticleDocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ArticleDocumentCreateWithoutUserInput>, Enumerable<ArticleDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ArticleDocumentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ArticleDocumentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ArticleDocumentCreateManyUserInputEnvelope
    set?: Enumerable<ArticleDocumentWhereUniqueInput>
    disconnect?: Enumerable<ArticleDocumentWhereUniqueInput>
    delete?: Enumerable<ArticleDocumentWhereUniqueInput>
    connect?: Enumerable<ArticleDocumentWhereUniqueInput>
    update?: Enumerable<ArticleDocumentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ArticleDocumentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ArticleDocumentScalarWhereInput>
  }

  export type ArticleCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ArticleCommentCreateWithoutUserInput>, Enumerable<ArticleCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ArticleCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ArticleCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ArticleCommentCreateManyUserInputEnvelope
    set?: Enumerable<ArticleCommentWhereUniqueInput>
    disconnect?: Enumerable<ArticleCommentWhereUniqueInput>
    delete?: Enumerable<ArticleCommentWhereUniqueInput>
    connect?: Enumerable<ArticleCommentWhereUniqueInput>
    update?: Enumerable<ArticleCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ArticleCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ArticleCommentScalarWhereInput>
  }

  export type HardwareUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<HardwareCreateWithoutUserInput>, Enumerable<HardwareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HardwareCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<HardwareUpsertWithWhereUniqueWithoutUserInput>
    createMany?: HardwareCreateManyUserInputEnvelope
    set?: Enumerable<HardwareWhereUniqueInput>
    disconnect?: Enumerable<HardwareWhereUniqueInput>
    delete?: Enumerable<HardwareWhereUniqueInput>
    connect?: Enumerable<HardwareWhereUniqueInput>
    update?: Enumerable<HardwareUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<HardwareUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<HardwareScalarWhereInput>
  }

  export type HardwareDocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<HardwareDocumentCreateWithoutUserInput>, Enumerable<HardwareDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HardwareDocumentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<HardwareDocumentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: HardwareDocumentCreateManyUserInputEnvelope
    set?: Enumerable<HardwareDocumentWhereUniqueInput>
    disconnect?: Enumerable<HardwareDocumentWhereUniqueInput>
    delete?: Enumerable<HardwareDocumentWhereUniqueInput>
    connect?: Enumerable<HardwareDocumentWhereUniqueInput>
    update?: Enumerable<HardwareDocumentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<HardwareDocumentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<HardwareDocumentScalarWhereInput>
  }

  export type HardwareCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<HardwareCommentCreateWithoutUserInput>, Enumerable<HardwareCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HardwareCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<HardwareCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: HardwareCommentCreateManyUserInputEnvelope
    set?: Enumerable<HardwareCommentWhereUniqueInput>
    disconnect?: Enumerable<HardwareCommentWhereUniqueInput>
    delete?: Enumerable<HardwareCommentWhereUniqueInput>
    connect?: Enumerable<HardwareCommentWhereUniqueInput>
    update?: Enumerable<HardwareCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<HardwareCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<HardwareCommentScalarWhereInput>
  }

  export type Article_HardwareUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<Article_HardwareCreateWithoutUserInput>, Enumerable<Article_HardwareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Article_HardwareCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<Article_HardwareUpsertWithWhereUniqueWithoutUserInput>
    createMany?: Article_HardwareCreateManyUserInputEnvelope
    set?: Enumerable<Article_HardwareWhereUniqueInput>
    disconnect?: Enumerable<Article_HardwareWhereUniqueInput>
    delete?: Enumerable<Article_HardwareWhereUniqueInput>
    connect?: Enumerable<Article_HardwareWhereUniqueInput>
    update?: Enumerable<Article_HardwareUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<Article_HardwareUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<Article_HardwareScalarWhereInput>
  }

  export type Hardware_HardwareUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<Hardware_HardwareCreateWithoutUserInput>, Enumerable<Hardware_HardwareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Hardware_HardwareCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<Hardware_HardwareUpsertWithWhereUniqueWithoutUserInput>
    createMany?: Hardware_HardwareCreateManyUserInputEnvelope
    set?: Enumerable<Hardware_HardwareWhereUniqueInput>
    disconnect?: Enumerable<Hardware_HardwareWhereUniqueInput>
    delete?: Enumerable<Hardware_HardwareWhereUniqueInput>
    connect?: Enumerable<Hardware_HardwareWhereUniqueInput>
    update?: Enumerable<Hardware_HardwareUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<Hardware_HardwareUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<Hardware_HardwareScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutArticlesInput = {
    create?: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticlesInput
    connect?: UserWhereUniqueInput
  }

  export type ArticleTypeCreateNestedOneWithoutArticlesInput = {
    create?: XOR<ArticleTypeCreateWithoutArticlesInput, ArticleTypeUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: ArticleTypeCreateOrConnectWithoutArticlesInput
    connect?: ArticleTypeWhereUniqueInput
  }

  export type ArticleCreateNestedOneWithoutArticlesInput = {
    create?: XOR<ArticleCreateWithoutArticlesInput, ArticleUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutArticlesInput
    connect?: ArticleWhereUniqueInput
  }

  export type ArticleCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutArticleInput>, Enumerable<ArticleUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutArticleInput>
    createMany?: ArticleCreateManyArticleInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type ArticleDocumentCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<ArticleDocumentCreateWithoutArticleInput>, Enumerable<ArticleDocumentUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ArticleDocumentCreateOrConnectWithoutArticleInput>
    createMany?: ArticleDocumentCreateManyArticleInputEnvelope
    connect?: Enumerable<ArticleDocumentWhereUniqueInput>
  }

  export type ArticleCommentCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<ArticleCommentCreateWithoutArticleInput>, Enumerable<ArticleCommentUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ArticleCommentCreateOrConnectWithoutArticleInput>
    createMany?: ArticleCommentCreateManyArticleInputEnvelope
    connect?: Enumerable<ArticleCommentWhereUniqueInput>
  }

  export type Article_HardwareCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<Article_HardwareCreateWithoutArticleInput>, Enumerable<Article_HardwareUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<Article_HardwareCreateOrConnectWithoutArticleInput>
    createMany?: Article_HardwareCreateManyArticleInputEnvelope
    connect?: Enumerable<Article_HardwareWhereUniqueInput>
  }

  export type ArticleUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutArticleInput>, Enumerable<ArticleUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutArticleInput>
    createMany?: ArticleCreateManyArticleInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type ArticleDocumentUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<ArticleDocumentCreateWithoutArticleInput>, Enumerable<ArticleDocumentUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ArticleDocumentCreateOrConnectWithoutArticleInput>
    createMany?: ArticleDocumentCreateManyArticleInputEnvelope
    connect?: Enumerable<ArticleDocumentWhereUniqueInput>
  }

  export type ArticleCommentUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<ArticleCommentCreateWithoutArticleInput>, Enumerable<ArticleCommentUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ArticleCommentCreateOrConnectWithoutArticleInput>
    createMany?: ArticleCommentCreateManyArticleInputEnvelope
    connect?: Enumerable<ArticleCommentWhereUniqueInput>
  }

  export type Article_HardwareUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<Article_HardwareCreateWithoutArticleInput>, Enumerable<Article_HardwareUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<Article_HardwareCreateOrConnectWithoutArticleInput>
    createMany?: Article_HardwareCreateManyArticleInputEnvelope
    connect?: Enumerable<Article_HardwareWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticlesInput
    upsert?: UserUpsertWithoutArticlesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutArticlesInput, UserUncheckedUpdateWithoutArticlesInput>
  }

  export type ArticleTypeUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<ArticleTypeCreateWithoutArticlesInput, ArticleTypeUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: ArticleTypeCreateOrConnectWithoutArticlesInput
    upsert?: ArticleTypeUpsertWithoutArticlesInput
    connect?: ArticleTypeWhereUniqueInput
    update?: XOR<ArticleTypeUpdateWithoutArticlesInput, ArticleTypeUncheckedUpdateWithoutArticlesInput>
  }

  export type ArticleUpdateOneWithoutArticlesNestedInput = {
    create?: XOR<ArticleCreateWithoutArticlesInput, ArticleUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutArticlesInput
    upsert?: ArticleUpsertWithoutArticlesInput
    disconnect?: boolean
    delete?: boolean
    connect?: ArticleWhereUniqueInput
    update?: XOR<ArticleUpdateWithoutArticlesInput, ArticleUncheckedUpdateWithoutArticlesInput>
  }

  export type ArticleUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutArticleInput>, Enumerable<ArticleUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: ArticleCreateManyArticleInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type ArticleDocumentUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<ArticleDocumentCreateWithoutArticleInput>, Enumerable<ArticleDocumentUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ArticleDocumentCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<ArticleDocumentUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: ArticleDocumentCreateManyArticleInputEnvelope
    set?: Enumerable<ArticleDocumentWhereUniqueInput>
    disconnect?: Enumerable<ArticleDocumentWhereUniqueInput>
    delete?: Enumerable<ArticleDocumentWhereUniqueInput>
    connect?: Enumerable<ArticleDocumentWhereUniqueInput>
    update?: Enumerable<ArticleDocumentUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<ArticleDocumentUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<ArticleDocumentScalarWhereInput>
  }

  export type ArticleCommentUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<ArticleCommentCreateWithoutArticleInput>, Enumerable<ArticleCommentUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ArticleCommentCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<ArticleCommentUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: ArticleCommentCreateManyArticleInputEnvelope
    set?: Enumerable<ArticleCommentWhereUniqueInput>
    disconnect?: Enumerable<ArticleCommentWhereUniqueInput>
    delete?: Enumerable<ArticleCommentWhereUniqueInput>
    connect?: Enumerable<ArticleCommentWhereUniqueInput>
    update?: Enumerable<ArticleCommentUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<ArticleCommentUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<ArticleCommentScalarWhereInput>
  }

  export type Article_HardwareUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<Article_HardwareCreateWithoutArticleInput>, Enumerable<Article_HardwareUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<Article_HardwareCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<Article_HardwareUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: Article_HardwareCreateManyArticleInputEnvelope
    set?: Enumerable<Article_HardwareWhereUniqueInput>
    disconnect?: Enumerable<Article_HardwareWhereUniqueInput>
    delete?: Enumerable<Article_HardwareWhereUniqueInput>
    connect?: Enumerable<Article_HardwareWhereUniqueInput>
    update?: Enumerable<Article_HardwareUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<Article_HardwareUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<Article_HardwareScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ArticleUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutArticleInput>, Enumerable<ArticleUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: ArticleCreateManyArticleInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type ArticleDocumentUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<ArticleDocumentCreateWithoutArticleInput>, Enumerable<ArticleDocumentUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ArticleDocumentCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<ArticleDocumentUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: ArticleDocumentCreateManyArticleInputEnvelope
    set?: Enumerable<ArticleDocumentWhereUniqueInput>
    disconnect?: Enumerable<ArticleDocumentWhereUniqueInput>
    delete?: Enumerable<ArticleDocumentWhereUniqueInput>
    connect?: Enumerable<ArticleDocumentWhereUniqueInput>
    update?: Enumerable<ArticleDocumentUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<ArticleDocumentUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<ArticleDocumentScalarWhereInput>
  }

  export type ArticleCommentUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<ArticleCommentCreateWithoutArticleInput>, Enumerable<ArticleCommentUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ArticleCommentCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<ArticleCommentUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: ArticleCommentCreateManyArticleInputEnvelope
    set?: Enumerable<ArticleCommentWhereUniqueInput>
    disconnect?: Enumerable<ArticleCommentWhereUniqueInput>
    delete?: Enumerable<ArticleCommentWhereUniqueInput>
    connect?: Enumerable<ArticleCommentWhereUniqueInput>
    update?: Enumerable<ArticleCommentUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<ArticleCommentUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<ArticleCommentScalarWhereInput>
  }

  export type Article_HardwareUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<Article_HardwareCreateWithoutArticleInput>, Enumerable<Article_HardwareUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<Article_HardwareCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<Article_HardwareUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: Article_HardwareCreateManyArticleInputEnvelope
    set?: Enumerable<Article_HardwareWhereUniqueInput>
    disconnect?: Enumerable<Article_HardwareWhereUniqueInput>
    delete?: Enumerable<Article_HardwareWhereUniqueInput>
    connect?: Enumerable<Article_HardwareWhereUniqueInput>
    update?: Enumerable<Article_HardwareUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<Article_HardwareUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<Article_HardwareScalarWhereInput>
  }

  export type HardwareCreatecommercialLinksInput = {
    set: Enumerable<string>
  }

  export type UserCreateNestedOneWithoutHardwaresInput = {
    create?: XOR<UserCreateWithoutHardwaresInput, UserUncheckedCreateWithoutHardwaresInput>
    connectOrCreate?: UserCreateOrConnectWithoutHardwaresInput
    connect?: UserWhereUniqueInput
  }

  export type HardwareTypeCreateNestedOneWithoutHardwaresInput = {
    create?: XOR<HardwareTypeCreateWithoutHardwaresInput, HardwareTypeUncheckedCreateWithoutHardwaresInput>
    connectOrCreate?: HardwareTypeCreateOrConnectWithoutHardwaresInput
    connect?: HardwareTypeWhereUniqueInput
  }

  export type HardwareDocumentCreateNestedManyWithoutHardwareInput = {
    create?: XOR<Enumerable<HardwareDocumentCreateWithoutHardwareInput>, Enumerable<HardwareDocumentUncheckedCreateWithoutHardwareInput>>
    connectOrCreate?: Enumerable<HardwareDocumentCreateOrConnectWithoutHardwareInput>
    createMany?: HardwareDocumentCreateManyHardwareInputEnvelope
    connect?: Enumerable<HardwareDocumentWhereUniqueInput>
  }

  export type HardwareCommentCreateNestedManyWithoutHardwareInput = {
    create?: XOR<Enumerable<HardwareCommentCreateWithoutHardwareInput>, Enumerable<HardwareCommentUncheckedCreateWithoutHardwareInput>>
    connectOrCreate?: Enumerable<HardwareCommentCreateOrConnectWithoutHardwareInput>
    createMany?: HardwareCommentCreateManyHardwareInputEnvelope
    connect?: Enumerable<HardwareCommentWhereUniqueInput>
  }

  export type Article_HardwareCreateNestedManyWithoutHardwareInput = {
    create?: XOR<Enumerable<Article_HardwareCreateWithoutHardwareInput>, Enumerable<Article_HardwareUncheckedCreateWithoutHardwareInput>>
    connectOrCreate?: Enumerable<Article_HardwareCreateOrConnectWithoutHardwareInput>
    createMany?: Article_HardwareCreateManyHardwareInputEnvelope
    connect?: Enumerable<Article_HardwareWhereUniqueInput>
  }

  export type Hardware_HardwareCreateNestedManyWithoutFirstHardwareInput = {
    create?: XOR<Enumerable<Hardware_HardwareCreateWithoutFirstHardwareInput>, Enumerable<Hardware_HardwareUncheckedCreateWithoutFirstHardwareInput>>
    connectOrCreate?: Enumerable<Hardware_HardwareCreateOrConnectWithoutFirstHardwareInput>
    createMany?: Hardware_HardwareCreateManyFirstHardwareInputEnvelope
    connect?: Enumerable<Hardware_HardwareWhereUniqueInput>
  }

  export type Hardware_HardwareCreateNestedManyWithoutSecondHardwareInput = {
    create?: XOR<Enumerable<Hardware_HardwareCreateWithoutSecondHardwareInput>, Enumerable<Hardware_HardwareUncheckedCreateWithoutSecondHardwareInput>>
    connectOrCreate?: Enumerable<Hardware_HardwareCreateOrConnectWithoutSecondHardwareInput>
    createMany?: Hardware_HardwareCreateManySecondHardwareInputEnvelope
    connect?: Enumerable<Hardware_HardwareWhereUniqueInput>
  }

  export type HardwareDocumentUncheckedCreateNestedManyWithoutHardwareInput = {
    create?: XOR<Enumerable<HardwareDocumentCreateWithoutHardwareInput>, Enumerable<HardwareDocumentUncheckedCreateWithoutHardwareInput>>
    connectOrCreate?: Enumerable<HardwareDocumentCreateOrConnectWithoutHardwareInput>
    createMany?: HardwareDocumentCreateManyHardwareInputEnvelope
    connect?: Enumerable<HardwareDocumentWhereUniqueInput>
  }

  export type HardwareCommentUncheckedCreateNestedManyWithoutHardwareInput = {
    create?: XOR<Enumerable<HardwareCommentCreateWithoutHardwareInput>, Enumerable<HardwareCommentUncheckedCreateWithoutHardwareInput>>
    connectOrCreate?: Enumerable<HardwareCommentCreateOrConnectWithoutHardwareInput>
    createMany?: HardwareCommentCreateManyHardwareInputEnvelope
    connect?: Enumerable<HardwareCommentWhereUniqueInput>
  }

  export type Article_HardwareUncheckedCreateNestedManyWithoutHardwareInput = {
    create?: XOR<Enumerable<Article_HardwareCreateWithoutHardwareInput>, Enumerable<Article_HardwareUncheckedCreateWithoutHardwareInput>>
    connectOrCreate?: Enumerable<Article_HardwareCreateOrConnectWithoutHardwareInput>
    createMany?: Article_HardwareCreateManyHardwareInputEnvelope
    connect?: Enumerable<Article_HardwareWhereUniqueInput>
  }

  export type Hardware_HardwareUncheckedCreateNestedManyWithoutFirstHardwareInput = {
    create?: XOR<Enumerable<Hardware_HardwareCreateWithoutFirstHardwareInput>, Enumerable<Hardware_HardwareUncheckedCreateWithoutFirstHardwareInput>>
    connectOrCreate?: Enumerable<Hardware_HardwareCreateOrConnectWithoutFirstHardwareInput>
    createMany?: Hardware_HardwareCreateManyFirstHardwareInputEnvelope
    connect?: Enumerable<Hardware_HardwareWhereUniqueInput>
  }

  export type Hardware_HardwareUncheckedCreateNestedManyWithoutSecondHardwareInput = {
    create?: XOR<Enumerable<Hardware_HardwareCreateWithoutSecondHardwareInput>, Enumerable<Hardware_HardwareUncheckedCreateWithoutSecondHardwareInput>>
    connectOrCreate?: Enumerable<Hardware_HardwareCreateOrConnectWithoutSecondHardwareInput>
    createMany?: Hardware_HardwareCreateManySecondHardwareInputEnvelope
    connect?: Enumerable<Hardware_HardwareWhereUniqueInput>
  }

  export type HardwareUpdatecommercialLinksInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type UserUpdateOneRequiredWithoutHardwaresNestedInput = {
    create?: XOR<UserCreateWithoutHardwaresInput, UserUncheckedCreateWithoutHardwaresInput>
    connectOrCreate?: UserCreateOrConnectWithoutHardwaresInput
    upsert?: UserUpsertWithoutHardwaresInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutHardwaresInput, UserUncheckedUpdateWithoutHardwaresInput>
  }

  export type HardwareTypeUpdateOneRequiredWithoutHardwaresNestedInput = {
    create?: XOR<HardwareTypeCreateWithoutHardwaresInput, HardwareTypeUncheckedCreateWithoutHardwaresInput>
    connectOrCreate?: HardwareTypeCreateOrConnectWithoutHardwaresInput
    upsert?: HardwareTypeUpsertWithoutHardwaresInput
    connect?: HardwareTypeWhereUniqueInput
    update?: XOR<HardwareTypeUpdateWithoutHardwaresInput, HardwareTypeUncheckedUpdateWithoutHardwaresInput>
  }

  export type HardwareDocumentUpdateManyWithoutHardwareNestedInput = {
    create?: XOR<Enumerable<HardwareDocumentCreateWithoutHardwareInput>, Enumerable<HardwareDocumentUncheckedCreateWithoutHardwareInput>>
    connectOrCreate?: Enumerable<HardwareDocumentCreateOrConnectWithoutHardwareInput>
    upsert?: Enumerable<HardwareDocumentUpsertWithWhereUniqueWithoutHardwareInput>
    createMany?: HardwareDocumentCreateManyHardwareInputEnvelope
    set?: Enumerable<HardwareDocumentWhereUniqueInput>
    disconnect?: Enumerable<HardwareDocumentWhereUniqueInput>
    delete?: Enumerable<HardwareDocumentWhereUniqueInput>
    connect?: Enumerable<HardwareDocumentWhereUniqueInput>
    update?: Enumerable<HardwareDocumentUpdateWithWhereUniqueWithoutHardwareInput>
    updateMany?: Enumerable<HardwareDocumentUpdateManyWithWhereWithoutHardwareInput>
    deleteMany?: Enumerable<HardwareDocumentScalarWhereInput>
  }

  export type HardwareCommentUpdateManyWithoutHardwareNestedInput = {
    create?: XOR<Enumerable<HardwareCommentCreateWithoutHardwareInput>, Enumerable<HardwareCommentUncheckedCreateWithoutHardwareInput>>
    connectOrCreate?: Enumerable<HardwareCommentCreateOrConnectWithoutHardwareInput>
    upsert?: Enumerable<HardwareCommentUpsertWithWhereUniqueWithoutHardwareInput>
    createMany?: HardwareCommentCreateManyHardwareInputEnvelope
    set?: Enumerable<HardwareCommentWhereUniqueInput>
    disconnect?: Enumerable<HardwareCommentWhereUniqueInput>
    delete?: Enumerable<HardwareCommentWhereUniqueInput>
    connect?: Enumerable<HardwareCommentWhereUniqueInput>
    update?: Enumerable<HardwareCommentUpdateWithWhereUniqueWithoutHardwareInput>
    updateMany?: Enumerable<HardwareCommentUpdateManyWithWhereWithoutHardwareInput>
    deleteMany?: Enumerable<HardwareCommentScalarWhereInput>
  }

  export type Article_HardwareUpdateManyWithoutHardwareNestedInput = {
    create?: XOR<Enumerable<Article_HardwareCreateWithoutHardwareInput>, Enumerable<Article_HardwareUncheckedCreateWithoutHardwareInput>>
    connectOrCreate?: Enumerable<Article_HardwareCreateOrConnectWithoutHardwareInput>
    upsert?: Enumerable<Article_HardwareUpsertWithWhereUniqueWithoutHardwareInput>
    createMany?: Article_HardwareCreateManyHardwareInputEnvelope
    set?: Enumerable<Article_HardwareWhereUniqueInput>
    disconnect?: Enumerable<Article_HardwareWhereUniqueInput>
    delete?: Enumerable<Article_HardwareWhereUniqueInput>
    connect?: Enumerable<Article_HardwareWhereUniqueInput>
    update?: Enumerable<Article_HardwareUpdateWithWhereUniqueWithoutHardwareInput>
    updateMany?: Enumerable<Article_HardwareUpdateManyWithWhereWithoutHardwareInput>
    deleteMany?: Enumerable<Article_HardwareScalarWhereInput>
  }

  export type Hardware_HardwareUpdateManyWithoutFirstHardwareNestedInput = {
    create?: XOR<Enumerable<Hardware_HardwareCreateWithoutFirstHardwareInput>, Enumerable<Hardware_HardwareUncheckedCreateWithoutFirstHardwareInput>>
    connectOrCreate?: Enumerable<Hardware_HardwareCreateOrConnectWithoutFirstHardwareInput>
    upsert?: Enumerable<Hardware_HardwareUpsertWithWhereUniqueWithoutFirstHardwareInput>
    createMany?: Hardware_HardwareCreateManyFirstHardwareInputEnvelope
    set?: Enumerable<Hardware_HardwareWhereUniqueInput>
    disconnect?: Enumerable<Hardware_HardwareWhereUniqueInput>
    delete?: Enumerable<Hardware_HardwareWhereUniqueInput>
    connect?: Enumerable<Hardware_HardwareWhereUniqueInput>
    update?: Enumerable<Hardware_HardwareUpdateWithWhereUniqueWithoutFirstHardwareInput>
    updateMany?: Enumerable<Hardware_HardwareUpdateManyWithWhereWithoutFirstHardwareInput>
    deleteMany?: Enumerable<Hardware_HardwareScalarWhereInput>
  }

  export type Hardware_HardwareUpdateManyWithoutSecondHardwareNestedInput = {
    create?: XOR<Enumerable<Hardware_HardwareCreateWithoutSecondHardwareInput>, Enumerable<Hardware_HardwareUncheckedCreateWithoutSecondHardwareInput>>
    connectOrCreate?: Enumerable<Hardware_HardwareCreateOrConnectWithoutSecondHardwareInput>
    upsert?: Enumerable<Hardware_HardwareUpsertWithWhereUniqueWithoutSecondHardwareInput>
    createMany?: Hardware_HardwareCreateManySecondHardwareInputEnvelope
    set?: Enumerable<Hardware_HardwareWhereUniqueInput>
    disconnect?: Enumerable<Hardware_HardwareWhereUniqueInput>
    delete?: Enumerable<Hardware_HardwareWhereUniqueInput>
    connect?: Enumerable<Hardware_HardwareWhereUniqueInput>
    update?: Enumerable<Hardware_HardwareUpdateWithWhereUniqueWithoutSecondHardwareInput>
    updateMany?: Enumerable<Hardware_HardwareUpdateManyWithWhereWithoutSecondHardwareInput>
    deleteMany?: Enumerable<Hardware_HardwareScalarWhereInput>
  }

  export type HardwareDocumentUncheckedUpdateManyWithoutHardwareNestedInput = {
    create?: XOR<Enumerable<HardwareDocumentCreateWithoutHardwareInput>, Enumerable<HardwareDocumentUncheckedCreateWithoutHardwareInput>>
    connectOrCreate?: Enumerable<HardwareDocumentCreateOrConnectWithoutHardwareInput>
    upsert?: Enumerable<HardwareDocumentUpsertWithWhereUniqueWithoutHardwareInput>
    createMany?: HardwareDocumentCreateManyHardwareInputEnvelope
    set?: Enumerable<HardwareDocumentWhereUniqueInput>
    disconnect?: Enumerable<HardwareDocumentWhereUniqueInput>
    delete?: Enumerable<HardwareDocumentWhereUniqueInput>
    connect?: Enumerable<HardwareDocumentWhereUniqueInput>
    update?: Enumerable<HardwareDocumentUpdateWithWhereUniqueWithoutHardwareInput>
    updateMany?: Enumerable<HardwareDocumentUpdateManyWithWhereWithoutHardwareInput>
    deleteMany?: Enumerable<HardwareDocumentScalarWhereInput>
  }

  export type HardwareCommentUncheckedUpdateManyWithoutHardwareNestedInput = {
    create?: XOR<Enumerable<HardwareCommentCreateWithoutHardwareInput>, Enumerable<HardwareCommentUncheckedCreateWithoutHardwareInput>>
    connectOrCreate?: Enumerable<HardwareCommentCreateOrConnectWithoutHardwareInput>
    upsert?: Enumerable<HardwareCommentUpsertWithWhereUniqueWithoutHardwareInput>
    createMany?: HardwareCommentCreateManyHardwareInputEnvelope
    set?: Enumerable<HardwareCommentWhereUniqueInput>
    disconnect?: Enumerable<HardwareCommentWhereUniqueInput>
    delete?: Enumerable<HardwareCommentWhereUniqueInput>
    connect?: Enumerable<HardwareCommentWhereUniqueInput>
    update?: Enumerable<HardwareCommentUpdateWithWhereUniqueWithoutHardwareInput>
    updateMany?: Enumerable<HardwareCommentUpdateManyWithWhereWithoutHardwareInput>
    deleteMany?: Enumerable<HardwareCommentScalarWhereInput>
  }

  export type Article_HardwareUncheckedUpdateManyWithoutHardwareNestedInput = {
    create?: XOR<Enumerable<Article_HardwareCreateWithoutHardwareInput>, Enumerable<Article_HardwareUncheckedCreateWithoutHardwareInput>>
    connectOrCreate?: Enumerable<Article_HardwareCreateOrConnectWithoutHardwareInput>
    upsert?: Enumerable<Article_HardwareUpsertWithWhereUniqueWithoutHardwareInput>
    createMany?: Article_HardwareCreateManyHardwareInputEnvelope
    set?: Enumerable<Article_HardwareWhereUniqueInput>
    disconnect?: Enumerable<Article_HardwareWhereUniqueInput>
    delete?: Enumerable<Article_HardwareWhereUniqueInput>
    connect?: Enumerable<Article_HardwareWhereUniqueInput>
    update?: Enumerable<Article_HardwareUpdateWithWhereUniqueWithoutHardwareInput>
    updateMany?: Enumerable<Article_HardwareUpdateManyWithWhereWithoutHardwareInput>
    deleteMany?: Enumerable<Article_HardwareScalarWhereInput>
  }

  export type Hardware_HardwareUncheckedUpdateManyWithoutFirstHardwareNestedInput = {
    create?: XOR<Enumerable<Hardware_HardwareCreateWithoutFirstHardwareInput>, Enumerable<Hardware_HardwareUncheckedCreateWithoutFirstHardwareInput>>
    connectOrCreate?: Enumerable<Hardware_HardwareCreateOrConnectWithoutFirstHardwareInput>
    upsert?: Enumerable<Hardware_HardwareUpsertWithWhereUniqueWithoutFirstHardwareInput>
    createMany?: Hardware_HardwareCreateManyFirstHardwareInputEnvelope
    set?: Enumerable<Hardware_HardwareWhereUniqueInput>
    disconnect?: Enumerable<Hardware_HardwareWhereUniqueInput>
    delete?: Enumerable<Hardware_HardwareWhereUniqueInput>
    connect?: Enumerable<Hardware_HardwareWhereUniqueInput>
    update?: Enumerable<Hardware_HardwareUpdateWithWhereUniqueWithoutFirstHardwareInput>
    updateMany?: Enumerable<Hardware_HardwareUpdateManyWithWhereWithoutFirstHardwareInput>
    deleteMany?: Enumerable<Hardware_HardwareScalarWhereInput>
  }

  export type Hardware_HardwareUncheckedUpdateManyWithoutSecondHardwareNestedInput = {
    create?: XOR<Enumerable<Hardware_HardwareCreateWithoutSecondHardwareInput>, Enumerable<Hardware_HardwareUncheckedCreateWithoutSecondHardwareInput>>
    connectOrCreate?: Enumerable<Hardware_HardwareCreateOrConnectWithoutSecondHardwareInput>
    upsert?: Enumerable<Hardware_HardwareUpsertWithWhereUniqueWithoutSecondHardwareInput>
    createMany?: Hardware_HardwareCreateManySecondHardwareInputEnvelope
    set?: Enumerable<Hardware_HardwareWhereUniqueInput>
    disconnect?: Enumerable<Hardware_HardwareWhereUniqueInput>
    delete?: Enumerable<Hardware_HardwareWhereUniqueInput>
    connect?: Enumerable<Hardware_HardwareWhereUniqueInput>
    update?: Enumerable<Hardware_HardwareUpdateWithWhereUniqueWithoutSecondHardwareInput>
    updateMany?: Enumerable<Hardware_HardwareUpdateManyWithWhereWithoutSecondHardwareInput>
    deleteMany?: Enumerable<Hardware_HardwareScalarWhereInput>
  }

  export type DocumentTypeCreateNestedOneWithoutArticleDocumentsInput = {
    create?: XOR<DocumentTypeCreateWithoutArticleDocumentsInput, DocumentTypeUncheckedCreateWithoutArticleDocumentsInput>
    connectOrCreate?: DocumentTypeCreateOrConnectWithoutArticleDocumentsInput
    connect?: DocumentTypeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutArticleDocumentsInput = {
    create?: XOR<UserCreateWithoutArticleDocumentsInput, UserUncheckedCreateWithoutArticleDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticleDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type ArticleCreateNestedOneWithoutArticleDocumentsInput = {
    create?: XOR<ArticleCreateWithoutArticleDocumentsInput, ArticleUncheckedCreateWithoutArticleDocumentsInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutArticleDocumentsInput
    connect?: ArticleWhereUniqueInput
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type DocumentTypeUpdateOneRequiredWithoutArticleDocumentsNestedInput = {
    create?: XOR<DocumentTypeCreateWithoutArticleDocumentsInput, DocumentTypeUncheckedCreateWithoutArticleDocumentsInput>
    connectOrCreate?: DocumentTypeCreateOrConnectWithoutArticleDocumentsInput
    upsert?: DocumentTypeUpsertWithoutArticleDocumentsInput
    connect?: DocumentTypeWhereUniqueInput
    update?: XOR<DocumentTypeUpdateWithoutArticleDocumentsInput, DocumentTypeUncheckedUpdateWithoutArticleDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutArticleDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutArticleDocumentsInput, UserUncheckedCreateWithoutArticleDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticleDocumentsInput
    upsert?: UserUpsertWithoutArticleDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutArticleDocumentsInput, UserUncheckedUpdateWithoutArticleDocumentsInput>
  }

  export type ArticleUpdateOneRequiredWithoutArticleDocumentsNestedInput = {
    create?: XOR<ArticleCreateWithoutArticleDocumentsInput, ArticleUncheckedCreateWithoutArticleDocumentsInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutArticleDocumentsInput
    upsert?: ArticleUpsertWithoutArticleDocumentsInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<ArticleUpdateWithoutArticleDocumentsInput, ArticleUncheckedUpdateWithoutArticleDocumentsInput>
  }

  export type UserCreateNestedOneWithoutArticleCommentsInput = {
    create?: XOR<UserCreateWithoutArticleCommentsInput, UserUncheckedCreateWithoutArticleCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticleCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ArticleCreateNestedOneWithoutArticleCommentsInput = {
    create?: XOR<ArticleCreateWithoutArticleCommentsInput, ArticleUncheckedCreateWithoutArticleCommentsInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutArticleCommentsInput
    connect?: ArticleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutArticleCommentsNestedInput = {
    create?: XOR<UserCreateWithoutArticleCommentsInput, UserUncheckedCreateWithoutArticleCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticleCommentsInput
    upsert?: UserUpsertWithoutArticleCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutArticleCommentsInput, UserUncheckedUpdateWithoutArticleCommentsInput>
  }

  export type ArticleUpdateOneRequiredWithoutArticleCommentsNestedInput = {
    create?: XOR<ArticleCreateWithoutArticleCommentsInput, ArticleUncheckedCreateWithoutArticleCommentsInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutArticleCommentsInput
    upsert?: ArticleUpsertWithoutArticleCommentsInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<ArticleUpdateWithoutArticleCommentsInput, ArticleUncheckedUpdateWithoutArticleCommentsInput>
  }

  export type DocumentTypeCreateNestedOneWithoutHardwareDocumentInput = {
    create?: XOR<DocumentTypeCreateWithoutHardwareDocumentInput, DocumentTypeUncheckedCreateWithoutHardwareDocumentInput>
    connectOrCreate?: DocumentTypeCreateOrConnectWithoutHardwareDocumentInput
    connect?: DocumentTypeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutHardwareDocumentsInput = {
    create?: XOR<UserCreateWithoutHardwareDocumentsInput, UserUncheckedCreateWithoutHardwareDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHardwareDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type HardwareCreateNestedOneWithoutHardwareDocumentsInput = {
    create?: XOR<HardwareCreateWithoutHardwareDocumentsInput, HardwareUncheckedCreateWithoutHardwareDocumentsInput>
    connectOrCreate?: HardwareCreateOrConnectWithoutHardwareDocumentsInput
    connect?: HardwareWhereUniqueInput
  }

  export type DocumentTypeUpdateOneRequiredWithoutHardwareDocumentNestedInput = {
    create?: XOR<DocumentTypeCreateWithoutHardwareDocumentInput, DocumentTypeUncheckedCreateWithoutHardwareDocumentInput>
    connectOrCreate?: DocumentTypeCreateOrConnectWithoutHardwareDocumentInput
    upsert?: DocumentTypeUpsertWithoutHardwareDocumentInput
    connect?: DocumentTypeWhereUniqueInput
    update?: XOR<DocumentTypeUpdateWithoutHardwareDocumentInput, DocumentTypeUncheckedUpdateWithoutHardwareDocumentInput>
  }

  export type UserUpdateOneRequiredWithoutHardwareDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutHardwareDocumentsInput, UserUncheckedCreateWithoutHardwareDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHardwareDocumentsInput
    upsert?: UserUpsertWithoutHardwareDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutHardwareDocumentsInput, UserUncheckedUpdateWithoutHardwareDocumentsInput>
  }

  export type HardwareUpdateOneRequiredWithoutHardwareDocumentsNestedInput = {
    create?: XOR<HardwareCreateWithoutHardwareDocumentsInput, HardwareUncheckedCreateWithoutHardwareDocumentsInput>
    connectOrCreate?: HardwareCreateOrConnectWithoutHardwareDocumentsInput
    upsert?: HardwareUpsertWithoutHardwareDocumentsInput
    connect?: HardwareWhereUniqueInput
    update?: XOR<HardwareUpdateWithoutHardwareDocumentsInput, HardwareUncheckedUpdateWithoutHardwareDocumentsInput>
  }

  export type UserCreateNestedOneWithoutHardwareCommentsInput = {
    create?: XOR<UserCreateWithoutHardwareCommentsInput, UserUncheckedCreateWithoutHardwareCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHardwareCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type HardwareCreateNestedOneWithoutHardwareCommentsInput = {
    create?: XOR<HardwareCreateWithoutHardwareCommentsInput, HardwareUncheckedCreateWithoutHardwareCommentsInput>
    connectOrCreate?: HardwareCreateOrConnectWithoutHardwareCommentsInput
    connect?: HardwareWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutHardwareCommentsNestedInput = {
    create?: XOR<UserCreateWithoutHardwareCommentsInput, UserUncheckedCreateWithoutHardwareCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHardwareCommentsInput
    upsert?: UserUpsertWithoutHardwareCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutHardwareCommentsInput, UserUncheckedUpdateWithoutHardwareCommentsInput>
  }

  export type HardwareUpdateOneRequiredWithoutHardwareCommentsNestedInput = {
    create?: XOR<HardwareCreateWithoutHardwareCommentsInput, HardwareUncheckedCreateWithoutHardwareCommentsInput>
    connectOrCreate?: HardwareCreateOrConnectWithoutHardwareCommentsInput
    upsert?: HardwareUpsertWithoutHardwareCommentsInput
    connect?: HardwareWhereUniqueInput
    update?: XOR<HardwareUpdateWithoutHardwareCommentsInput, HardwareUncheckedUpdateWithoutHardwareCommentsInput>
  }

  export type ArticleCreateNestedOneWithoutArticle_hardwareInput = {
    create?: XOR<ArticleCreateWithoutArticle_hardwareInput, ArticleUncheckedCreateWithoutArticle_hardwareInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutArticle_hardwareInput
    connect?: ArticleWhereUniqueInput
  }

  export type HardwareCreateNestedOneWithoutArticle_hardwareInput = {
    create?: XOR<HardwareCreateWithoutArticle_hardwareInput, HardwareUncheckedCreateWithoutArticle_hardwareInput>
    connectOrCreate?: HardwareCreateOrConnectWithoutArticle_hardwareInput
    connect?: HardwareWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutArticle_hardwareInput = {
    create?: XOR<UserCreateWithoutArticle_hardwareInput, UserUncheckedCreateWithoutArticle_hardwareInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticle_hardwareInput
    connect?: UserWhereUniqueInput
  }

  export type ArticleUpdateOneRequiredWithoutArticle_hardwareNestedInput = {
    create?: XOR<ArticleCreateWithoutArticle_hardwareInput, ArticleUncheckedCreateWithoutArticle_hardwareInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutArticle_hardwareInput
    upsert?: ArticleUpsertWithoutArticle_hardwareInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<ArticleUpdateWithoutArticle_hardwareInput, ArticleUncheckedUpdateWithoutArticle_hardwareInput>
  }

  export type HardwareUpdateOneRequiredWithoutArticle_hardwareNestedInput = {
    create?: XOR<HardwareCreateWithoutArticle_hardwareInput, HardwareUncheckedCreateWithoutArticle_hardwareInput>
    connectOrCreate?: HardwareCreateOrConnectWithoutArticle_hardwareInput
    upsert?: HardwareUpsertWithoutArticle_hardwareInput
    connect?: HardwareWhereUniqueInput
    update?: XOR<HardwareUpdateWithoutArticle_hardwareInput, HardwareUncheckedUpdateWithoutArticle_hardwareInput>
  }

  export type UserUpdateOneRequiredWithoutArticle_hardwareNestedInput = {
    create?: XOR<UserCreateWithoutArticle_hardwareInput, UserUncheckedCreateWithoutArticle_hardwareInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticle_hardwareInput
    upsert?: UserUpsertWithoutArticle_hardwareInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutArticle_hardwareInput, UserUncheckedUpdateWithoutArticle_hardwareInput>
  }

  export type HardwareCreateNestedOneWithoutFirstHardwareOfInput = {
    create?: XOR<HardwareCreateWithoutFirstHardwareOfInput, HardwareUncheckedCreateWithoutFirstHardwareOfInput>
    connectOrCreate?: HardwareCreateOrConnectWithoutFirstHardwareOfInput
    connect?: HardwareWhereUniqueInput
  }

  export type HardwareCreateNestedOneWithoutSecondHardwaresInput = {
    create?: XOR<HardwareCreateWithoutSecondHardwaresInput, HardwareUncheckedCreateWithoutSecondHardwaresInput>
    connectOrCreate?: HardwareCreateOrConnectWithoutSecondHardwaresInput
    connect?: HardwareWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutHardware_hardwareInput = {
    create?: XOR<UserCreateWithoutHardware_hardwareInput, UserUncheckedCreateWithoutHardware_hardwareInput>
    connectOrCreate?: UserCreateOrConnectWithoutHardware_hardwareInput
    connect?: UserWhereUniqueInput
  }

  export type HardwareUpdateOneRequiredWithoutFirstHardwareOfNestedInput = {
    create?: XOR<HardwareCreateWithoutFirstHardwareOfInput, HardwareUncheckedCreateWithoutFirstHardwareOfInput>
    connectOrCreate?: HardwareCreateOrConnectWithoutFirstHardwareOfInput
    upsert?: HardwareUpsertWithoutFirstHardwareOfInput
    connect?: HardwareWhereUniqueInput
    update?: XOR<HardwareUpdateWithoutFirstHardwareOfInput, HardwareUncheckedUpdateWithoutFirstHardwareOfInput>
  }

  export type HardwareUpdateOneRequiredWithoutSecondHardwaresNestedInput = {
    create?: XOR<HardwareCreateWithoutSecondHardwaresInput, HardwareUncheckedCreateWithoutSecondHardwaresInput>
    connectOrCreate?: HardwareCreateOrConnectWithoutSecondHardwaresInput
    upsert?: HardwareUpsertWithoutSecondHardwaresInput
    connect?: HardwareWhereUniqueInput
    update?: XOR<HardwareUpdateWithoutSecondHardwaresInput, HardwareUncheckedUpdateWithoutSecondHardwaresInput>
  }

  export type UserUpdateOneRequiredWithoutHardware_hardwareNestedInput = {
    create?: XOR<UserCreateWithoutHardware_hardwareInput, UserUncheckedCreateWithoutHardware_hardwareInput>
    connectOrCreate?: UserCreateOrConnectWithoutHardware_hardwareInput
    upsert?: UserUpsertWithoutHardware_hardwareInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutHardware_hardwareInput, UserUncheckedUpdateWithoutHardware_hardwareInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedBytesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesFilter | Buffer
  }

  export type NestedBytesWithAggregatesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesWithAggregatesFilter | Buffer
    _count?: NestedIntFilter
    _min?: NestedBytesFilter
    _max?: NestedBytesFilter
  }

  export type UserCreateWithoutRoleInput = {
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    articles?: ArticleCreateNestedManyWithoutUserInput
    articleDocuments?: ArticleDocumentCreateNestedManyWithoutUserInput
    articleComments?: ArticleCommentCreateNestedManyWithoutUserInput
    hardwares?: HardwareCreateNestedManyWithoutUserInput
    hardwareDocuments?: HardwareDocumentCreateNestedManyWithoutUserInput
    hardwareComments?: HardwareCommentCreateNestedManyWithoutUserInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutUserInput
    hardware_hardware?: Hardware_HardwareCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: number
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    articles?: ArticleUncheckedCreateNestedManyWithoutUserInput
    articleDocuments?: ArticleDocumentUncheckedCreateNestedManyWithoutUserInput
    articleComments?: ArticleCommentUncheckedCreateNestedManyWithoutUserInput
    hardwares?: HardwareUncheckedCreateNestedManyWithoutUserInput
    hardwareDocuments?: HardwareDocumentUncheckedCreateNestedManyWithoutUserInput
    hardwareComments?: HardwareCommentUncheckedCreateNestedManyWithoutUserInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutUserInput
    hardware_hardware?: Hardware_HardwareUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: Enumerable<UserCreateManyRoleInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: IntFilter | number
    firstname?: StringFilter | string
    lastname?: StringFilter | string
    username?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    roleId?: IntFilter | number
  }

  export type ArticleCreateWithoutArticleTypeInput = {
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    user: UserCreateNestedOneWithoutArticlesInput
    article?: ArticleCreateNestedOneWithoutArticlesInput
    articles?: ArticleCreateNestedManyWithoutArticleInput
    articleDocuments?: ArticleDocumentCreateNestedManyWithoutArticleInput
    articleComments?: ArticleCommentCreateNestedManyWithoutArticleInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutArticleTypeInput = {
    id?: number
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    userId: number
    articleId?: number | null
    articles?: ArticleUncheckedCreateNestedManyWithoutArticleInput
    articleDocuments?: ArticleDocumentUncheckedCreateNestedManyWithoutArticleInput
    articleComments?: ArticleCommentUncheckedCreateNestedManyWithoutArticleInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutArticleTypeInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutArticleTypeInput, ArticleUncheckedCreateWithoutArticleTypeInput>
  }

  export type ArticleCreateManyArticleTypeInputEnvelope = {
    data: Enumerable<ArticleCreateManyArticleTypeInput>
    skipDuplicates?: boolean
  }

  export type ArticleUpsertWithWhereUniqueWithoutArticleTypeInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutArticleTypeInput, ArticleUncheckedUpdateWithoutArticleTypeInput>
    create: XOR<ArticleCreateWithoutArticleTypeInput, ArticleUncheckedCreateWithoutArticleTypeInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutArticleTypeInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutArticleTypeInput, ArticleUncheckedUpdateWithoutArticleTypeInput>
  }

  export type ArticleUpdateManyWithWhereWithoutArticleTypeInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutArticlesInput>
  }

  export type ArticleScalarWhereInput = {
    AND?: Enumerable<ArticleScalarWhereInput>
    OR?: Enumerable<ArticleScalarWhereInput>
    NOT?: Enumerable<ArticleScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    subDescription?: StringFilter | string
    description?: StringFilter | string
    isPublished?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    modifiedAt?: DateTimeNullableFilter | Date | string | null
    userId?: IntFilter | number
    articleTypeId?: IntFilter | number
    articleId?: IntNullableFilter | number | null
  }

  export type HardwareCreateWithoutHardwareTypeInput = {
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    user: UserCreateNestedOneWithoutHardwaresInput
    hardwareDocuments?: HardwareDocumentCreateNestedManyWithoutHardwareInput
    hardwareComments?: HardwareCommentCreateNestedManyWithoutHardwareInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutHardwareInput
    firstHardwareOf?: Hardware_HardwareCreateNestedManyWithoutFirstHardwareInput
    secondHardwares?: Hardware_HardwareCreateNestedManyWithoutSecondHardwareInput
  }

  export type HardwareUncheckedCreateWithoutHardwareTypeInput = {
    id?: number
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    userId: number
    hardwareDocuments?: HardwareDocumentUncheckedCreateNestedManyWithoutHardwareInput
    hardwareComments?: HardwareCommentUncheckedCreateNestedManyWithoutHardwareInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutHardwareInput
    firstHardwareOf?: Hardware_HardwareUncheckedCreateNestedManyWithoutFirstHardwareInput
    secondHardwares?: Hardware_HardwareUncheckedCreateNestedManyWithoutSecondHardwareInput
  }

  export type HardwareCreateOrConnectWithoutHardwareTypeInput = {
    where: HardwareWhereUniqueInput
    create: XOR<HardwareCreateWithoutHardwareTypeInput, HardwareUncheckedCreateWithoutHardwareTypeInput>
  }

  export type HardwareCreateManyHardwareTypeInputEnvelope = {
    data: Enumerable<HardwareCreateManyHardwareTypeInput>
    skipDuplicates?: boolean
  }

  export type HardwareUpsertWithWhereUniqueWithoutHardwareTypeInput = {
    where: HardwareWhereUniqueInput
    update: XOR<HardwareUpdateWithoutHardwareTypeInput, HardwareUncheckedUpdateWithoutHardwareTypeInput>
    create: XOR<HardwareCreateWithoutHardwareTypeInput, HardwareUncheckedCreateWithoutHardwareTypeInput>
  }

  export type HardwareUpdateWithWhereUniqueWithoutHardwareTypeInput = {
    where: HardwareWhereUniqueInput
    data: XOR<HardwareUpdateWithoutHardwareTypeInput, HardwareUncheckedUpdateWithoutHardwareTypeInput>
  }

  export type HardwareUpdateManyWithWhereWithoutHardwareTypeInput = {
    where: HardwareScalarWhereInput
    data: XOR<HardwareUpdateManyMutationInput, HardwareUncheckedUpdateManyWithoutHardwaresInput>
  }

  export type HardwareScalarWhereInput = {
    AND?: Enumerable<HardwareScalarWhereInput>
    OR?: Enumerable<HardwareScalarWhereInput>
    NOT?: Enumerable<HardwareScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    brand?: StringFilter | string
    subDescription?: StringFilter | string
    description?: StringFilter | string
    isDiy?: BoolFilter | boolean
    creationDate?: DateTimeFilter | Date | string
    discontinuationDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    modifiedAt?: DateTimeNullableFilter | Date | string | null
    commercialLinks?: StringNullableListFilter
    userId?: IntFilter | number
    hardwareTypeId?: IntFilter | number
  }

  export type ArticleDocumentCreateWithoutDocumentTypeInput = {
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutArticleDocumentsInput
    article: ArticleCreateNestedOneWithoutArticleDocumentsInput
  }

  export type ArticleDocumentUncheckedCreateWithoutDocumentTypeInput = {
    id?: number
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    userId: number
    articleId: number
  }

  export type ArticleDocumentCreateOrConnectWithoutDocumentTypeInput = {
    where: ArticleDocumentWhereUniqueInput
    create: XOR<ArticleDocumentCreateWithoutDocumentTypeInput, ArticleDocumentUncheckedCreateWithoutDocumentTypeInput>
  }

  export type ArticleDocumentCreateManyDocumentTypeInputEnvelope = {
    data: Enumerable<ArticleDocumentCreateManyDocumentTypeInput>
    skipDuplicates?: boolean
  }

  export type HardwareDocumentCreateWithoutDocumentTypeInput = {
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutHardwareDocumentsInput
    hardware: HardwareCreateNestedOneWithoutHardwareDocumentsInput
  }

  export type HardwareDocumentUncheckedCreateWithoutDocumentTypeInput = {
    id?: number
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    userId: number
    hardwareId: number
  }

  export type HardwareDocumentCreateOrConnectWithoutDocumentTypeInput = {
    where: HardwareDocumentWhereUniqueInput
    create: XOR<HardwareDocumentCreateWithoutDocumentTypeInput, HardwareDocumentUncheckedCreateWithoutDocumentTypeInput>
  }

  export type HardwareDocumentCreateManyDocumentTypeInputEnvelope = {
    data: Enumerable<HardwareDocumentCreateManyDocumentTypeInput>
    skipDuplicates?: boolean
  }

  export type ArticleDocumentUpsertWithWhereUniqueWithoutDocumentTypeInput = {
    where: ArticleDocumentWhereUniqueInput
    update: XOR<ArticleDocumentUpdateWithoutDocumentTypeInput, ArticleDocumentUncheckedUpdateWithoutDocumentTypeInput>
    create: XOR<ArticleDocumentCreateWithoutDocumentTypeInput, ArticleDocumentUncheckedCreateWithoutDocumentTypeInput>
  }

  export type ArticleDocumentUpdateWithWhereUniqueWithoutDocumentTypeInput = {
    where: ArticleDocumentWhereUniqueInput
    data: XOR<ArticleDocumentUpdateWithoutDocumentTypeInput, ArticleDocumentUncheckedUpdateWithoutDocumentTypeInput>
  }

  export type ArticleDocumentUpdateManyWithWhereWithoutDocumentTypeInput = {
    where: ArticleDocumentScalarWhereInput
    data: XOR<ArticleDocumentUpdateManyMutationInput, ArticleDocumentUncheckedUpdateManyWithoutArticleDocumentsInput>
  }

  export type ArticleDocumentScalarWhereInput = {
    AND?: Enumerable<ArticleDocumentScalarWhereInput>
    OR?: Enumerable<ArticleDocumentScalarWhereInput>
    NOT?: Enumerable<ArticleDocumentScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    mimetype?: StringFilter | string
    buffer?: BytesFilter | Buffer
    size?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    documentTypeId?: IntFilter | number
    userId?: IntFilter | number
    articleId?: IntFilter | number
  }

  export type HardwareDocumentUpsertWithWhereUniqueWithoutDocumentTypeInput = {
    where: HardwareDocumentWhereUniqueInput
    update: XOR<HardwareDocumentUpdateWithoutDocumentTypeInput, HardwareDocumentUncheckedUpdateWithoutDocumentTypeInput>
    create: XOR<HardwareDocumentCreateWithoutDocumentTypeInput, HardwareDocumentUncheckedCreateWithoutDocumentTypeInput>
  }

  export type HardwareDocumentUpdateWithWhereUniqueWithoutDocumentTypeInput = {
    where: HardwareDocumentWhereUniqueInput
    data: XOR<HardwareDocumentUpdateWithoutDocumentTypeInput, HardwareDocumentUncheckedUpdateWithoutDocumentTypeInput>
  }

  export type HardwareDocumentUpdateManyWithWhereWithoutDocumentTypeInput = {
    where: HardwareDocumentScalarWhereInput
    data: XOR<HardwareDocumentUpdateManyMutationInput, HardwareDocumentUncheckedUpdateManyWithoutHardwareDocumentInput>
  }

  export type HardwareDocumentScalarWhereInput = {
    AND?: Enumerable<HardwareDocumentScalarWhereInput>
    OR?: Enumerable<HardwareDocumentScalarWhereInput>
    NOT?: Enumerable<HardwareDocumentScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    mimetype?: StringFilter | string
    buffer?: BytesFilter | Buffer
    size?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    documentTypeId?: IntFilter | number
    userId?: IntFilter | number
    hardwareId?: IntFilter | number
  }

  export type RoleCreateWithoutUsersInput = {
    role: string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    role: string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type ArticleCreateWithoutUserInput = {
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    articleType: ArticleTypeCreateNestedOneWithoutArticlesInput
    article?: ArticleCreateNestedOneWithoutArticlesInput
    articles?: ArticleCreateNestedManyWithoutArticleInput
    articleDocuments?: ArticleDocumentCreateNestedManyWithoutArticleInput
    articleComments?: ArticleCommentCreateNestedManyWithoutArticleInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    articleTypeId: number
    articleId?: number | null
    articles?: ArticleUncheckedCreateNestedManyWithoutArticleInput
    articleDocuments?: ArticleDocumentUncheckedCreateNestedManyWithoutArticleInput
    articleComments?: ArticleCommentUncheckedCreateNestedManyWithoutArticleInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutUserInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutUserInput, ArticleUncheckedCreateWithoutUserInput>
  }

  export type ArticleCreateManyUserInputEnvelope = {
    data: Enumerable<ArticleCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ArticleDocumentCreateWithoutUserInput = {
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    documentType: DocumentTypeCreateNestedOneWithoutArticleDocumentsInput
    article: ArticleCreateNestedOneWithoutArticleDocumentsInput
  }

  export type ArticleDocumentUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    documentTypeId: number
    articleId: number
  }

  export type ArticleDocumentCreateOrConnectWithoutUserInput = {
    where: ArticleDocumentWhereUniqueInput
    create: XOR<ArticleDocumentCreateWithoutUserInput, ArticleDocumentUncheckedCreateWithoutUserInput>
  }

  export type ArticleDocumentCreateManyUserInputEnvelope = {
    data: Enumerable<ArticleDocumentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ArticleCommentCreateWithoutUserInput = {
    content: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    article: ArticleCreateNestedOneWithoutArticleCommentsInput
  }

  export type ArticleCommentUncheckedCreateWithoutUserInput = {
    id?: number
    content: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    articleId: number
  }

  export type ArticleCommentCreateOrConnectWithoutUserInput = {
    where: ArticleCommentWhereUniqueInput
    create: XOR<ArticleCommentCreateWithoutUserInput, ArticleCommentUncheckedCreateWithoutUserInput>
  }

  export type ArticleCommentCreateManyUserInputEnvelope = {
    data: Enumerable<ArticleCommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type HardwareCreateWithoutUserInput = {
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    hardwareType: HardwareTypeCreateNestedOneWithoutHardwaresInput
    hardwareDocuments?: HardwareDocumentCreateNestedManyWithoutHardwareInput
    hardwareComments?: HardwareCommentCreateNestedManyWithoutHardwareInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutHardwareInput
    firstHardwareOf?: Hardware_HardwareCreateNestedManyWithoutFirstHardwareInput
    secondHardwares?: Hardware_HardwareCreateNestedManyWithoutSecondHardwareInput
  }

  export type HardwareUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    hardwareTypeId: number
    hardwareDocuments?: HardwareDocumentUncheckedCreateNestedManyWithoutHardwareInput
    hardwareComments?: HardwareCommentUncheckedCreateNestedManyWithoutHardwareInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutHardwareInput
    firstHardwareOf?: Hardware_HardwareUncheckedCreateNestedManyWithoutFirstHardwareInput
    secondHardwares?: Hardware_HardwareUncheckedCreateNestedManyWithoutSecondHardwareInput
  }

  export type HardwareCreateOrConnectWithoutUserInput = {
    where: HardwareWhereUniqueInput
    create: XOR<HardwareCreateWithoutUserInput, HardwareUncheckedCreateWithoutUserInput>
  }

  export type HardwareCreateManyUserInputEnvelope = {
    data: Enumerable<HardwareCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type HardwareDocumentCreateWithoutUserInput = {
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    documentType: DocumentTypeCreateNestedOneWithoutHardwareDocumentInput
    hardware: HardwareCreateNestedOneWithoutHardwareDocumentsInput
  }

  export type HardwareDocumentUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    documentTypeId: number
    hardwareId: number
  }

  export type HardwareDocumentCreateOrConnectWithoutUserInput = {
    where: HardwareDocumentWhereUniqueInput
    create: XOR<HardwareDocumentCreateWithoutUserInput, HardwareDocumentUncheckedCreateWithoutUserInput>
  }

  export type HardwareDocumentCreateManyUserInputEnvelope = {
    data: Enumerable<HardwareDocumentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type HardwareCommentCreateWithoutUserInput = {
    content: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    hardware: HardwareCreateNestedOneWithoutHardwareCommentsInput
  }

  export type HardwareCommentUncheckedCreateWithoutUserInput = {
    id?: number
    content: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    hardwareId: number
  }

  export type HardwareCommentCreateOrConnectWithoutUserInput = {
    where: HardwareCommentWhereUniqueInput
    create: XOR<HardwareCommentCreateWithoutUserInput, HardwareCommentUncheckedCreateWithoutUserInput>
  }

  export type HardwareCommentCreateManyUserInputEnvelope = {
    data: Enumerable<HardwareCommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type Article_HardwareCreateWithoutUserInput = {
    assigneddAt?: Date | string
    article: ArticleCreateNestedOneWithoutArticle_hardwareInput
    hardware: HardwareCreateNestedOneWithoutArticle_hardwareInput
  }

  export type Article_HardwareUncheckedCreateWithoutUserInput = {
    assigneddAt?: Date | string
    articleId: number
    hardwareId: number
  }

  export type Article_HardwareCreateOrConnectWithoutUserInput = {
    where: Article_HardwareWhereUniqueInput
    create: XOR<Article_HardwareCreateWithoutUserInput, Article_HardwareUncheckedCreateWithoutUserInput>
  }

  export type Article_HardwareCreateManyUserInputEnvelope = {
    data: Enumerable<Article_HardwareCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type Hardware_HardwareCreateWithoutUserInput = {
    assigneddAt?: Date | string
    firstHardware: HardwareCreateNestedOneWithoutFirstHardwareOfInput
    secondHardware: HardwareCreateNestedOneWithoutSecondHardwaresInput
  }

  export type Hardware_HardwareUncheckedCreateWithoutUserInput = {
    assigneddAt?: Date | string
    firstHardwareId: number
    secondHardwareId: number
  }

  export type Hardware_HardwareCreateOrConnectWithoutUserInput = {
    where: Hardware_HardwareWhereUniqueInput
    create: XOR<Hardware_HardwareCreateWithoutUserInput, Hardware_HardwareUncheckedCreateWithoutUserInput>
  }

  export type Hardware_HardwareCreateManyUserInputEnvelope = {
    data: Enumerable<Hardware_HardwareCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    role?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleUpsertWithWhereUniqueWithoutUserInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutUserInput, ArticleUncheckedUpdateWithoutUserInput>
    create: XOR<ArticleCreateWithoutUserInput, ArticleUncheckedCreateWithoutUserInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutUserInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutUserInput, ArticleUncheckedUpdateWithoutUserInput>
  }

  export type ArticleUpdateManyWithWhereWithoutUserInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutArticlesInput>
  }

  export type ArticleDocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: ArticleDocumentWhereUniqueInput
    update: XOR<ArticleDocumentUpdateWithoutUserInput, ArticleDocumentUncheckedUpdateWithoutUserInput>
    create: XOR<ArticleDocumentCreateWithoutUserInput, ArticleDocumentUncheckedCreateWithoutUserInput>
  }

  export type ArticleDocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: ArticleDocumentWhereUniqueInput
    data: XOR<ArticleDocumentUpdateWithoutUserInput, ArticleDocumentUncheckedUpdateWithoutUserInput>
  }

  export type ArticleDocumentUpdateManyWithWhereWithoutUserInput = {
    where: ArticleDocumentScalarWhereInput
    data: XOR<ArticleDocumentUpdateManyMutationInput, ArticleDocumentUncheckedUpdateManyWithoutArticleDocumentsInput>
  }

  export type ArticleCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: ArticleCommentWhereUniqueInput
    update: XOR<ArticleCommentUpdateWithoutUserInput, ArticleCommentUncheckedUpdateWithoutUserInput>
    create: XOR<ArticleCommentCreateWithoutUserInput, ArticleCommentUncheckedCreateWithoutUserInput>
  }

  export type ArticleCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: ArticleCommentWhereUniqueInput
    data: XOR<ArticleCommentUpdateWithoutUserInput, ArticleCommentUncheckedUpdateWithoutUserInput>
  }

  export type ArticleCommentUpdateManyWithWhereWithoutUserInput = {
    where: ArticleCommentScalarWhereInput
    data: XOR<ArticleCommentUpdateManyMutationInput, ArticleCommentUncheckedUpdateManyWithoutArticleCommentsInput>
  }

  export type ArticleCommentScalarWhereInput = {
    AND?: Enumerable<ArticleCommentScalarWhereInput>
    OR?: Enumerable<ArticleCommentScalarWhereInput>
    NOT?: Enumerable<ArticleCommentScalarWhereInput>
    id?: IntFilter | number
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    modifiedAt?: DateTimeNullableFilter | Date | string | null
    userId?: IntFilter | number
    articleId?: IntFilter | number
  }

  export type HardwareUpsertWithWhereUniqueWithoutUserInput = {
    where: HardwareWhereUniqueInput
    update: XOR<HardwareUpdateWithoutUserInput, HardwareUncheckedUpdateWithoutUserInput>
    create: XOR<HardwareCreateWithoutUserInput, HardwareUncheckedCreateWithoutUserInput>
  }

  export type HardwareUpdateWithWhereUniqueWithoutUserInput = {
    where: HardwareWhereUniqueInput
    data: XOR<HardwareUpdateWithoutUserInput, HardwareUncheckedUpdateWithoutUserInput>
  }

  export type HardwareUpdateManyWithWhereWithoutUserInput = {
    where: HardwareScalarWhereInput
    data: XOR<HardwareUpdateManyMutationInput, HardwareUncheckedUpdateManyWithoutHardwaresInput>
  }

  export type HardwareDocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: HardwareDocumentWhereUniqueInput
    update: XOR<HardwareDocumentUpdateWithoutUserInput, HardwareDocumentUncheckedUpdateWithoutUserInput>
    create: XOR<HardwareDocumentCreateWithoutUserInput, HardwareDocumentUncheckedCreateWithoutUserInput>
  }

  export type HardwareDocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: HardwareDocumentWhereUniqueInput
    data: XOR<HardwareDocumentUpdateWithoutUserInput, HardwareDocumentUncheckedUpdateWithoutUserInput>
  }

  export type HardwareDocumentUpdateManyWithWhereWithoutUserInput = {
    where: HardwareDocumentScalarWhereInput
    data: XOR<HardwareDocumentUpdateManyMutationInput, HardwareDocumentUncheckedUpdateManyWithoutHardwareDocumentsInput>
  }

  export type HardwareCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: HardwareCommentWhereUniqueInput
    update: XOR<HardwareCommentUpdateWithoutUserInput, HardwareCommentUncheckedUpdateWithoutUserInput>
    create: XOR<HardwareCommentCreateWithoutUserInput, HardwareCommentUncheckedCreateWithoutUserInput>
  }

  export type HardwareCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: HardwareCommentWhereUniqueInput
    data: XOR<HardwareCommentUpdateWithoutUserInput, HardwareCommentUncheckedUpdateWithoutUserInput>
  }

  export type HardwareCommentUpdateManyWithWhereWithoutUserInput = {
    where: HardwareCommentScalarWhereInput
    data: XOR<HardwareCommentUpdateManyMutationInput, HardwareCommentUncheckedUpdateManyWithoutHardwareCommentsInput>
  }

  export type HardwareCommentScalarWhereInput = {
    AND?: Enumerable<HardwareCommentScalarWhereInput>
    OR?: Enumerable<HardwareCommentScalarWhereInput>
    NOT?: Enumerable<HardwareCommentScalarWhereInput>
    id?: IntFilter | number
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    modifiedAt?: DateTimeNullableFilter | Date | string | null
    userId?: IntFilter | number
    hardwareId?: IntFilter | number
  }

  export type Article_HardwareUpsertWithWhereUniqueWithoutUserInput = {
    where: Article_HardwareWhereUniqueInput
    update: XOR<Article_HardwareUpdateWithoutUserInput, Article_HardwareUncheckedUpdateWithoutUserInput>
    create: XOR<Article_HardwareCreateWithoutUserInput, Article_HardwareUncheckedCreateWithoutUserInput>
  }

  export type Article_HardwareUpdateWithWhereUniqueWithoutUserInput = {
    where: Article_HardwareWhereUniqueInput
    data: XOR<Article_HardwareUpdateWithoutUserInput, Article_HardwareUncheckedUpdateWithoutUserInput>
  }

  export type Article_HardwareUpdateManyWithWhereWithoutUserInput = {
    where: Article_HardwareScalarWhereInput
    data: XOR<Article_HardwareUpdateManyMutationInput, Article_HardwareUncheckedUpdateManyWithoutArticle_hardwareInput>
  }

  export type Article_HardwareScalarWhereInput = {
    AND?: Enumerable<Article_HardwareScalarWhereInput>
    OR?: Enumerable<Article_HardwareScalarWhereInput>
    NOT?: Enumerable<Article_HardwareScalarWhereInput>
    assigneddAt?: DateTimeFilter | Date | string
    articleId?: IntFilter | number
    hardwareId?: IntFilter | number
    userId?: IntFilter | number
  }

  export type Hardware_HardwareUpsertWithWhereUniqueWithoutUserInput = {
    where: Hardware_HardwareWhereUniqueInput
    update: XOR<Hardware_HardwareUpdateWithoutUserInput, Hardware_HardwareUncheckedUpdateWithoutUserInput>
    create: XOR<Hardware_HardwareCreateWithoutUserInput, Hardware_HardwareUncheckedCreateWithoutUserInput>
  }

  export type Hardware_HardwareUpdateWithWhereUniqueWithoutUserInput = {
    where: Hardware_HardwareWhereUniqueInput
    data: XOR<Hardware_HardwareUpdateWithoutUserInput, Hardware_HardwareUncheckedUpdateWithoutUserInput>
  }

  export type Hardware_HardwareUpdateManyWithWhereWithoutUserInput = {
    where: Hardware_HardwareScalarWhereInput
    data: XOR<Hardware_HardwareUpdateManyMutationInput, Hardware_HardwareUncheckedUpdateManyWithoutHardware_hardwareInput>
  }

  export type Hardware_HardwareScalarWhereInput = {
    AND?: Enumerable<Hardware_HardwareScalarWhereInput>
    OR?: Enumerable<Hardware_HardwareScalarWhereInput>
    NOT?: Enumerable<Hardware_HardwareScalarWhereInput>
    assigneddAt?: DateTimeFilter | Date | string
    firstHardwareId?: IntFilter | number
    secondHardwareId?: IntFilter | number
    userId?: IntFilter | number
  }

  export type UserCreateWithoutArticlesInput = {
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    role: RoleCreateNestedOneWithoutUsersInput
    articleDocuments?: ArticleDocumentCreateNestedManyWithoutUserInput
    articleComments?: ArticleCommentCreateNestedManyWithoutUserInput
    hardwares?: HardwareCreateNestedManyWithoutUserInput
    hardwareDocuments?: HardwareDocumentCreateNestedManyWithoutUserInput
    hardwareComments?: HardwareCommentCreateNestedManyWithoutUserInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutUserInput
    hardware_hardware?: Hardware_HardwareCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutArticlesInput = {
    id?: number
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    roleId: number
    articleDocuments?: ArticleDocumentUncheckedCreateNestedManyWithoutUserInput
    articleComments?: ArticleCommentUncheckedCreateNestedManyWithoutUserInput
    hardwares?: HardwareUncheckedCreateNestedManyWithoutUserInput
    hardwareDocuments?: HardwareDocumentUncheckedCreateNestedManyWithoutUserInput
    hardwareComments?: HardwareCommentUncheckedCreateNestedManyWithoutUserInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutUserInput
    hardware_hardware?: Hardware_HardwareUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutArticlesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
  }

  export type ArticleTypeCreateWithoutArticlesInput = {
    type: string
  }

  export type ArticleTypeUncheckedCreateWithoutArticlesInput = {
    id?: number
    type: string
  }

  export type ArticleTypeCreateOrConnectWithoutArticlesInput = {
    where: ArticleTypeWhereUniqueInput
    create: XOR<ArticleTypeCreateWithoutArticlesInput, ArticleTypeUncheckedCreateWithoutArticlesInput>
  }

  export type ArticleCreateWithoutArticlesInput = {
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    user: UserCreateNestedOneWithoutArticlesInput
    articleType: ArticleTypeCreateNestedOneWithoutArticlesInput
    article?: ArticleCreateNestedOneWithoutArticlesInput
    articleDocuments?: ArticleDocumentCreateNestedManyWithoutArticleInput
    articleComments?: ArticleCommentCreateNestedManyWithoutArticleInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutArticlesInput = {
    id?: number
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    userId: number
    articleTypeId: number
    articleId?: number | null
    articleDocuments?: ArticleDocumentUncheckedCreateNestedManyWithoutArticleInput
    articleComments?: ArticleCommentUncheckedCreateNestedManyWithoutArticleInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutArticlesInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutArticlesInput, ArticleUncheckedCreateWithoutArticlesInput>
  }

  export type ArticleCreateWithoutArticleInput = {
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    user: UserCreateNestedOneWithoutArticlesInput
    articleType: ArticleTypeCreateNestedOneWithoutArticlesInput
    articles?: ArticleCreateNestedManyWithoutArticleInput
    articleDocuments?: ArticleDocumentCreateNestedManyWithoutArticleInput
    articleComments?: ArticleCommentCreateNestedManyWithoutArticleInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutArticleInput = {
    id?: number
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    userId: number
    articleTypeId: number
    articles?: ArticleUncheckedCreateNestedManyWithoutArticleInput
    articleDocuments?: ArticleDocumentUncheckedCreateNestedManyWithoutArticleInput
    articleComments?: ArticleCommentUncheckedCreateNestedManyWithoutArticleInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutArticleInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutArticleInput, ArticleUncheckedCreateWithoutArticleInput>
  }

  export type ArticleCreateManyArticleInputEnvelope = {
    data: Enumerable<ArticleCreateManyArticleInput>
    skipDuplicates?: boolean
  }

  export type ArticleDocumentCreateWithoutArticleInput = {
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    documentType: DocumentTypeCreateNestedOneWithoutArticleDocumentsInput
    user: UserCreateNestedOneWithoutArticleDocumentsInput
  }

  export type ArticleDocumentUncheckedCreateWithoutArticleInput = {
    id?: number
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    documentTypeId: number
    userId: number
  }

  export type ArticleDocumentCreateOrConnectWithoutArticleInput = {
    where: ArticleDocumentWhereUniqueInput
    create: XOR<ArticleDocumentCreateWithoutArticleInput, ArticleDocumentUncheckedCreateWithoutArticleInput>
  }

  export type ArticleDocumentCreateManyArticleInputEnvelope = {
    data: Enumerable<ArticleDocumentCreateManyArticleInput>
    skipDuplicates?: boolean
  }

  export type ArticleCommentCreateWithoutArticleInput = {
    content: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    user: UserCreateNestedOneWithoutArticleCommentsInput
  }

  export type ArticleCommentUncheckedCreateWithoutArticleInput = {
    id?: number
    content: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    userId: number
  }

  export type ArticleCommentCreateOrConnectWithoutArticleInput = {
    where: ArticleCommentWhereUniqueInput
    create: XOR<ArticleCommentCreateWithoutArticleInput, ArticleCommentUncheckedCreateWithoutArticleInput>
  }

  export type ArticleCommentCreateManyArticleInputEnvelope = {
    data: Enumerable<ArticleCommentCreateManyArticleInput>
    skipDuplicates?: boolean
  }

  export type Article_HardwareCreateWithoutArticleInput = {
    assigneddAt?: Date | string
    hardware: HardwareCreateNestedOneWithoutArticle_hardwareInput
    user: UserCreateNestedOneWithoutArticle_hardwareInput
  }

  export type Article_HardwareUncheckedCreateWithoutArticleInput = {
    assigneddAt?: Date | string
    hardwareId: number
    userId: number
  }

  export type Article_HardwareCreateOrConnectWithoutArticleInput = {
    where: Article_HardwareWhereUniqueInput
    create: XOR<Article_HardwareCreateWithoutArticleInput, Article_HardwareUncheckedCreateWithoutArticleInput>
  }

  export type Article_HardwareCreateManyArticleInputEnvelope = {
    data: Enumerable<Article_HardwareCreateManyArticleInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutArticlesInput = {
    update: XOR<UserUpdateWithoutArticlesInput, UserUncheckedUpdateWithoutArticlesInput>
    create: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
  }

  export type UserUpdateWithoutArticlesInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    articleDocuments?: ArticleDocumentUpdateManyWithoutUserNestedInput
    articleComments?: ArticleCommentUpdateManyWithoutUserNestedInput
    hardwares?: HardwareUpdateManyWithoutUserNestedInput
    hardwareDocuments?: HardwareDocumentUpdateManyWithoutUserNestedInput
    hardwareComments?: HardwareCommentUpdateManyWithoutUserNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutUserNestedInput
    hardware_hardware?: Hardware_HardwareUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutArticlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    articleDocuments?: ArticleDocumentUncheckedUpdateManyWithoutUserNestedInput
    articleComments?: ArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    hardwares?: HardwareUncheckedUpdateManyWithoutUserNestedInput
    hardwareDocuments?: HardwareDocumentUncheckedUpdateManyWithoutUserNestedInput
    hardwareComments?: HardwareCommentUncheckedUpdateManyWithoutUserNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutUserNestedInput
    hardware_hardware?: Hardware_HardwareUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ArticleTypeUpsertWithoutArticlesInput = {
    update: XOR<ArticleTypeUpdateWithoutArticlesInput, ArticleTypeUncheckedUpdateWithoutArticlesInput>
    create: XOR<ArticleTypeCreateWithoutArticlesInput, ArticleTypeUncheckedCreateWithoutArticlesInput>
  }

  export type ArticleTypeUpdateWithoutArticlesInput = {
    type?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleTypeUncheckedUpdateWithoutArticlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleUpsertWithoutArticlesInput = {
    update: XOR<ArticleUpdateWithoutArticlesInput, ArticleUncheckedUpdateWithoutArticlesInput>
    create: XOR<ArticleCreateWithoutArticlesInput, ArticleUncheckedCreateWithoutArticlesInput>
  }

  export type ArticleUpdateWithoutArticlesInput = {
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutArticlesNestedInput
    articleType?: ArticleTypeUpdateOneRequiredWithoutArticlesNestedInput
    article?: ArticleUpdateOneWithoutArticlesNestedInput
    articleDocuments?: ArticleDocumentUpdateManyWithoutArticleNestedInput
    articleComments?: ArticleCommentUpdateManyWithoutArticleNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutArticlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    articleTypeId?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    articleDocuments?: ArticleDocumentUncheckedUpdateManyWithoutArticleNestedInput
    articleComments?: ArticleCommentUncheckedUpdateManyWithoutArticleNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUpsertWithWhereUniqueWithoutArticleInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutArticleInput, ArticleUncheckedUpdateWithoutArticleInput>
    create: XOR<ArticleCreateWithoutArticleInput, ArticleUncheckedCreateWithoutArticleInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutArticleInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutArticleInput, ArticleUncheckedUpdateWithoutArticleInput>
  }

  export type ArticleUpdateManyWithWhereWithoutArticleInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutArticlesInput>
  }

  export type ArticleDocumentUpsertWithWhereUniqueWithoutArticleInput = {
    where: ArticleDocumentWhereUniqueInput
    update: XOR<ArticleDocumentUpdateWithoutArticleInput, ArticleDocumentUncheckedUpdateWithoutArticleInput>
    create: XOR<ArticleDocumentCreateWithoutArticleInput, ArticleDocumentUncheckedCreateWithoutArticleInput>
  }

  export type ArticleDocumentUpdateWithWhereUniqueWithoutArticleInput = {
    where: ArticleDocumentWhereUniqueInput
    data: XOR<ArticleDocumentUpdateWithoutArticleInput, ArticleDocumentUncheckedUpdateWithoutArticleInput>
  }

  export type ArticleDocumentUpdateManyWithWhereWithoutArticleInput = {
    where: ArticleDocumentScalarWhereInput
    data: XOR<ArticleDocumentUpdateManyMutationInput, ArticleDocumentUncheckedUpdateManyWithoutArticleDocumentsInput>
  }

  export type ArticleCommentUpsertWithWhereUniqueWithoutArticleInput = {
    where: ArticleCommentWhereUniqueInput
    update: XOR<ArticleCommentUpdateWithoutArticleInput, ArticleCommentUncheckedUpdateWithoutArticleInput>
    create: XOR<ArticleCommentCreateWithoutArticleInput, ArticleCommentUncheckedCreateWithoutArticleInput>
  }

  export type ArticleCommentUpdateWithWhereUniqueWithoutArticleInput = {
    where: ArticleCommentWhereUniqueInput
    data: XOR<ArticleCommentUpdateWithoutArticleInput, ArticleCommentUncheckedUpdateWithoutArticleInput>
  }

  export type ArticleCommentUpdateManyWithWhereWithoutArticleInput = {
    where: ArticleCommentScalarWhereInput
    data: XOR<ArticleCommentUpdateManyMutationInput, ArticleCommentUncheckedUpdateManyWithoutArticleCommentsInput>
  }

  export type Article_HardwareUpsertWithWhereUniqueWithoutArticleInput = {
    where: Article_HardwareWhereUniqueInput
    update: XOR<Article_HardwareUpdateWithoutArticleInput, Article_HardwareUncheckedUpdateWithoutArticleInput>
    create: XOR<Article_HardwareCreateWithoutArticleInput, Article_HardwareUncheckedCreateWithoutArticleInput>
  }

  export type Article_HardwareUpdateWithWhereUniqueWithoutArticleInput = {
    where: Article_HardwareWhereUniqueInput
    data: XOR<Article_HardwareUpdateWithoutArticleInput, Article_HardwareUncheckedUpdateWithoutArticleInput>
  }

  export type Article_HardwareUpdateManyWithWhereWithoutArticleInput = {
    where: Article_HardwareScalarWhereInput
    data: XOR<Article_HardwareUpdateManyMutationInput, Article_HardwareUncheckedUpdateManyWithoutArticle_hardwareInput>
  }

  export type UserCreateWithoutHardwaresInput = {
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    role: RoleCreateNestedOneWithoutUsersInput
    articles?: ArticleCreateNestedManyWithoutUserInput
    articleDocuments?: ArticleDocumentCreateNestedManyWithoutUserInput
    articleComments?: ArticleCommentCreateNestedManyWithoutUserInput
    hardwareDocuments?: HardwareDocumentCreateNestedManyWithoutUserInput
    hardwareComments?: HardwareCommentCreateNestedManyWithoutUserInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutUserInput
    hardware_hardware?: Hardware_HardwareCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHardwaresInput = {
    id?: number
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    roleId: number
    articles?: ArticleUncheckedCreateNestedManyWithoutUserInput
    articleDocuments?: ArticleDocumentUncheckedCreateNestedManyWithoutUserInput
    articleComments?: ArticleCommentUncheckedCreateNestedManyWithoutUserInput
    hardwareDocuments?: HardwareDocumentUncheckedCreateNestedManyWithoutUserInput
    hardwareComments?: HardwareCommentUncheckedCreateNestedManyWithoutUserInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutUserInput
    hardware_hardware?: Hardware_HardwareUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHardwaresInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHardwaresInput, UserUncheckedCreateWithoutHardwaresInput>
  }

  export type HardwareTypeCreateWithoutHardwaresInput = {
    type: string
  }

  export type HardwareTypeUncheckedCreateWithoutHardwaresInput = {
    id?: number
    type: string
  }

  export type HardwareTypeCreateOrConnectWithoutHardwaresInput = {
    where: HardwareTypeWhereUniqueInput
    create: XOR<HardwareTypeCreateWithoutHardwaresInput, HardwareTypeUncheckedCreateWithoutHardwaresInput>
  }

  export type HardwareDocumentCreateWithoutHardwareInput = {
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    documentType: DocumentTypeCreateNestedOneWithoutHardwareDocumentInput
    user: UserCreateNestedOneWithoutHardwareDocumentsInput
  }

  export type HardwareDocumentUncheckedCreateWithoutHardwareInput = {
    id?: number
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    documentTypeId: number
    userId: number
  }

  export type HardwareDocumentCreateOrConnectWithoutHardwareInput = {
    where: HardwareDocumentWhereUniqueInput
    create: XOR<HardwareDocumentCreateWithoutHardwareInput, HardwareDocumentUncheckedCreateWithoutHardwareInput>
  }

  export type HardwareDocumentCreateManyHardwareInputEnvelope = {
    data: Enumerable<HardwareDocumentCreateManyHardwareInput>
    skipDuplicates?: boolean
  }

  export type HardwareCommentCreateWithoutHardwareInput = {
    content: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    user: UserCreateNestedOneWithoutHardwareCommentsInput
  }

  export type HardwareCommentUncheckedCreateWithoutHardwareInput = {
    id?: number
    content: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    userId: number
  }

  export type HardwareCommentCreateOrConnectWithoutHardwareInput = {
    where: HardwareCommentWhereUniqueInput
    create: XOR<HardwareCommentCreateWithoutHardwareInput, HardwareCommentUncheckedCreateWithoutHardwareInput>
  }

  export type HardwareCommentCreateManyHardwareInputEnvelope = {
    data: Enumerable<HardwareCommentCreateManyHardwareInput>
    skipDuplicates?: boolean
  }

  export type Article_HardwareCreateWithoutHardwareInput = {
    assigneddAt?: Date | string
    article: ArticleCreateNestedOneWithoutArticle_hardwareInput
    user: UserCreateNestedOneWithoutArticle_hardwareInput
  }

  export type Article_HardwareUncheckedCreateWithoutHardwareInput = {
    assigneddAt?: Date | string
    articleId: number
    userId: number
  }

  export type Article_HardwareCreateOrConnectWithoutHardwareInput = {
    where: Article_HardwareWhereUniqueInput
    create: XOR<Article_HardwareCreateWithoutHardwareInput, Article_HardwareUncheckedCreateWithoutHardwareInput>
  }

  export type Article_HardwareCreateManyHardwareInputEnvelope = {
    data: Enumerable<Article_HardwareCreateManyHardwareInput>
    skipDuplicates?: boolean
  }

  export type Hardware_HardwareCreateWithoutFirstHardwareInput = {
    assigneddAt?: Date | string
    secondHardware: HardwareCreateNestedOneWithoutSecondHardwaresInput
    user: UserCreateNestedOneWithoutHardware_hardwareInput
  }

  export type Hardware_HardwareUncheckedCreateWithoutFirstHardwareInput = {
    assigneddAt?: Date | string
    secondHardwareId: number
    userId: number
  }

  export type Hardware_HardwareCreateOrConnectWithoutFirstHardwareInput = {
    where: Hardware_HardwareWhereUniqueInput
    create: XOR<Hardware_HardwareCreateWithoutFirstHardwareInput, Hardware_HardwareUncheckedCreateWithoutFirstHardwareInput>
  }

  export type Hardware_HardwareCreateManyFirstHardwareInputEnvelope = {
    data: Enumerable<Hardware_HardwareCreateManyFirstHardwareInput>
    skipDuplicates?: boolean
  }

  export type Hardware_HardwareCreateWithoutSecondHardwareInput = {
    assigneddAt?: Date | string
    firstHardware: HardwareCreateNestedOneWithoutFirstHardwareOfInput
    user: UserCreateNestedOneWithoutHardware_hardwareInput
  }

  export type Hardware_HardwareUncheckedCreateWithoutSecondHardwareInput = {
    assigneddAt?: Date | string
    firstHardwareId: number
    userId: number
  }

  export type Hardware_HardwareCreateOrConnectWithoutSecondHardwareInput = {
    where: Hardware_HardwareWhereUniqueInput
    create: XOR<Hardware_HardwareCreateWithoutSecondHardwareInput, Hardware_HardwareUncheckedCreateWithoutSecondHardwareInput>
  }

  export type Hardware_HardwareCreateManySecondHardwareInputEnvelope = {
    data: Enumerable<Hardware_HardwareCreateManySecondHardwareInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutHardwaresInput = {
    update: XOR<UserUpdateWithoutHardwaresInput, UserUncheckedUpdateWithoutHardwaresInput>
    create: XOR<UserCreateWithoutHardwaresInput, UserUncheckedCreateWithoutHardwaresInput>
  }

  export type UserUpdateWithoutHardwaresInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    articles?: ArticleUpdateManyWithoutUserNestedInput
    articleDocuments?: ArticleDocumentUpdateManyWithoutUserNestedInput
    articleComments?: ArticleCommentUpdateManyWithoutUserNestedInput
    hardwareDocuments?: HardwareDocumentUpdateManyWithoutUserNestedInput
    hardwareComments?: HardwareCommentUpdateManyWithoutUserNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutUserNestedInput
    hardware_hardware?: Hardware_HardwareUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHardwaresInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    articles?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    articleDocuments?: ArticleDocumentUncheckedUpdateManyWithoutUserNestedInput
    articleComments?: ArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    hardwareDocuments?: HardwareDocumentUncheckedUpdateManyWithoutUserNestedInput
    hardwareComments?: HardwareCommentUncheckedUpdateManyWithoutUserNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutUserNestedInput
    hardware_hardware?: Hardware_HardwareUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HardwareTypeUpsertWithoutHardwaresInput = {
    update: XOR<HardwareTypeUpdateWithoutHardwaresInput, HardwareTypeUncheckedUpdateWithoutHardwaresInput>
    create: XOR<HardwareTypeCreateWithoutHardwaresInput, HardwareTypeUncheckedCreateWithoutHardwaresInput>
  }

  export type HardwareTypeUpdateWithoutHardwaresInput = {
    type?: StringFieldUpdateOperationsInput | string
  }

  export type HardwareTypeUncheckedUpdateWithoutHardwaresInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type HardwareDocumentUpsertWithWhereUniqueWithoutHardwareInput = {
    where: HardwareDocumentWhereUniqueInput
    update: XOR<HardwareDocumentUpdateWithoutHardwareInput, HardwareDocumentUncheckedUpdateWithoutHardwareInput>
    create: XOR<HardwareDocumentCreateWithoutHardwareInput, HardwareDocumentUncheckedCreateWithoutHardwareInput>
  }

  export type HardwareDocumentUpdateWithWhereUniqueWithoutHardwareInput = {
    where: HardwareDocumentWhereUniqueInput
    data: XOR<HardwareDocumentUpdateWithoutHardwareInput, HardwareDocumentUncheckedUpdateWithoutHardwareInput>
  }

  export type HardwareDocumentUpdateManyWithWhereWithoutHardwareInput = {
    where: HardwareDocumentScalarWhereInput
    data: XOR<HardwareDocumentUpdateManyMutationInput, HardwareDocumentUncheckedUpdateManyWithoutHardwareDocumentsInput>
  }

  export type HardwareCommentUpsertWithWhereUniqueWithoutHardwareInput = {
    where: HardwareCommentWhereUniqueInput
    update: XOR<HardwareCommentUpdateWithoutHardwareInput, HardwareCommentUncheckedUpdateWithoutHardwareInput>
    create: XOR<HardwareCommentCreateWithoutHardwareInput, HardwareCommentUncheckedCreateWithoutHardwareInput>
  }

  export type HardwareCommentUpdateWithWhereUniqueWithoutHardwareInput = {
    where: HardwareCommentWhereUniqueInput
    data: XOR<HardwareCommentUpdateWithoutHardwareInput, HardwareCommentUncheckedUpdateWithoutHardwareInput>
  }

  export type HardwareCommentUpdateManyWithWhereWithoutHardwareInput = {
    where: HardwareCommentScalarWhereInput
    data: XOR<HardwareCommentUpdateManyMutationInput, HardwareCommentUncheckedUpdateManyWithoutHardwareCommentsInput>
  }

  export type Article_HardwareUpsertWithWhereUniqueWithoutHardwareInput = {
    where: Article_HardwareWhereUniqueInput
    update: XOR<Article_HardwareUpdateWithoutHardwareInput, Article_HardwareUncheckedUpdateWithoutHardwareInput>
    create: XOR<Article_HardwareCreateWithoutHardwareInput, Article_HardwareUncheckedCreateWithoutHardwareInput>
  }

  export type Article_HardwareUpdateWithWhereUniqueWithoutHardwareInput = {
    where: Article_HardwareWhereUniqueInput
    data: XOR<Article_HardwareUpdateWithoutHardwareInput, Article_HardwareUncheckedUpdateWithoutHardwareInput>
  }

  export type Article_HardwareUpdateManyWithWhereWithoutHardwareInput = {
    where: Article_HardwareScalarWhereInput
    data: XOR<Article_HardwareUpdateManyMutationInput, Article_HardwareUncheckedUpdateManyWithoutArticle_hardwareInput>
  }

  export type Hardware_HardwareUpsertWithWhereUniqueWithoutFirstHardwareInput = {
    where: Hardware_HardwareWhereUniqueInput
    update: XOR<Hardware_HardwareUpdateWithoutFirstHardwareInput, Hardware_HardwareUncheckedUpdateWithoutFirstHardwareInput>
    create: XOR<Hardware_HardwareCreateWithoutFirstHardwareInput, Hardware_HardwareUncheckedCreateWithoutFirstHardwareInput>
  }

  export type Hardware_HardwareUpdateWithWhereUniqueWithoutFirstHardwareInput = {
    where: Hardware_HardwareWhereUniqueInput
    data: XOR<Hardware_HardwareUpdateWithoutFirstHardwareInput, Hardware_HardwareUncheckedUpdateWithoutFirstHardwareInput>
  }

  export type Hardware_HardwareUpdateManyWithWhereWithoutFirstHardwareInput = {
    where: Hardware_HardwareScalarWhereInput
    data: XOR<Hardware_HardwareUpdateManyMutationInput, Hardware_HardwareUncheckedUpdateManyWithoutFirstHardwareOfInput>
  }

  export type Hardware_HardwareUpsertWithWhereUniqueWithoutSecondHardwareInput = {
    where: Hardware_HardwareWhereUniqueInput
    update: XOR<Hardware_HardwareUpdateWithoutSecondHardwareInput, Hardware_HardwareUncheckedUpdateWithoutSecondHardwareInput>
    create: XOR<Hardware_HardwareCreateWithoutSecondHardwareInput, Hardware_HardwareUncheckedCreateWithoutSecondHardwareInput>
  }

  export type Hardware_HardwareUpdateWithWhereUniqueWithoutSecondHardwareInput = {
    where: Hardware_HardwareWhereUniqueInput
    data: XOR<Hardware_HardwareUpdateWithoutSecondHardwareInput, Hardware_HardwareUncheckedUpdateWithoutSecondHardwareInput>
  }

  export type Hardware_HardwareUpdateManyWithWhereWithoutSecondHardwareInput = {
    where: Hardware_HardwareScalarWhereInput
    data: XOR<Hardware_HardwareUpdateManyMutationInput, Hardware_HardwareUncheckedUpdateManyWithoutSecondHardwaresInput>
  }

  export type DocumentTypeCreateWithoutArticleDocumentsInput = {
    type: string
    hardwareDocument?: HardwareDocumentCreateNestedManyWithoutDocumentTypeInput
  }

  export type DocumentTypeUncheckedCreateWithoutArticleDocumentsInput = {
    id?: number
    type: string
    hardwareDocument?: HardwareDocumentUncheckedCreateNestedManyWithoutDocumentTypeInput
  }

  export type DocumentTypeCreateOrConnectWithoutArticleDocumentsInput = {
    where: DocumentTypeWhereUniqueInput
    create: XOR<DocumentTypeCreateWithoutArticleDocumentsInput, DocumentTypeUncheckedCreateWithoutArticleDocumentsInput>
  }

  export type UserCreateWithoutArticleDocumentsInput = {
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    role: RoleCreateNestedOneWithoutUsersInput
    articles?: ArticleCreateNestedManyWithoutUserInput
    articleComments?: ArticleCommentCreateNestedManyWithoutUserInput
    hardwares?: HardwareCreateNestedManyWithoutUserInput
    hardwareDocuments?: HardwareDocumentCreateNestedManyWithoutUserInput
    hardwareComments?: HardwareCommentCreateNestedManyWithoutUserInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutUserInput
    hardware_hardware?: Hardware_HardwareCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutArticleDocumentsInput = {
    id?: number
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    roleId: number
    articles?: ArticleUncheckedCreateNestedManyWithoutUserInput
    articleComments?: ArticleCommentUncheckedCreateNestedManyWithoutUserInput
    hardwares?: HardwareUncheckedCreateNestedManyWithoutUserInput
    hardwareDocuments?: HardwareDocumentUncheckedCreateNestedManyWithoutUserInput
    hardwareComments?: HardwareCommentUncheckedCreateNestedManyWithoutUserInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutUserInput
    hardware_hardware?: Hardware_HardwareUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutArticleDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutArticleDocumentsInput, UserUncheckedCreateWithoutArticleDocumentsInput>
  }

  export type ArticleCreateWithoutArticleDocumentsInput = {
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    user: UserCreateNestedOneWithoutArticlesInput
    articleType: ArticleTypeCreateNestedOneWithoutArticlesInput
    article?: ArticleCreateNestedOneWithoutArticlesInput
    articles?: ArticleCreateNestedManyWithoutArticleInput
    articleComments?: ArticleCommentCreateNestedManyWithoutArticleInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutArticleDocumentsInput = {
    id?: number
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    userId: number
    articleTypeId: number
    articleId?: number | null
    articles?: ArticleUncheckedCreateNestedManyWithoutArticleInput
    articleComments?: ArticleCommentUncheckedCreateNestedManyWithoutArticleInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutArticleDocumentsInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutArticleDocumentsInput, ArticleUncheckedCreateWithoutArticleDocumentsInput>
  }

  export type DocumentTypeUpsertWithoutArticleDocumentsInput = {
    update: XOR<DocumentTypeUpdateWithoutArticleDocumentsInput, DocumentTypeUncheckedUpdateWithoutArticleDocumentsInput>
    create: XOR<DocumentTypeCreateWithoutArticleDocumentsInput, DocumentTypeUncheckedCreateWithoutArticleDocumentsInput>
  }

  export type DocumentTypeUpdateWithoutArticleDocumentsInput = {
    type?: StringFieldUpdateOperationsInput | string
    hardwareDocument?: HardwareDocumentUpdateManyWithoutDocumentTypeNestedInput
  }

  export type DocumentTypeUncheckedUpdateWithoutArticleDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    hardwareDocument?: HardwareDocumentUncheckedUpdateManyWithoutDocumentTypeNestedInput
  }

  export type UserUpsertWithoutArticleDocumentsInput = {
    update: XOR<UserUpdateWithoutArticleDocumentsInput, UserUncheckedUpdateWithoutArticleDocumentsInput>
    create: XOR<UserCreateWithoutArticleDocumentsInput, UserUncheckedCreateWithoutArticleDocumentsInput>
  }

  export type UserUpdateWithoutArticleDocumentsInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    articles?: ArticleUpdateManyWithoutUserNestedInput
    articleComments?: ArticleCommentUpdateManyWithoutUserNestedInput
    hardwares?: HardwareUpdateManyWithoutUserNestedInput
    hardwareDocuments?: HardwareDocumentUpdateManyWithoutUserNestedInput
    hardwareComments?: HardwareCommentUpdateManyWithoutUserNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutUserNestedInput
    hardware_hardware?: Hardware_HardwareUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutArticleDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    articles?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    articleComments?: ArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    hardwares?: HardwareUncheckedUpdateManyWithoutUserNestedInput
    hardwareDocuments?: HardwareDocumentUncheckedUpdateManyWithoutUserNestedInput
    hardwareComments?: HardwareCommentUncheckedUpdateManyWithoutUserNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutUserNestedInput
    hardware_hardware?: Hardware_HardwareUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ArticleUpsertWithoutArticleDocumentsInput = {
    update: XOR<ArticleUpdateWithoutArticleDocumentsInput, ArticleUncheckedUpdateWithoutArticleDocumentsInput>
    create: XOR<ArticleCreateWithoutArticleDocumentsInput, ArticleUncheckedCreateWithoutArticleDocumentsInput>
  }

  export type ArticleUpdateWithoutArticleDocumentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutArticlesNestedInput
    articleType?: ArticleTypeUpdateOneRequiredWithoutArticlesNestedInput
    article?: ArticleUpdateOneWithoutArticlesNestedInput
    articles?: ArticleUpdateManyWithoutArticleNestedInput
    articleComments?: ArticleCommentUpdateManyWithoutArticleNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutArticleDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    articleTypeId?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    articles?: ArticleUncheckedUpdateManyWithoutArticleNestedInput
    articleComments?: ArticleCommentUncheckedUpdateManyWithoutArticleNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type UserCreateWithoutArticleCommentsInput = {
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    role: RoleCreateNestedOneWithoutUsersInput
    articles?: ArticleCreateNestedManyWithoutUserInput
    articleDocuments?: ArticleDocumentCreateNestedManyWithoutUserInput
    hardwares?: HardwareCreateNestedManyWithoutUserInput
    hardwareDocuments?: HardwareDocumentCreateNestedManyWithoutUserInput
    hardwareComments?: HardwareCommentCreateNestedManyWithoutUserInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutUserInput
    hardware_hardware?: Hardware_HardwareCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutArticleCommentsInput = {
    id?: number
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    roleId: number
    articles?: ArticleUncheckedCreateNestedManyWithoutUserInput
    articleDocuments?: ArticleDocumentUncheckedCreateNestedManyWithoutUserInput
    hardwares?: HardwareUncheckedCreateNestedManyWithoutUserInput
    hardwareDocuments?: HardwareDocumentUncheckedCreateNestedManyWithoutUserInput
    hardwareComments?: HardwareCommentUncheckedCreateNestedManyWithoutUserInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutUserInput
    hardware_hardware?: Hardware_HardwareUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutArticleCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutArticleCommentsInput, UserUncheckedCreateWithoutArticleCommentsInput>
  }

  export type ArticleCreateWithoutArticleCommentsInput = {
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    user: UserCreateNestedOneWithoutArticlesInput
    articleType: ArticleTypeCreateNestedOneWithoutArticlesInput
    article?: ArticleCreateNestedOneWithoutArticlesInput
    articles?: ArticleCreateNestedManyWithoutArticleInput
    articleDocuments?: ArticleDocumentCreateNestedManyWithoutArticleInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutArticleCommentsInput = {
    id?: number
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    userId: number
    articleTypeId: number
    articleId?: number | null
    articles?: ArticleUncheckedCreateNestedManyWithoutArticleInput
    articleDocuments?: ArticleDocumentUncheckedCreateNestedManyWithoutArticleInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutArticleCommentsInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutArticleCommentsInput, ArticleUncheckedCreateWithoutArticleCommentsInput>
  }

  export type UserUpsertWithoutArticleCommentsInput = {
    update: XOR<UserUpdateWithoutArticleCommentsInput, UserUncheckedUpdateWithoutArticleCommentsInput>
    create: XOR<UserCreateWithoutArticleCommentsInput, UserUncheckedCreateWithoutArticleCommentsInput>
  }

  export type UserUpdateWithoutArticleCommentsInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    articles?: ArticleUpdateManyWithoutUserNestedInput
    articleDocuments?: ArticleDocumentUpdateManyWithoutUserNestedInput
    hardwares?: HardwareUpdateManyWithoutUserNestedInput
    hardwareDocuments?: HardwareDocumentUpdateManyWithoutUserNestedInput
    hardwareComments?: HardwareCommentUpdateManyWithoutUserNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutUserNestedInput
    hardware_hardware?: Hardware_HardwareUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutArticleCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    articles?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    articleDocuments?: ArticleDocumentUncheckedUpdateManyWithoutUserNestedInput
    hardwares?: HardwareUncheckedUpdateManyWithoutUserNestedInput
    hardwareDocuments?: HardwareDocumentUncheckedUpdateManyWithoutUserNestedInput
    hardwareComments?: HardwareCommentUncheckedUpdateManyWithoutUserNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutUserNestedInput
    hardware_hardware?: Hardware_HardwareUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ArticleUpsertWithoutArticleCommentsInput = {
    update: XOR<ArticleUpdateWithoutArticleCommentsInput, ArticleUncheckedUpdateWithoutArticleCommentsInput>
    create: XOR<ArticleCreateWithoutArticleCommentsInput, ArticleUncheckedCreateWithoutArticleCommentsInput>
  }

  export type ArticleUpdateWithoutArticleCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutArticlesNestedInput
    articleType?: ArticleTypeUpdateOneRequiredWithoutArticlesNestedInput
    article?: ArticleUpdateOneWithoutArticlesNestedInput
    articles?: ArticleUpdateManyWithoutArticleNestedInput
    articleDocuments?: ArticleDocumentUpdateManyWithoutArticleNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutArticleCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    articleTypeId?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    articles?: ArticleUncheckedUpdateManyWithoutArticleNestedInput
    articleDocuments?: ArticleDocumentUncheckedUpdateManyWithoutArticleNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type DocumentTypeCreateWithoutHardwareDocumentInput = {
    type: string
    articleDocuments?: ArticleDocumentCreateNestedManyWithoutDocumentTypeInput
  }

  export type DocumentTypeUncheckedCreateWithoutHardwareDocumentInput = {
    id?: number
    type: string
    articleDocuments?: ArticleDocumentUncheckedCreateNestedManyWithoutDocumentTypeInput
  }

  export type DocumentTypeCreateOrConnectWithoutHardwareDocumentInput = {
    where: DocumentTypeWhereUniqueInput
    create: XOR<DocumentTypeCreateWithoutHardwareDocumentInput, DocumentTypeUncheckedCreateWithoutHardwareDocumentInput>
  }

  export type UserCreateWithoutHardwareDocumentsInput = {
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    role: RoleCreateNestedOneWithoutUsersInput
    articles?: ArticleCreateNestedManyWithoutUserInput
    articleDocuments?: ArticleDocumentCreateNestedManyWithoutUserInput
    articleComments?: ArticleCommentCreateNestedManyWithoutUserInput
    hardwares?: HardwareCreateNestedManyWithoutUserInput
    hardwareComments?: HardwareCommentCreateNestedManyWithoutUserInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutUserInput
    hardware_hardware?: Hardware_HardwareCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHardwareDocumentsInput = {
    id?: number
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    roleId: number
    articles?: ArticleUncheckedCreateNestedManyWithoutUserInput
    articleDocuments?: ArticleDocumentUncheckedCreateNestedManyWithoutUserInput
    articleComments?: ArticleCommentUncheckedCreateNestedManyWithoutUserInput
    hardwares?: HardwareUncheckedCreateNestedManyWithoutUserInput
    hardwareComments?: HardwareCommentUncheckedCreateNestedManyWithoutUserInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutUserInput
    hardware_hardware?: Hardware_HardwareUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHardwareDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHardwareDocumentsInput, UserUncheckedCreateWithoutHardwareDocumentsInput>
  }

  export type HardwareCreateWithoutHardwareDocumentsInput = {
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    user: UserCreateNestedOneWithoutHardwaresInput
    hardwareType: HardwareTypeCreateNestedOneWithoutHardwaresInput
    hardwareComments?: HardwareCommentCreateNestedManyWithoutHardwareInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutHardwareInput
    firstHardwareOf?: Hardware_HardwareCreateNestedManyWithoutFirstHardwareInput
    secondHardwares?: Hardware_HardwareCreateNestedManyWithoutSecondHardwareInput
  }

  export type HardwareUncheckedCreateWithoutHardwareDocumentsInput = {
    id?: number
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    userId: number
    hardwareTypeId: number
    hardwareComments?: HardwareCommentUncheckedCreateNestedManyWithoutHardwareInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutHardwareInput
    firstHardwareOf?: Hardware_HardwareUncheckedCreateNestedManyWithoutFirstHardwareInput
    secondHardwares?: Hardware_HardwareUncheckedCreateNestedManyWithoutSecondHardwareInput
  }

  export type HardwareCreateOrConnectWithoutHardwareDocumentsInput = {
    where: HardwareWhereUniqueInput
    create: XOR<HardwareCreateWithoutHardwareDocumentsInput, HardwareUncheckedCreateWithoutHardwareDocumentsInput>
  }

  export type DocumentTypeUpsertWithoutHardwareDocumentInput = {
    update: XOR<DocumentTypeUpdateWithoutHardwareDocumentInput, DocumentTypeUncheckedUpdateWithoutHardwareDocumentInput>
    create: XOR<DocumentTypeCreateWithoutHardwareDocumentInput, DocumentTypeUncheckedCreateWithoutHardwareDocumentInput>
  }

  export type DocumentTypeUpdateWithoutHardwareDocumentInput = {
    type?: StringFieldUpdateOperationsInput | string
    articleDocuments?: ArticleDocumentUpdateManyWithoutDocumentTypeNestedInput
  }

  export type DocumentTypeUncheckedUpdateWithoutHardwareDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    articleDocuments?: ArticleDocumentUncheckedUpdateManyWithoutDocumentTypeNestedInput
  }

  export type UserUpsertWithoutHardwareDocumentsInput = {
    update: XOR<UserUpdateWithoutHardwareDocumentsInput, UserUncheckedUpdateWithoutHardwareDocumentsInput>
    create: XOR<UserCreateWithoutHardwareDocumentsInput, UserUncheckedCreateWithoutHardwareDocumentsInput>
  }

  export type UserUpdateWithoutHardwareDocumentsInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    articles?: ArticleUpdateManyWithoutUserNestedInput
    articleDocuments?: ArticleDocumentUpdateManyWithoutUserNestedInput
    articleComments?: ArticleCommentUpdateManyWithoutUserNestedInput
    hardwares?: HardwareUpdateManyWithoutUserNestedInput
    hardwareComments?: HardwareCommentUpdateManyWithoutUserNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutUserNestedInput
    hardware_hardware?: Hardware_HardwareUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHardwareDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    articles?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    articleDocuments?: ArticleDocumentUncheckedUpdateManyWithoutUserNestedInput
    articleComments?: ArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    hardwares?: HardwareUncheckedUpdateManyWithoutUserNestedInput
    hardwareComments?: HardwareCommentUncheckedUpdateManyWithoutUserNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutUserNestedInput
    hardware_hardware?: Hardware_HardwareUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HardwareUpsertWithoutHardwareDocumentsInput = {
    update: XOR<HardwareUpdateWithoutHardwareDocumentsInput, HardwareUncheckedUpdateWithoutHardwareDocumentsInput>
    create: XOR<HardwareCreateWithoutHardwareDocumentsInput, HardwareUncheckedCreateWithoutHardwareDocumentsInput>
  }

  export type HardwareUpdateWithoutHardwareDocumentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
    user?: UserUpdateOneRequiredWithoutHardwaresNestedInput
    hardwareType?: HardwareTypeUpdateOneRequiredWithoutHardwaresNestedInput
    hardwareComments?: HardwareCommentUpdateManyWithoutHardwareNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutHardwareNestedInput
    firstHardwareOf?: Hardware_HardwareUpdateManyWithoutFirstHardwareNestedInput
    secondHardwares?: Hardware_HardwareUpdateManyWithoutSecondHardwareNestedInput
  }

  export type HardwareUncheckedUpdateWithoutHardwareDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
    userId?: IntFieldUpdateOperationsInput | number
    hardwareTypeId?: IntFieldUpdateOperationsInput | number
    hardwareComments?: HardwareCommentUncheckedUpdateManyWithoutHardwareNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutHardwareNestedInput
    firstHardwareOf?: Hardware_HardwareUncheckedUpdateManyWithoutFirstHardwareNestedInput
    secondHardwares?: Hardware_HardwareUncheckedUpdateManyWithoutSecondHardwareNestedInput
  }

  export type UserCreateWithoutHardwareCommentsInput = {
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    role: RoleCreateNestedOneWithoutUsersInput
    articles?: ArticleCreateNestedManyWithoutUserInput
    articleDocuments?: ArticleDocumentCreateNestedManyWithoutUserInput
    articleComments?: ArticleCommentCreateNestedManyWithoutUserInput
    hardwares?: HardwareCreateNestedManyWithoutUserInput
    hardwareDocuments?: HardwareDocumentCreateNestedManyWithoutUserInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutUserInput
    hardware_hardware?: Hardware_HardwareCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHardwareCommentsInput = {
    id?: number
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    roleId: number
    articles?: ArticleUncheckedCreateNestedManyWithoutUserInput
    articleDocuments?: ArticleDocumentUncheckedCreateNestedManyWithoutUserInput
    articleComments?: ArticleCommentUncheckedCreateNestedManyWithoutUserInput
    hardwares?: HardwareUncheckedCreateNestedManyWithoutUserInput
    hardwareDocuments?: HardwareDocumentUncheckedCreateNestedManyWithoutUserInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutUserInput
    hardware_hardware?: Hardware_HardwareUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHardwareCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHardwareCommentsInput, UserUncheckedCreateWithoutHardwareCommentsInput>
  }

  export type HardwareCreateWithoutHardwareCommentsInput = {
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    user: UserCreateNestedOneWithoutHardwaresInput
    hardwareType: HardwareTypeCreateNestedOneWithoutHardwaresInput
    hardwareDocuments?: HardwareDocumentCreateNestedManyWithoutHardwareInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutHardwareInput
    firstHardwareOf?: Hardware_HardwareCreateNestedManyWithoutFirstHardwareInput
    secondHardwares?: Hardware_HardwareCreateNestedManyWithoutSecondHardwareInput
  }

  export type HardwareUncheckedCreateWithoutHardwareCommentsInput = {
    id?: number
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    userId: number
    hardwareTypeId: number
    hardwareDocuments?: HardwareDocumentUncheckedCreateNestedManyWithoutHardwareInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutHardwareInput
    firstHardwareOf?: Hardware_HardwareUncheckedCreateNestedManyWithoutFirstHardwareInput
    secondHardwares?: Hardware_HardwareUncheckedCreateNestedManyWithoutSecondHardwareInput
  }

  export type HardwareCreateOrConnectWithoutHardwareCommentsInput = {
    where: HardwareWhereUniqueInput
    create: XOR<HardwareCreateWithoutHardwareCommentsInput, HardwareUncheckedCreateWithoutHardwareCommentsInput>
  }

  export type UserUpsertWithoutHardwareCommentsInput = {
    update: XOR<UserUpdateWithoutHardwareCommentsInput, UserUncheckedUpdateWithoutHardwareCommentsInput>
    create: XOR<UserCreateWithoutHardwareCommentsInput, UserUncheckedCreateWithoutHardwareCommentsInput>
  }

  export type UserUpdateWithoutHardwareCommentsInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    articles?: ArticleUpdateManyWithoutUserNestedInput
    articleDocuments?: ArticleDocumentUpdateManyWithoutUserNestedInput
    articleComments?: ArticleCommentUpdateManyWithoutUserNestedInput
    hardwares?: HardwareUpdateManyWithoutUserNestedInput
    hardwareDocuments?: HardwareDocumentUpdateManyWithoutUserNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutUserNestedInput
    hardware_hardware?: Hardware_HardwareUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHardwareCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    articles?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    articleDocuments?: ArticleDocumentUncheckedUpdateManyWithoutUserNestedInput
    articleComments?: ArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    hardwares?: HardwareUncheckedUpdateManyWithoutUserNestedInput
    hardwareDocuments?: HardwareDocumentUncheckedUpdateManyWithoutUserNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutUserNestedInput
    hardware_hardware?: Hardware_HardwareUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HardwareUpsertWithoutHardwareCommentsInput = {
    update: XOR<HardwareUpdateWithoutHardwareCommentsInput, HardwareUncheckedUpdateWithoutHardwareCommentsInput>
    create: XOR<HardwareCreateWithoutHardwareCommentsInput, HardwareUncheckedCreateWithoutHardwareCommentsInput>
  }

  export type HardwareUpdateWithoutHardwareCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
    user?: UserUpdateOneRequiredWithoutHardwaresNestedInput
    hardwareType?: HardwareTypeUpdateOneRequiredWithoutHardwaresNestedInput
    hardwareDocuments?: HardwareDocumentUpdateManyWithoutHardwareNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutHardwareNestedInput
    firstHardwareOf?: Hardware_HardwareUpdateManyWithoutFirstHardwareNestedInput
    secondHardwares?: Hardware_HardwareUpdateManyWithoutSecondHardwareNestedInput
  }

  export type HardwareUncheckedUpdateWithoutHardwareCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
    userId?: IntFieldUpdateOperationsInput | number
    hardwareTypeId?: IntFieldUpdateOperationsInput | number
    hardwareDocuments?: HardwareDocumentUncheckedUpdateManyWithoutHardwareNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutHardwareNestedInput
    firstHardwareOf?: Hardware_HardwareUncheckedUpdateManyWithoutFirstHardwareNestedInput
    secondHardwares?: Hardware_HardwareUncheckedUpdateManyWithoutSecondHardwareNestedInput
  }

  export type ArticleCreateWithoutArticle_hardwareInput = {
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    user: UserCreateNestedOneWithoutArticlesInput
    articleType: ArticleTypeCreateNestedOneWithoutArticlesInput
    article?: ArticleCreateNestedOneWithoutArticlesInput
    articles?: ArticleCreateNestedManyWithoutArticleInput
    articleDocuments?: ArticleDocumentCreateNestedManyWithoutArticleInput
    articleComments?: ArticleCommentCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutArticle_hardwareInput = {
    id?: number
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    userId: number
    articleTypeId: number
    articleId?: number | null
    articles?: ArticleUncheckedCreateNestedManyWithoutArticleInput
    articleDocuments?: ArticleDocumentUncheckedCreateNestedManyWithoutArticleInput
    articleComments?: ArticleCommentUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutArticle_hardwareInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutArticle_hardwareInput, ArticleUncheckedCreateWithoutArticle_hardwareInput>
  }

  export type HardwareCreateWithoutArticle_hardwareInput = {
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    user: UserCreateNestedOneWithoutHardwaresInput
    hardwareType: HardwareTypeCreateNestedOneWithoutHardwaresInput
    hardwareDocuments?: HardwareDocumentCreateNestedManyWithoutHardwareInput
    hardwareComments?: HardwareCommentCreateNestedManyWithoutHardwareInput
    firstHardwareOf?: Hardware_HardwareCreateNestedManyWithoutFirstHardwareInput
    secondHardwares?: Hardware_HardwareCreateNestedManyWithoutSecondHardwareInput
  }

  export type HardwareUncheckedCreateWithoutArticle_hardwareInput = {
    id?: number
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    userId: number
    hardwareTypeId: number
    hardwareDocuments?: HardwareDocumentUncheckedCreateNestedManyWithoutHardwareInput
    hardwareComments?: HardwareCommentUncheckedCreateNestedManyWithoutHardwareInput
    firstHardwareOf?: Hardware_HardwareUncheckedCreateNestedManyWithoutFirstHardwareInput
    secondHardwares?: Hardware_HardwareUncheckedCreateNestedManyWithoutSecondHardwareInput
  }

  export type HardwareCreateOrConnectWithoutArticle_hardwareInput = {
    where: HardwareWhereUniqueInput
    create: XOR<HardwareCreateWithoutArticle_hardwareInput, HardwareUncheckedCreateWithoutArticle_hardwareInput>
  }

  export type UserCreateWithoutArticle_hardwareInput = {
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    role: RoleCreateNestedOneWithoutUsersInput
    articles?: ArticleCreateNestedManyWithoutUserInput
    articleDocuments?: ArticleDocumentCreateNestedManyWithoutUserInput
    articleComments?: ArticleCommentCreateNestedManyWithoutUserInput
    hardwares?: HardwareCreateNestedManyWithoutUserInput
    hardwareDocuments?: HardwareDocumentCreateNestedManyWithoutUserInput
    hardwareComments?: HardwareCommentCreateNestedManyWithoutUserInput
    hardware_hardware?: Hardware_HardwareCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutArticle_hardwareInput = {
    id?: number
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    roleId: number
    articles?: ArticleUncheckedCreateNestedManyWithoutUserInput
    articleDocuments?: ArticleDocumentUncheckedCreateNestedManyWithoutUserInput
    articleComments?: ArticleCommentUncheckedCreateNestedManyWithoutUserInput
    hardwares?: HardwareUncheckedCreateNestedManyWithoutUserInput
    hardwareDocuments?: HardwareDocumentUncheckedCreateNestedManyWithoutUserInput
    hardwareComments?: HardwareCommentUncheckedCreateNestedManyWithoutUserInput
    hardware_hardware?: Hardware_HardwareUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutArticle_hardwareInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutArticle_hardwareInput, UserUncheckedCreateWithoutArticle_hardwareInput>
  }

  export type ArticleUpsertWithoutArticle_hardwareInput = {
    update: XOR<ArticleUpdateWithoutArticle_hardwareInput, ArticleUncheckedUpdateWithoutArticle_hardwareInput>
    create: XOR<ArticleCreateWithoutArticle_hardwareInput, ArticleUncheckedCreateWithoutArticle_hardwareInput>
  }

  export type ArticleUpdateWithoutArticle_hardwareInput = {
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutArticlesNestedInput
    articleType?: ArticleTypeUpdateOneRequiredWithoutArticlesNestedInput
    article?: ArticleUpdateOneWithoutArticlesNestedInput
    articles?: ArticleUpdateManyWithoutArticleNestedInput
    articleDocuments?: ArticleDocumentUpdateManyWithoutArticleNestedInput
    articleComments?: ArticleCommentUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutArticle_hardwareInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    articleTypeId?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    articles?: ArticleUncheckedUpdateManyWithoutArticleNestedInput
    articleDocuments?: ArticleDocumentUncheckedUpdateManyWithoutArticleNestedInput
    articleComments?: ArticleCommentUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type HardwareUpsertWithoutArticle_hardwareInput = {
    update: XOR<HardwareUpdateWithoutArticle_hardwareInput, HardwareUncheckedUpdateWithoutArticle_hardwareInput>
    create: XOR<HardwareCreateWithoutArticle_hardwareInput, HardwareUncheckedCreateWithoutArticle_hardwareInput>
  }

  export type HardwareUpdateWithoutArticle_hardwareInput = {
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
    user?: UserUpdateOneRequiredWithoutHardwaresNestedInput
    hardwareType?: HardwareTypeUpdateOneRequiredWithoutHardwaresNestedInput
    hardwareDocuments?: HardwareDocumentUpdateManyWithoutHardwareNestedInput
    hardwareComments?: HardwareCommentUpdateManyWithoutHardwareNestedInput
    firstHardwareOf?: Hardware_HardwareUpdateManyWithoutFirstHardwareNestedInput
    secondHardwares?: Hardware_HardwareUpdateManyWithoutSecondHardwareNestedInput
  }

  export type HardwareUncheckedUpdateWithoutArticle_hardwareInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
    userId?: IntFieldUpdateOperationsInput | number
    hardwareTypeId?: IntFieldUpdateOperationsInput | number
    hardwareDocuments?: HardwareDocumentUncheckedUpdateManyWithoutHardwareNestedInput
    hardwareComments?: HardwareCommentUncheckedUpdateManyWithoutHardwareNestedInput
    firstHardwareOf?: Hardware_HardwareUncheckedUpdateManyWithoutFirstHardwareNestedInput
    secondHardwares?: Hardware_HardwareUncheckedUpdateManyWithoutSecondHardwareNestedInput
  }

  export type UserUpsertWithoutArticle_hardwareInput = {
    update: XOR<UserUpdateWithoutArticle_hardwareInput, UserUncheckedUpdateWithoutArticle_hardwareInput>
    create: XOR<UserCreateWithoutArticle_hardwareInput, UserUncheckedCreateWithoutArticle_hardwareInput>
  }

  export type UserUpdateWithoutArticle_hardwareInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    articles?: ArticleUpdateManyWithoutUserNestedInput
    articleDocuments?: ArticleDocumentUpdateManyWithoutUserNestedInput
    articleComments?: ArticleCommentUpdateManyWithoutUserNestedInput
    hardwares?: HardwareUpdateManyWithoutUserNestedInput
    hardwareDocuments?: HardwareDocumentUpdateManyWithoutUserNestedInput
    hardwareComments?: HardwareCommentUpdateManyWithoutUserNestedInput
    hardware_hardware?: Hardware_HardwareUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutArticle_hardwareInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    articles?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    articleDocuments?: ArticleDocumentUncheckedUpdateManyWithoutUserNestedInput
    articleComments?: ArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    hardwares?: HardwareUncheckedUpdateManyWithoutUserNestedInput
    hardwareDocuments?: HardwareDocumentUncheckedUpdateManyWithoutUserNestedInput
    hardwareComments?: HardwareCommentUncheckedUpdateManyWithoutUserNestedInput
    hardware_hardware?: Hardware_HardwareUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HardwareCreateWithoutFirstHardwareOfInput = {
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    user: UserCreateNestedOneWithoutHardwaresInput
    hardwareType: HardwareTypeCreateNestedOneWithoutHardwaresInput
    hardwareDocuments?: HardwareDocumentCreateNestedManyWithoutHardwareInput
    hardwareComments?: HardwareCommentCreateNestedManyWithoutHardwareInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutHardwareInput
    secondHardwares?: Hardware_HardwareCreateNestedManyWithoutSecondHardwareInput
  }

  export type HardwareUncheckedCreateWithoutFirstHardwareOfInput = {
    id?: number
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    userId: number
    hardwareTypeId: number
    hardwareDocuments?: HardwareDocumentUncheckedCreateNestedManyWithoutHardwareInput
    hardwareComments?: HardwareCommentUncheckedCreateNestedManyWithoutHardwareInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutHardwareInput
    secondHardwares?: Hardware_HardwareUncheckedCreateNestedManyWithoutSecondHardwareInput
  }

  export type HardwareCreateOrConnectWithoutFirstHardwareOfInput = {
    where: HardwareWhereUniqueInput
    create: XOR<HardwareCreateWithoutFirstHardwareOfInput, HardwareUncheckedCreateWithoutFirstHardwareOfInput>
  }

  export type HardwareCreateWithoutSecondHardwaresInput = {
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    user: UserCreateNestedOneWithoutHardwaresInput
    hardwareType: HardwareTypeCreateNestedOneWithoutHardwaresInput
    hardwareDocuments?: HardwareDocumentCreateNestedManyWithoutHardwareInput
    hardwareComments?: HardwareCommentCreateNestedManyWithoutHardwareInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutHardwareInput
    firstHardwareOf?: Hardware_HardwareCreateNestedManyWithoutFirstHardwareInput
  }

  export type HardwareUncheckedCreateWithoutSecondHardwaresInput = {
    id?: number
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    userId: number
    hardwareTypeId: number
    hardwareDocuments?: HardwareDocumentUncheckedCreateNestedManyWithoutHardwareInput
    hardwareComments?: HardwareCommentUncheckedCreateNestedManyWithoutHardwareInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutHardwareInput
    firstHardwareOf?: Hardware_HardwareUncheckedCreateNestedManyWithoutFirstHardwareInput
  }

  export type HardwareCreateOrConnectWithoutSecondHardwaresInput = {
    where: HardwareWhereUniqueInput
    create: XOR<HardwareCreateWithoutSecondHardwaresInput, HardwareUncheckedCreateWithoutSecondHardwaresInput>
  }

  export type UserCreateWithoutHardware_hardwareInput = {
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    role: RoleCreateNestedOneWithoutUsersInput
    articles?: ArticleCreateNestedManyWithoutUserInput
    articleDocuments?: ArticleDocumentCreateNestedManyWithoutUserInput
    articleComments?: ArticleCommentCreateNestedManyWithoutUserInput
    hardwares?: HardwareCreateNestedManyWithoutUserInput
    hardwareDocuments?: HardwareDocumentCreateNestedManyWithoutUserInput
    hardwareComments?: HardwareCommentCreateNestedManyWithoutUserInput
    article_hardware?: Article_HardwareCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHardware_hardwareInput = {
    id?: number
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    roleId: number
    articles?: ArticleUncheckedCreateNestedManyWithoutUserInput
    articleDocuments?: ArticleDocumentUncheckedCreateNestedManyWithoutUserInput
    articleComments?: ArticleCommentUncheckedCreateNestedManyWithoutUserInput
    hardwares?: HardwareUncheckedCreateNestedManyWithoutUserInput
    hardwareDocuments?: HardwareDocumentUncheckedCreateNestedManyWithoutUserInput
    hardwareComments?: HardwareCommentUncheckedCreateNestedManyWithoutUserInput
    article_hardware?: Article_HardwareUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHardware_hardwareInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHardware_hardwareInput, UserUncheckedCreateWithoutHardware_hardwareInput>
  }

  export type HardwareUpsertWithoutFirstHardwareOfInput = {
    update: XOR<HardwareUpdateWithoutFirstHardwareOfInput, HardwareUncheckedUpdateWithoutFirstHardwareOfInput>
    create: XOR<HardwareCreateWithoutFirstHardwareOfInput, HardwareUncheckedCreateWithoutFirstHardwareOfInput>
  }

  export type HardwareUpdateWithoutFirstHardwareOfInput = {
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
    user?: UserUpdateOneRequiredWithoutHardwaresNestedInput
    hardwareType?: HardwareTypeUpdateOneRequiredWithoutHardwaresNestedInput
    hardwareDocuments?: HardwareDocumentUpdateManyWithoutHardwareNestedInput
    hardwareComments?: HardwareCommentUpdateManyWithoutHardwareNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutHardwareNestedInput
    secondHardwares?: Hardware_HardwareUpdateManyWithoutSecondHardwareNestedInput
  }

  export type HardwareUncheckedUpdateWithoutFirstHardwareOfInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
    userId?: IntFieldUpdateOperationsInput | number
    hardwareTypeId?: IntFieldUpdateOperationsInput | number
    hardwareDocuments?: HardwareDocumentUncheckedUpdateManyWithoutHardwareNestedInput
    hardwareComments?: HardwareCommentUncheckedUpdateManyWithoutHardwareNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutHardwareNestedInput
    secondHardwares?: Hardware_HardwareUncheckedUpdateManyWithoutSecondHardwareNestedInput
  }

  export type HardwareUpsertWithoutSecondHardwaresInput = {
    update: XOR<HardwareUpdateWithoutSecondHardwaresInput, HardwareUncheckedUpdateWithoutSecondHardwaresInput>
    create: XOR<HardwareCreateWithoutSecondHardwaresInput, HardwareUncheckedCreateWithoutSecondHardwaresInput>
  }

  export type HardwareUpdateWithoutSecondHardwaresInput = {
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
    user?: UserUpdateOneRequiredWithoutHardwaresNestedInput
    hardwareType?: HardwareTypeUpdateOneRequiredWithoutHardwaresNestedInput
    hardwareDocuments?: HardwareDocumentUpdateManyWithoutHardwareNestedInput
    hardwareComments?: HardwareCommentUpdateManyWithoutHardwareNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutHardwareNestedInput
    firstHardwareOf?: Hardware_HardwareUpdateManyWithoutFirstHardwareNestedInput
  }

  export type HardwareUncheckedUpdateWithoutSecondHardwaresInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
    userId?: IntFieldUpdateOperationsInput | number
    hardwareTypeId?: IntFieldUpdateOperationsInput | number
    hardwareDocuments?: HardwareDocumentUncheckedUpdateManyWithoutHardwareNestedInput
    hardwareComments?: HardwareCommentUncheckedUpdateManyWithoutHardwareNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutHardwareNestedInput
    firstHardwareOf?: Hardware_HardwareUncheckedUpdateManyWithoutFirstHardwareNestedInput
  }

  export type UserUpsertWithoutHardware_hardwareInput = {
    update: XOR<UserUpdateWithoutHardware_hardwareInput, UserUncheckedUpdateWithoutHardware_hardwareInput>
    create: XOR<UserCreateWithoutHardware_hardwareInput, UserUncheckedCreateWithoutHardware_hardwareInput>
  }

  export type UserUpdateWithoutHardware_hardwareInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    articles?: ArticleUpdateManyWithoutUserNestedInput
    articleDocuments?: ArticleDocumentUpdateManyWithoutUserNestedInput
    articleComments?: ArticleCommentUpdateManyWithoutUserNestedInput
    hardwares?: HardwareUpdateManyWithoutUserNestedInput
    hardwareDocuments?: HardwareDocumentUpdateManyWithoutUserNestedInput
    hardwareComments?: HardwareCommentUpdateManyWithoutUserNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHardware_hardwareInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    articles?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    articleDocuments?: ArticleDocumentUncheckedUpdateManyWithoutUserNestedInput
    articleComments?: ArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    hardwares?: HardwareUncheckedUpdateManyWithoutUserNestedInput
    hardwareDocuments?: HardwareDocumentUncheckedUpdateManyWithoutUserNestedInput
    hardwareComments?: HardwareCommentUncheckedUpdateManyWithoutUserNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyRoleInput = {
    id?: number
    firstname: string
    lastname: string
    username: string
    email: string
    password: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserUpdateWithoutRoleInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    articles?: ArticleUpdateManyWithoutUserNestedInput
    articleDocuments?: ArticleDocumentUpdateManyWithoutUserNestedInput
    articleComments?: ArticleCommentUpdateManyWithoutUserNestedInput
    hardwares?: HardwareUpdateManyWithoutUserNestedInput
    hardwareDocuments?: HardwareDocumentUpdateManyWithoutUserNestedInput
    hardwareComments?: HardwareCommentUpdateManyWithoutUserNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutUserNestedInput
    hardware_hardware?: Hardware_HardwareUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    articles?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    articleDocuments?: ArticleDocumentUncheckedUpdateManyWithoutUserNestedInput
    articleComments?: ArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    hardwares?: HardwareUncheckedUpdateManyWithoutUserNestedInput
    hardwareDocuments?: HardwareDocumentUncheckedUpdateManyWithoutUserNestedInput
    hardwareComments?: HardwareCommentUncheckedUpdateManyWithoutUserNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutUserNestedInput
    hardware_hardware?: Hardware_HardwareUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArticleCreateManyArticleTypeInput = {
    id?: number
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    userId: number
    articleId?: number | null
  }

  export type ArticleUpdateWithoutArticleTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutArticlesNestedInput
    article?: ArticleUpdateOneWithoutArticlesNestedInput
    articles?: ArticleUpdateManyWithoutArticleNestedInput
    articleDocuments?: ArticleDocumentUpdateManyWithoutArticleNestedInput
    articleComments?: ArticleCommentUpdateManyWithoutArticleNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutArticleTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    articles?: ArticleUncheckedUpdateManyWithoutArticleNestedInput
    articleDocuments?: ArticleDocumentUncheckedUpdateManyWithoutArticleNestedInput
    articleComments?: ArticleCommentUncheckedUpdateManyWithoutArticleNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateManyWithoutArticlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HardwareCreateManyHardwareTypeInput = {
    id?: number
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    userId: number
  }

  export type HardwareUpdateWithoutHardwareTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
    user?: UserUpdateOneRequiredWithoutHardwaresNestedInput
    hardwareDocuments?: HardwareDocumentUpdateManyWithoutHardwareNestedInput
    hardwareComments?: HardwareCommentUpdateManyWithoutHardwareNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutHardwareNestedInput
    firstHardwareOf?: Hardware_HardwareUpdateManyWithoutFirstHardwareNestedInput
    secondHardwares?: Hardware_HardwareUpdateManyWithoutSecondHardwareNestedInput
  }

  export type HardwareUncheckedUpdateWithoutHardwareTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
    userId?: IntFieldUpdateOperationsInput | number
    hardwareDocuments?: HardwareDocumentUncheckedUpdateManyWithoutHardwareNestedInput
    hardwareComments?: HardwareCommentUncheckedUpdateManyWithoutHardwareNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutHardwareNestedInput
    firstHardwareOf?: Hardware_HardwareUncheckedUpdateManyWithoutFirstHardwareNestedInput
    secondHardwares?: Hardware_HardwareUncheckedUpdateManyWithoutSecondHardwareNestedInput
  }

  export type HardwareUncheckedUpdateManyWithoutHardwaresInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ArticleDocumentCreateManyDocumentTypeInput = {
    id?: number
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    userId: number
    articleId: number
  }

  export type HardwareDocumentCreateManyDocumentTypeInput = {
    id?: number
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    userId: number
    hardwareId: number
  }

  export type ArticleDocumentUpdateWithoutDocumentTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutArticleDocumentsNestedInput
    article?: ArticleUpdateOneRequiredWithoutArticleDocumentsNestedInput
  }

  export type ArticleDocumentUncheckedUpdateWithoutDocumentTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
  }

  export type ArticleDocumentUncheckedUpdateManyWithoutArticleDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
  }

  export type HardwareDocumentUpdateWithoutDocumentTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHardwareDocumentsNestedInput
    hardware?: HardwareUpdateOneRequiredWithoutHardwareDocumentsNestedInput
  }

  export type HardwareDocumentUncheckedUpdateWithoutDocumentTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    hardwareId?: IntFieldUpdateOperationsInput | number
  }

  export type HardwareDocumentUncheckedUpdateManyWithoutHardwareDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    hardwareId?: IntFieldUpdateOperationsInput | number
  }

  export type ArticleCreateManyUserInput = {
    id?: number
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    articleTypeId: number
    articleId?: number | null
  }

  export type ArticleDocumentCreateManyUserInput = {
    id?: number
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    documentTypeId: number
    articleId: number
  }

  export type ArticleCommentCreateManyUserInput = {
    id?: number
    content: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    articleId: number
  }

  export type HardwareCreateManyUserInput = {
    id?: number
    name: string
    brand: string
    subDescription: string
    description: string
    isDiy: boolean
    creationDate: Date | string
    discontinuationDate?: Date | string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    commercialLinks?: HardwareCreatecommercialLinksInput | Enumerable<string>
    hardwareTypeId: number
  }

  export type HardwareDocumentCreateManyUserInput = {
    id?: number
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    documentTypeId: number
    hardwareId: number
  }

  export type HardwareCommentCreateManyUserInput = {
    id?: number
    content: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    hardwareId: number
  }

  export type Article_HardwareCreateManyUserInput = {
    assigneddAt?: Date | string
    articleId: number
    hardwareId: number
  }

  export type Hardware_HardwareCreateManyUserInput = {
    assigneddAt?: Date | string
    firstHardwareId: number
    secondHardwareId: number
  }

  export type ArticleUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    articleType?: ArticleTypeUpdateOneRequiredWithoutArticlesNestedInput
    article?: ArticleUpdateOneWithoutArticlesNestedInput
    articles?: ArticleUpdateManyWithoutArticleNestedInput
    articleDocuments?: ArticleDocumentUpdateManyWithoutArticleNestedInput
    articleComments?: ArticleCommentUpdateManyWithoutArticleNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    articleTypeId?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    articles?: ArticleUncheckedUpdateManyWithoutArticleNestedInput
    articleDocuments?: ArticleDocumentUncheckedUpdateManyWithoutArticleNestedInput
    articleComments?: ArticleCommentUncheckedUpdateManyWithoutArticleNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleDocumentUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentType?: DocumentTypeUpdateOneRequiredWithoutArticleDocumentsNestedInput
    article?: ArticleUpdateOneRequiredWithoutArticleDocumentsNestedInput
  }

  export type ArticleDocumentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentTypeId?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
  }

  export type ArticleCommentUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article?: ArticleUpdateOneRequiredWithoutArticleCommentsNestedInput
  }

  export type ArticleCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    articleId?: IntFieldUpdateOperationsInput | number
  }

  export type ArticleCommentUncheckedUpdateManyWithoutArticleCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    articleId?: IntFieldUpdateOperationsInput | number
  }

  export type HardwareUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
    hardwareType?: HardwareTypeUpdateOneRequiredWithoutHardwaresNestedInput
    hardwareDocuments?: HardwareDocumentUpdateManyWithoutHardwareNestedInput
    hardwareComments?: HardwareCommentUpdateManyWithoutHardwareNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutHardwareNestedInput
    firstHardwareOf?: Hardware_HardwareUpdateManyWithoutFirstHardwareNestedInput
    secondHardwares?: Hardware_HardwareUpdateManyWithoutSecondHardwareNestedInput
  }

  export type HardwareUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDiy?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discontinuationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commercialLinks?: HardwareUpdatecommercialLinksInput | Enumerable<string>
    hardwareTypeId?: IntFieldUpdateOperationsInput | number
    hardwareDocuments?: HardwareDocumentUncheckedUpdateManyWithoutHardwareNestedInput
    hardwareComments?: HardwareCommentUncheckedUpdateManyWithoutHardwareNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutHardwareNestedInput
    firstHardwareOf?: Hardware_HardwareUncheckedUpdateManyWithoutFirstHardwareNestedInput
    secondHardwares?: Hardware_HardwareUncheckedUpdateManyWithoutSecondHardwareNestedInput
  }

  export type HardwareDocumentUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentType?: DocumentTypeUpdateOneRequiredWithoutHardwareDocumentNestedInput
    hardware?: HardwareUpdateOneRequiredWithoutHardwareDocumentsNestedInput
  }

  export type HardwareDocumentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentTypeId?: IntFieldUpdateOperationsInput | number
    hardwareId?: IntFieldUpdateOperationsInput | number
  }

  export type HardwareDocumentUncheckedUpdateManyWithoutHardwareDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentTypeId?: IntFieldUpdateOperationsInput | number
    hardwareId?: IntFieldUpdateOperationsInput | number
  }

  export type HardwareCommentUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hardware?: HardwareUpdateOneRequiredWithoutHardwareCommentsNestedInput
  }

  export type HardwareCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hardwareId?: IntFieldUpdateOperationsInput | number
  }

  export type HardwareCommentUncheckedUpdateManyWithoutHardwareCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hardwareId?: IntFieldUpdateOperationsInput | number
  }

  export type Article_HardwareUpdateWithoutUserInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: ArticleUpdateOneRequiredWithoutArticle_hardwareNestedInput
    hardware?: HardwareUpdateOneRequiredWithoutArticle_hardwareNestedInput
  }

  export type Article_HardwareUncheckedUpdateWithoutUserInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articleId?: IntFieldUpdateOperationsInput | number
    hardwareId?: IntFieldUpdateOperationsInput | number
  }

  export type Article_HardwareUncheckedUpdateManyWithoutArticle_hardwareInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articleId?: IntFieldUpdateOperationsInput | number
    hardwareId?: IntFieldUpdateOperationsInput | number
  }

  export type Hardware_HardwareUpdateWithoutUserInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstHardware?: HardwareUpdateOneRequiredWithoutFirstHardwareOfNestedInput
    secondHardware?: HardwareUpdateOneRequiredWithoutSecondHardwaresNestedInput
  }

  export type Hardware_HardwareUncheckedUpdateWithoutUserInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstHardwareId?: IntFieldUpdateOperationsInput | number
    secondHardwareId?: IntFieldUpdateOperationsInput | number
  }

  export type Hardware_HardwareUncheckedUpdateManyWithoutHardware_hardwareInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstHardwareId?: IntFieldUpdateOperationsInput | number
    secondHardwareId?: IntFieldUpdateOperationsInput | number
  }

  export type ArticleCreateManyArticleInput = {
    id?: number
    name: string
    subDescription: string
    description: string
    isPublished: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    userId: number
    articleTypeId: number
  }

  export type ArticleDocumentCreateManyArticleInput = {
    id?: number
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    documentTypeId: number
    userId: number
  }

  export type ArticleCommentCreateManyArticleInput = {
    id?: number
    content: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    userId: number
  }

  export type Article_HardwareCreateManyArticleInput = {
    assigneddAt?: Date | string
    hardwareId: number
    userId: number
  }

  export type ArticleUpdateWithoutArticleInput = {
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutArticlesNestedInput
    articleType?: ArticleTypeUpdateOneRequiredWithoutArticlesNestedInput
    articles?: ArticleUpdateManyWithoutArticleNestedInput
    articleDocuments?: ArticleDocumentUpdateManyWithoutArticleNestedInput
    articleComments?: ArticleCommentUpdateManyWithoutArticleNestedInput
    article_hardware?: Article_HardwareUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    articleTypeId?: IntFieldUpdateOperationsInput | number
    articles?: ArticleUncheckedUpdateManyWithoutArticleNestedInput
    articleDocuments?: ArticleDocumentUncheckedUpdateManyWithoutArticleNestedInput
    articleComments?: ArticleCommentUncheckedUpdateManyWithoutArticleNestedInput
    article_hardware?: Article_HardwareUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleDocumentUpdateWithoutArticleInput = {
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentType?: DocumentTypeUpdateOneRequiredWithoutArticleDocumentsNestedInput
    user?: UserUpdateOneRequiredWithoutArticleDocumentsNestedInput
  }

  export type ArticleDocumentUncheckedUpdateWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentTypeId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ArticleCommentUpdateWithoutArticleInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutArticleCommentsNestedInput
  }

  export type ArticleCommentUncheckedUpdateWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type Article_HardwareUpdateWithoutArticleInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hardware?: HardwareUpdateOneRequiredWithoutArticle_hardwareNestedInput
    user?: UserUpdateOneRequiredWithoutArticle_hardwareNestedInput
  }

  export type Article_HardwareUncheckedUpdateWithoutArticleInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hardwareId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type HardwareDocumentCreateManyHardwareInput = {
    id?: number
    name: string
    mimetype: string
    buffer: Buffer
    size: number
    createdAt?: Date | string
    documentTypeId: number
    userId: number
  }

  export type HardwareCommentCreateManyHardwareInput = {
    id?: number
    content: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    modifiedAt?: Date | string | null
    userId: number
  }

  export type Article_HardwareCreateManyHardwareInput = {
    assigneddAt?: Date | string
    articleId: number
    userId: number
  }

  export type Hardware_HardwareCreateManyFirstHardwareInput = {
    assigneddAt?: Date | string
    secondHardwareId: number
    userId: number
  }

  export type Hardware_HardwareCreateManySecondHardwareInput = {
    assigneddAt?: Date | string
    firstHardwareId: number
    userId: number
  }

  export type HardwareDocumentUpdateWithoutHardwareInput = {
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentType?: DocumentTypeUpdateOneRequiredWithoutHardwareDocumentNestedInput
    user?: UserUpdateOneRequiredWithoutHardwareDocumentsNestedInput
  }

  export type HardwareDocumentUncheckedUpdateWithoutHardwareInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    buffer?: BytesFieldUpdateOperationsInput | Buffer
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentTypeId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type HardwareCommentUpdateWithoutHardwareInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutHardwareCommentsNestedInput
  }

  export type HardwareCommentUncheckedUpdateWithoutHardwareInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type Article_HardwareUpdateWithoutHardwareInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: ArticleUpdateOneRequiredWithoutArticle_hardwareNestedInput
    user?: UserUpdateOneRequiredWithoutArticle_hardwareNestedInput
  }

  export type Article_HardwareUncheckedUpdateWithoutHardwareInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articleId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type Hardware_HardwareUpdateWithoutFirstHardwareInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    secondHardware?: HardwareUpdateOneRequiredWithoutSecondHardwaresNestedInput
    user?: UserUpdateOneRequiredWithoutHardware_hardwareNestedInput
  }

  export type Hardware_HardwareUncheckedUpdateWithoutFirstHardwareInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    secondHardwareId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type Hardware_HardwareUncheckedUpdateManyWithoutFirstHardwareOfInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    secondHardwareId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type Hardware_HardwareUpdateWithoutSecondHardwareInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstHardware?: HardwareUpdateOneRequiredWithoutFirstHardwareOfNestedInput
    user?: UserUpdateOneRequiredWithoutHardware_hardwareNestedInput
  }

  export type Hardware_HardwareUncheckedUpdateWithoutSecondHardwareInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstHardwareId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type Hardware_HardwareUncheckedUpdateManyWithoutSecondHardwaresInput = {
    assigneddAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstHardwareId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}